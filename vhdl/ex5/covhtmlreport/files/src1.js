var g_data = {"name":"avmm_pkg.vhd","src":"library ieee;\n  use ieee.std_logic_1164.all;\n  use ieee.numeric_std.all;\n\nlibrary osvvm;\n  context osvvm.OsvvmContext;\n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ; \n\npackage avmm_pkg is\n\n  type AvmmPinoutT is record\n    address            : std_logic_vector;\n    writedata          : std_logic_vector;\n    readdata           : std_logic_vector;\n    byteenable         : std_logic_vector;\n    read               : std_logic;\n    write              : std_logic;\n  end record;\n\n  procedure AvmmWrite(signal trans: inout AddressBusRecType; addr, data, byte_enable: std_logic_vector);\n  procedure AvmmRead(signal trans: inout AddressBusRecType; addr, byte_enable: std_logic_vector; variable read_data: out std_logic_vector);\n  procedure AvmmReadModifyWrite(signal trans: inout AddressBusRecType; addr, data, write_mask: std_logic_vector);\n\n  /*\n    type AddressBusRecType is record\n    -- Handshaking controls\n    --   Used by RequestTransaction in the Transaction Procedures\n    --   Used by WaitForTransaction in the Verification Component\n    --   RequestTransaction and WaitForTransaction are in osvvm.TbUtilPkg\n    Rdy                : RdyType ;\n    Ack                : AckType ;\n    -- Transaction Type\n    Operation          : AddressBusOperationType ;\n    -- Address to verification component and its width\n    -- Width may be smaller than Address\n    Address            : std_logic_vector_max_c ;\n    AddrWidth          : integer_max ;\n    -- Data to and from the verification component and its width.\n    -- Width will be smaller than Data for byte operations\n    -- Width size requirements are enforced in the verification component\n    DataToModel        : std_logic_vector_max_c ;\n    DataFromModel      : std_logic_vector_max_c ;\n    DataWidth          : integer_max ;\n    -- Burst FIFOs\n    WriteBurstFifo     : ScoreboardIdType ; \n    ReadBurstFifo      : ScoreboardIdType ; \n    --    UseCheckFifo       : boolean_max ; \n    --    CheckFifo          : ScoreboardIdType ; \n    -- Parameters - internal settings for the VC in a singleton data structure   \n    Params             : ModelParametersIDType ;  \n    -- StatusMsgOn provides transaction messaging override.\n    -- When true, print transaction messaging independent of \n    -- other verification based based controls.\n    StatusMsgOn        : boolean_max ;\n    -- Verification Component Options Parameters - used by SetModelOptions\n    IntToModel         : integer_max ;\n    IntFromModel       : integer_max ; \n    BoolToModel        : boolean_max ; \n    BoolFromModel      : boolean_max ;\n    TimeToModel        : time_max ; \n    TimeFromModel      : time_max ; \n    -- Verification Component Options Type  \n    Options            : integer_max ;  \n    end record AddressBusRecType ;\n  */\n\n  subtype AvmmRecType is AddressBusRecType(\n    Address(4 downto 0),\n    DataToModel(15 downto 0),\n    DataFromModel(15 downto 0)\n  );\n  subtype AvmmPinoutR is AvmmPinoutT(    \n    address(4 downto 0),\n    writedata(15 downto 0),\n    readdata(15 downto 0),\n    byteenable(1 downto 0)\n    );\n\n  function to_string(val: AvmmPinoutT) return string;\n  function Match (\n    constant  Actual          : in    AvmmPinoutT ;\n    constant  Expected        : in    AvmmPinoutT\n  ) return boolean; \nend package;\n\npackage body avmm_pkg is\n  function to_string(val: AvmmPinoutT) return string is\n  begin\n    return \"AvmmPinoutT: address(0x\" & to_string(val.address) &\n      \") writedata(0x\" & to_string(val.writedata)  &\n      \") readdata(0x\" & to_string(val.readdata) &\n      \") byteenable(0x\" & to_string(val.byteenable) &\n      \") read(\" & to_string(val.read) &\n      \") write(\" & to_string(val.write) & \");\";\n  end function;\n\n  function Match (\n      constant  Actual   : in AvmmPinoutT ;\n      constant  Expected : in AvmmPinoutT\n    ) return boolean is\n  begin\n    return (Actual.address = Expected.address) and\n           (Actual.write = '0' -- dont care otherwise\n              or (Actual.write = '1' and Actual.writedata = Expected.writedata)) and \n           (Actual.read = '0' -- dont care otherwise\n              or (Actual.read = '1' and Actual.readdata = Expected.readdata)) and \n           (Actual.byteenable = Expected.byteenable) and\n           (Actual.read = Expected.read) and\n           (Actual.write = Expected.write);\n  end function;\n\n  procedure AvmmWrite(signal trans: inout AddressBusRecType; addr, data, byte_enable: std_logic_vector) is\n  begin\n    -- Enter your code here\n    trans.intToModel <= to_integer(unsigned(byte_enable));\n    write(trans, addr, data);\n  end procedure;\n\n  procedure AvmmRead(signal trans: inout AddressBusRecType; addr, byte_enable: std_logic_vector; variable read_data: out std_logic_vector) is\n    variable data : std_logic_vector(trans.dataFromModel'range) := (others => '0');\n  begin\n    -- Enter your code here\n    trans.intToModel <= to_integer(unsigned(byte_enable));\n    read(trans, addr, data);\n    read_data := data;\n  end procedure;\n\n  procedure AvmmReadModifyWrite(signal trans: inout AddressBusRecType; addr, data, write_mask: std_logic_vector) is\n    variable data_r : std_logic_vector(trans.dataFromModel'range) := (others => '0');\n    variable byte_enable : std_logic_vector(trans.dataFromModel'length - 1 / 8 downto 0) := (others => '0');\n  begin\n    for i in 0 to write_mask'length / 8 - 1 loop\n      if unsigned(write_mask(i*8 to (i+1)*8-1)) > 0 then\n        byte_enable(write_mask'length / 8 - 1 - i) := '1';\n      end if;\n    end loop;\n\n    trans.intToModel <= to_integer(unsigned(byte_enable));\n    read(trans, addr, data_r);\n    -- additonal step, not done by avmm\n    data_r := (data_r and not write_mask) or (data and write_mask);\n    write(trans, addr, data_r);\n  end procedure;\n  \nend package body;","lang":"vhdl"};
processSrcData(g_data);