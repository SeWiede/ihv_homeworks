var g_data = {"name":"ex5.vhd","src":"library common_lib;\ncontext common_lib.common_context;\nuse work.avmm_pkg.all;\n\nentity ex5 is\nend entity;\n\narchitecture behav of ex5 is\n\n  -- Define clk_i, trans_io and pins_io with the correct constrained data types\n  -- Enter your code here\n  signal trans_io : AvmmRecType;\n  signal clk_i : std_logic;\n  signal pins_io : AvmmPinoutR;\n\n  package ScoreBoardAVMM is new OSVVM.ScoreboardGenericPkg generic map( \n      AvmmPinoutT,\n      AvmmPinoutT,\n      Match,\n      to_string,\n      to_string\n    );\n    use ScoreBoardAVMM.all;\n\n    signal avmmScoreBoardID : ScoreBoardIDType; \n\n    constant IDLE_PINS : AvmmPinoutR := (\n      address => (others => '0'),\n      writedata => (others => '0'),\n      readdata => (others => '0'),\n      byteenable => (others => '0'),\n      read => '0',\n      write => '0'\n    );\n\n    signal testdone : std_logic;\n\n    -- simulating target memory\n    type ram_t is array (0 to pins_io.address'length-1) of std_logic_vector(pins_io.writedata'range);\n    signal ram : ram_t := (others => (others => '0'));\n\nbegin\n\n  CreateClock(clk_i, 10 ns);\n\n  avmm_vu_inst: entity work.avmm_vu\n    port map (\n      trans_io => trans_io,\n      clk_i    => clk_i,\n      pins_io  => pins_io\n    );\n\n  stimuli_p: process is\n    variable poppedPins : AvmmPinoutR;\n    variable read_data: std_logic_vector(pins_io.readdata'range);\n  begin\n    -- Implement your main testbench code here\n    -- Enter your code here\n    Log(\"**********************************\");\n    avmmScoreBoardID <= newId(\"AVMM Scoreboard\");\n    waitForClock(clk_i);\n    Log(\"***********Check Empty************\");\n\n    push(avmmScoreBoardID, IDLE_PINS);\n    check(avmmScoreBoardID, IDLE_PINS);\n\n    Log(\"***********Check Write************\");\n    waitForClock(clk_i);\n    push(avmmScoreBoardID, (\n      address => \"00001\",\n      writedata => x\"aa55\",\n      readdata => x\"----\",\n      byteenable => \"11\",\n      read => '0',\n      write => '1'\n    ));\n    AvmmWrite(trans_io, \"00001\", x\"aa55\", \"11\");\n\n    Log(\"***********Check Write************\");\n    waitForClock(clk_i);\n    push(avmmScoreBoardID, (\n      address => \"00001\",\n      writedata => x\"aa55\",\n      readdata => x\"----\",\n      byteenable => \"11\",\n      read => '0',\n      write => '1'\n    ));\n    AvmmWrite(trans_io, \"00001\", x\"aa55\", \"11\");\n\n    Log(\"***********Check Read************\");\n    waitForClock(clk_i);\n    push(avmmScoreBoardID, (\n      address => \"00001\",\n      writedata => x\"----\",\n      readdata => x\"aa55\",\n      byteenable => \"11\",\n      read => '1',\n      write => '0'\n    ));\n    AvmmRead(trans_io, \"00001\", \"11\", read_data); \n    waitForClock(clk_i, 5);\n\n    Log(\"*****Check Read Modify Write*****\");\n    waitForClock(clk_i);\n    push(avmmScoreBoardID, ( -- cycle 2 read\n      address => \"00001\",\n      writedata => x\"----\",\n      readdata => x\"aa00\",\n      byteenable => \"10\",\n      read => '1',\n      write => '0'\n    ));\n    push(avmmScoreBoardID, (\n      address => \"00001\",\n      writedata => x\"5500\",\n      readdata => x\"----\",\n      byteenable => \"10\",\n      read => '0',\n      write => '1'\n    ));\n    AvmmReadModifyWrite(trans_io, \"00001\", x\"5511\", x\"ff00\");\n    waitForClock(clk_i);\n    waitForClock(clk_i);\n\n  --  procedure AvmmWrite(signal trans: inout AddressBusRecType; addr, data, byte_enable: std_logic_vector) is\n  --  procedure AvmmRead(signal trans: inout AddressBusRecType; addr, byte_enable: std_logic_vector; variable read_data: out std_logic_vector) is\n  --  procedure AvmmReadModifyWrite(signal trans: inout AddressBusRecType; addr, data, write_mask: std_logic_vector) is\n\n    ReportAlerts ;\n    Log(\"***************DONE***************\");\n    std.env.stop;\n    wait ; \n  end process;\n\n  -- just a process that handles expected reads\n  expected_read_p: process\n  begin\n    wait until pins_io.read = '1';\n    pins_io.readdata <= x\"aa55\";\n    wait until pins_io.read = '1';\n    pins_io.readdata <= x\"aa00\";  \n  end process;\n\n  check_reads_p: process\n    variable masked : std_logic_vector(pins_io.writedata'range);\n  begin\n    wait until pins_io.read = '1';\n\n    waitForClock(clk_i, 2);\n    check(avmmScoreBoardID, pins_io);\n  end process;\n\n  check_writes_p: process\n    variable masked : std_logic_vector(pins_io.writedata'range);\n  begin\n    wait until pins_io.write = '1';\n\n    check(avmmScoreBoardID, pins_io);\n    waitForClock(clk_i);\n  end process;\n\nend architecture;","lang":"vhdl"};
processSrcData(g_data);