Coverage Report by file with details

=================================================================================
=== File: ../osvvm/Common/src/AddressBusResponderTransactionArrayPkg.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      77         0        77     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/AddressBusResponderTransactionArrayPkg.vhd --

    1                                                --
    2                                                --  File Name:         AddressBusResponderTransactionArrayPkg.vhd
    3                                                --  Design Unit Name:  AddressBusResponderTransactionArrayPkg
    4                                                --  Revision:          OSVVM MODELS STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com
    7                                                --  Contributor(s):
    8                                                --     Jim Lewis      jim@synthworks.com
    9                                                --
    10                                               --
    11                                               --  Description:
    12                                               --      Defines types, constants, and subprograms used by
    13                                               --      OSVVM Address Bus Slave Transaction Based Models (aka: TBM, TLM, VVC)
    14                                               --
    15                                               --
    16                                               --  Developed by:
    17                                               --        SynthWorks Design Inc.
    18                                               --        VHDL Training Classes
    19                                               --        http://www.SynthWorks.com
    20                                               --
    21                                               --  Revision History:
    22                                               --    Date      Version    Description
    23                                               --    11/2022   2022.11    Initial.  Derived from AddressBusResponderTransactionPkg
    24                                               --
    25                                               --  This file is part of OSVVM.
    26                                               --
    27                                               --  Copyright (c) 2022 by SynthWorks Design Inc.
    28                                               --
    29                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    30                                               --  you may not use this file except in compliance with the License.
    31                                               --  You may obtain a copy of the License at
    32                                               --
    33                                               --      https://www.apache.org/licenses/LICENSE-2.0
    34                                               --
    35                                               --  Unless required by applicable law or agreed to in writing, software
    36                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    37                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    38                                               --  See the License for the specific language governing permissions and
    39                                               --  limitations under the License.
    40                                               --
    41                                               
    42                                               library ieee ;
    43                                                 use ieee.std_logic_1164.all ;
    44                                                 use ieee.numeric_std.all ;
    45                                                 use ieee.numeric_std_unsigned.all ;
    46                                                 use ieee.math_real.all ;
    47                                               
    48                                               library osvvm ;
    49                                                   context osvvm.OsvvmContext ;
    50                                                   
    51                                                 use work.AddressBusTransactionPkg.all; 
    52                                                 use work.AddressBusTransactionArrayPkg.AddressBusArrayRequestTransaction; 
    53                                               
    54                                               package AddressBusResponderTransactionArrayPkg is
    55                                                 -- ========================================================
    56                                                 --  Types of Transactions
    57                                                 --  A transaction may be either a directive or an interface transaction.
    58                                                 --
    59                                                 --  Directive transactions interact with the verification component 
    60                                                 --  without generating any transactions or interface waveforms.
    61                                                 --
    62                                                 --  An interface transaction results in interface signaling to the DUT.
    63                                                 --
    64                                                 --  A blocking transaction is an interface transaction that does not 
    65                                                 --  does not return (complete) until the interface operation   
    66                                                 --  requested by the transaction has completed.
    67                                                 --
    68                                                 --  An asynchronous transaction is nonblocking interface transaction
    69                                                 --  that returns before the transaction has completed - typically 
    70                                                 --  immediately and before the transaction has started. 
    71                                                 --
    72                                                 --  A Try transaction is nonblocking interface transaction that 
    73                                                 --  checks to see if transaction information is available, 
    74                                                 --  such as read data, and if it is returns it.  
    75                                                 --
    76                                                 -- ========================================================
    77                                                 
    78                                                 
    79                                                 -- ========================================================
    80                                                 --  Interface Independent Transactions
    81                                                 --  These transactions work independent of the interface.
    82                                                 --  Recommended for all tests that verify internal design functionality.
    83                                                 --  Many are blocking transactions which do not return (complete)
    84                                                 --  until the interface operation requested by the transaction  
    85                                                 --  has completed.
    86                                                 --  Some are asynchronous, which means they return before the
    87                                                 --  transaction is complete - typically even before it starts.
    88                                                 --  Supported by all verification components
    89                                                 -- ========================================================
    90                                                 ------------------------------------------------------------
    91                                                 procedure GetWrite (
    92                                                 -- Blocking write transaction.  
    93                                                 -- Block until the write address and data are available.
    94                                                 -- oData variable should be sized to match the size of the data 
    95                                                 -- being transferred.
    96                                                 ------------------------------------------------------------
    97                                                   signal   TransactionRec  : InOut AddressBusRecArrayType ;
    98                                                   constant Index           : In    integer   ;
    99                                                   variable oAddr           : Out   std_logic_vector ;
    100                                                  variable oData           : Out   std_logic_vector ;
    101                                                  constant StatusMsgOn     : In    boolean := false
    102                                                ) ;
    103                                                
    104                                                ------------------------------------------------------------
    105                                                procedure TryGetWrite (
    106                                                -- Try write transaction.  
    107                                                -- If a write cycle has already completed return Address and Data, 
    108                                                -- and return Available as TRUE, otherwise, return Available as FALSE. 
    109                                                -- oData variable should be sized to match the size of the data 
    110                                                -- being transferred.
    111                                                ------------------------------------------------------------
    112                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    113                                                  constant Index           : In    integer   ;
    114                                                  variable oAddr           : Out   std_logic_vector ;
    115                                                  variable oData           : Out   std_logic_vector ;
    116                                                  variable Available       : Out   boolean ;
    117                                                  constant StatusMsgOn     : In    boolean := false
    118                                                ) ;
    119                                              
    120                                                ------------------------------------------------------------
    121                                                procedure SendRead (
    122                                                -- Blocking Read transaction.   
    123                                                -- Block until address is available and data is sent.
    124                                                -- iData variable should be sized to match the size of the data 
    125                                                -- being transferred.
    126                                                ------------------------------------------------------------
    127                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    128                                                  constant Index           : In    integer   ;
    129                                                  variable oAddr           : Out   std_logic_vector ;
    130                                                  constant iData           : In    std_logic_vector ;
    131                                                  constant StatusMsgOn     : In    boolean := false
    132                                                ) ;
    133                                                
    134                                                ------------------------------------------------------------
    135                                                procedure TrySendRead (
    136                                                -- Try Read transaction.   
    137                                                -- If a read address already been received return Address, 
    138                                                -- send iData as the read data, and return Available as TRUE,
    139                                                -- otherwise return Available as FALSE.
    140                                                -- iData variable should be sized to match the size of the data 
    141                                                -- being transferred.
    142                                                ------------------------------------------------------------
    143                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    144                                                  constant Index           : In    integer   ;
    145                                                  variable oAddr           : Out   std_logic_vector ;
    146                                                  constant iData           : In    std_logic_vector ;
    147                                                  variable Available       : Out   boolean ;
    148                                                  constant StatusMsgOn     : In    boolean := false
    149                                                ) ;
    150                                                
    151                                                
    152                                                -- ========================================================
    153                                                --  Interface Specific Transactions
    154                                                --  Support split transaction interfaces - such as AXI which
    155                                                --  independently operates the write address, write data, 
    156                                                --  write response, read address, and read data interfaces. 
    157                                                --  For split transaction interfaces, these transactions are 
    158                                                --  required to fully test the interface characteristics.  
    159                                                --  Most of these transactions are asynchronous.  
    160                                                -- ========================================================
    161                                                ------------------------------------------------------------
    162                                                procedure GetWriteAddress (
    163                                                -- Blocking write address transaction.  
    164                                                ------------------------------------------------------------
    165                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    166                                                  constant Index           : In    integer   ;
    167                                                  variable oAddr           : Out   std_logic_vector ;
    168                                                  constant StatusMsgOn     : In    boolean := false
    169                                                ) ;
    170                                                
    171                                                ------------------------------------------------------------
    172                                                procedure TryGetWriteAddress (
    173                                                -- Try write address transaction.  
    174                                                -- If a write address cycle has already completed return oAddr and 
    175                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    176                                                ------------------------------------------------------------
    177                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    178                                                  constant Index           : In    integer   ;
    179                                                  variable oAddr           : Out   std_logic_vector ;
    180                                                  variable Available       : Out   boolean ;
    181                                                  constant StatusMsgOn     : In    boolean := false
    182                                                ) ;
    183                                              
    184                                                ------------------------------------------------------------
    185                                                procedure GetWriteData (
    186                                                -- Blocking write data transaction.  
    187                                                -- oData should be sized to match the size of the data 
    188                                                -- being transferred.  
    189                                                ------------------------------------------------------------
    190                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    191                                                  constant Index           : In    integer   ;
    192                                                  constant iAddr           : In    std_logic_vector ;
    193                                                  variable oData           : Out   std_logic_vector ;
    194                                                  constant StatusMsgOn     : In    boolean := false
    195                                                ) ;
    196                                                
    197                                                ------------------------------------------------------------
    198                                                procedure TryGetWriteData (
    199                                                -- Try write data transaction.  
    200                                                -- If a write data cycle has already completed return oData and 
    201                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    202                                                -- oData should be sized to match the size of the data 
    203                                                -- being transferred.  
    204                                                ------------------------------------------------------------
    205                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    206                                                  constant Index           : In    integer   ;
    207                                                  constant iAddr           : In    std_logic_vector ;
    208                                                  variable oData           : Out   std_logic_vector ;
    209                                                  variable Available       : Out   boolean ;
    210                                                  constant StatusMsgOn     : In    boolean := false
    211                                                ) ;
    212                                                
    213                                                ------------------------------------------------------------
    214                                                procedure GetWriteData (
    215                                                -- Blocking write data transaction.  
    216                                                -- oData should be sized to match the size of the data 
    217                                                -- being transferred.  iAddr = 0
    218                                                ------------------------------------------------------------
    219                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    220                                                  constant Index           : In    integer   ;
    221                                                  variable oData           : Out   std_logic_vector ;
    222                                                  constant StatusMsgOn     : In    boolean := false
    223                                                ) ;
    224                                              
    225                                                ------------------------------------------------------------
    226                                                procedure TryGetWriteData (
    227                                                -- Try write data transaction.  
    228                                                -- If a write data cycle has already completed return oData and 
    229                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    230                                                -- oData should be sized to match the size of the data 
    231                                                -- being transferred.  iAddr = 0
    232                                                ------------------------------------------------------------
    233                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    234                                                  constant Index           : In    integer   ;
    235                                                  variable oData           : Out   std_logic_vector ;
    236                                                  variable Available       : Out   boolean ;
    237                                                  constant StatusMsgOn     : In    boolean := false
    238                                                ) ;
    239                                                
    240                                                ------------------------------------------------------------
    241                                                procedure GetReadAddress (
    242                                                -- Blocking Read address transaction.   
    243                                                ------------------------------------------------------------
    244                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    245                                                  constant Index           : In    integer   ;
    246                                                  variable oAddr           : Out   std_logic_vector ;
    247                                                  constant StatusMsgOn     : In    boolean := false
    248                                                ) ;
    249                                                
    250                                                ------------------------------------------------------------
    251                                                procedure TryGetReadAddress (
    252                                                -- Try read address transaction.  
    253                                                -- If a read address cycle has already completed return oAddr and 
    254                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    255                                                ------------------------------------------------------------
    256                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    257                                                  constant Index           : In    integer   ;
    258                                                  variable oAddr           : Out   std_logic_vector ;
    259                                                  variable Available       : Out   boolean ;
    260                                                  constant StatusMsgOn     : In    boolean := false
    261                                                ) ;
    262                                                
    263                                                ------------------------------------------------------------
    264                                                procedure SendReadData (
    265                                                -- Blocking Send Read Data transaction.  
    266                                                -- iData should be sized to match the size of the data 
    267                                                -- being transferred.
    268                                                ------------------------------------------------------------
    269                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    270                                                  constant Index           : In    integer   ;
    271                                                  constant iData           : In    std_logic_vector ;
    272                                                  constant StatusMsgOn     : In    boolean := false
    273                                                ) ;
    274                                                
    275                                                ------------------------------------------------------------
    276                                                procedure SendReadDataAsync (
    277                                                -- Asynchronous Send Read Data transaction.  
    278                                                -- iData should be sized to match the size of the data 
    279                                                -- being transferred.
    280                                                ------------------------------------------------------------
    281                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    282                                                  constant Index           : In    integer   ;
    283                                                  constant iData           : In    std_logic_vector ;
    284                                                  constant StatusMsgOn     : In    boolean := false
    285                                                ) ;   
    286                                                
    287                                              end package AddressBusResponderTransactionArrayPkg ;
    288                                              
    289                                              -- /////////////////////////////////////////////////////////////////////////////////////////
    290                                              -- /////////////////////////////////////////////////////////////////////////////////////////
    291                                              
    292                                              package body AddressBusResponderTransactionArrayPkg is
    293                                              
    294                                                ------------------------------------------------------------
    295                                                procedure GetWrite (
    296                                                -- Blocks until Address and Data are both available
    297                                                ------------------------------------------------------------
    298                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    299                                                  constant Index           : In    integer   ;
    300                                                  variable oAddr           : Out   std_logic_vector ;
    301                                                  variable oData           : Out   std_logic_vector ;
    302                                                  constant StatusMsgOn     : In    boolean := false
    303                                                ) is
    304                                                begin
    305                                                  -- Put values in record
    306             1                    ***0***         TransactionRec(Index).Operation     <= WRITE_OP ;
    307             1                    ***0***         TransactionRec(Index).AddrWidth     <= oAddr'length ;
    308             1                    ***0***         TransactionRec(Index).DataWidth     <= oData'length ;
    309             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    310             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    311             1                    ***0***         oAddr  := FromTransaction(TransactionRec(Index).Address, oAddr'length) ;
    312             1                    ***0***         oData  := FromTransaction(TransactionRec(Index).DataFromModel, oData'length) ;
    313                                                end procedure GetWrite ;
    314                                              
    315                                                ------------------------------------------------------------
    316                                                procedure TryGetWrite (
    317                                                -- Return address and data if both available otherwise return false
    318                                                ------------------------------------------------------------
    319                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    320                                                  constant Index           : In    integer   ;
    321                                                  variable oAddr           : Out   std_logic_vector ;
    322                                                  variable oData           : Out   std_logic_vector ;
    323                                                  variable Available       : Out   boolean ;
    324                                                  constant StatusMsgOn     : In    boolean := false
    325                                                ) is
    326                                                begin
    327                                                  -- Put values in record
    328             1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_WRITE ;
    329             1                    ***0***         TransactionRec(Index).AddrWidth     <= oAddr'length ;
    330             1                    ***0***         TransactionRec(Index).DataWidth     <= oData'length ;
    331             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    332             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    333             1                    ***0***         oAddr  := FromTransaction(TransactionRec(Index).Address, oAddr'length) ;
    334             1                    ***0***         oData  := FromTransaction(TransactionRec(Index).DataFromModel, oData'length) ;
    335             1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    336                                                end procedure TryGetWrite ;
    337                                              
    338                                                ------------------------------------------------------------
    339                                                procedure GetWriteAddress (
    340                                                -- Blocks until Address is available
    341                                                ------------------------------------------------------------
    342                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    343                                                  constant Index           : In    integer   ;
    344                                                  variable oAddr           : Out   std_logic_vector ;
    345                                                  constant StatusMsgOn     : In    boolean := false
    346                                                ) is
    347                                                begin
    348                                                  -- Put values in record
    349             1                    ***0***         TransactionRec(Index).Operation     <= WRITE_ADDRESS ;
    350             1                    ***0***         TransactionRec(Index).AddrWidth     <= oAddr'length ;
    351             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    352             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    353             1                    ***0***         oAddr  := FromTransaction(TransactionRec(Index).Address, oAddr'length) ;
    354                                                end procedure GetWriteAddress ;
    355                                                
    356                                                ------------------------------------------------------------
    357                                                procedure TryGetWriteAddress (
    358                                                -- Return address if available otherwise return false
    359                                                ------------------------------------------------------------
    360                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    361                                                  constant Index           : In    integer   ;
    362                                                  variable oAddr           : Out   std_logic_vector ;
    363                                                  variable Available       : Out   boolean ;
    364                                                  constant StatusMsgOn     : In    boolean := false
    365                                                ) is
    366                                                begin
    367                                                  -- Put values in record
    368             1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_WRITE_ADDRESS ;
    369             1                    ***0***         TransactionRec(Index).AddrWidth     <= oAddr'length ;
    370             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    371             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    372             1                    ***0***         oAddr  := FromTransaction(TransactionRec(Index).Address, oAddr'length) ;
    373             1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    374                                                end procedure TryGetWriteAddress ;
    375                                              
    376                                                ------------------------------------------------------------
    377                                                procedure GetWriteData (
    378                                                -- Blocking write data transaction.  
    379                                                -- oData should be sized to match the size of the data 
    380                                                -- being transferred.  
    381                                                ------------------------------------------------------------
    382                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    383                                                  constant Index           : In    integer   ;
    384                                                  constant iAddr           : In    std_logic_vector ;
    385                                                  variable oData           : Out   std_logic_vector ;
    386                                                  constant StatusMsgOn     : In    boolean := false
    387                                                ) is
    388                                                  alias aAddr : std_logic_vector(iAddr'length-1 downto 0) is iAddr ;
    389                                                  constant ADDR_LEN : integer := minimum(aAddr'left, 30) ;
    390                                                begin
    391                                                  -- Put values in record
    392             1                    ***0***         TransactionRec(Index).Operation     <= WRITE_DATA ;
    393             1                    ***0***         TransactionRec(Index).AddrWidth     <= to_integer(aAddr(ADDR_LEN downto 0)) ; -- Allows bursts upto 2**31
    394             1                    ***0***         TransactionRec(Index).DataWidth     <= oData'length ;
    395             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    396             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    397             1                    ***0***         oData  := FromTransaction(TransactionRec(Index).DataFromModel, oData'length) ;
    398                                                end procedure GetWriteData ;
    399                                                
    400                                                ------------------------------------------------------------
    401                                                procedure TryGetWriteData (
    402                                                -- Try write data transaction.  
    403                                                -- If a write data cycle has already completed return oData and 
    404                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    405                                                -- oData should be sized to match the size of the data 
    406                                                -- being transferred.  
    407                                                ------------------------------------------------------------
    408                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    409                                                  constant Index           : In    integer   ;
    410                                                  constant iAddr           : In    std_logic_vector ;
    411                                                  variable oData           : Out   std_logic_vector ;
    412                                                  variable Available       : Out   boolean ;
    413                                                  constant StatusMsgOn     : In    boolean := false
    414                                                ) is
    415                                                  alias aAddr : std_logic_vector(iAddr'length-1 downto 0) is iAddr ;
    416                                                  constant ADDR_LEN : integer := minimum(aAddr'left, 30) ;
    417                                                begin
    418                                                  -- Put values in record
    419             1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_WRITE_DATA ;
    420             1                    ***0***         TransactionRec(Index).AddrWidth     <= to_integer(aAddr(ADDR_LEN downto 0)) ; -- Allows bursts upto 2**31
    421             1                    ***0***         TransactionRec(Index).DataWidth     <= oData'length ;
    422             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    423             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    424             1                    ***0***         oData  := FromTransaction(TransactionRec(Index).DataFromModel, oData'length) ;
    425             1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    426                                                end procedure TryGetWriteData ;
    427                                                
    428                                                ------------------------------------------------------------
    429                                                procedure GetWriteData (
    430                                                -- Blocks until Data is available
    431                                                ------------------------------------------------------------
    432                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    433                                                  constant Index           : In    integer   ;
    434                                                  variable oData           : Out   std_logic_vector ;
    435                                                  constant StatusMsgOn     : In    boolean := false
    436                                                ) is
    437                                                begin
    438             1                    ***0***         GetWriteData(TransactionRec, Index, X"00", oData, StatusMsgOn) ;
    439                                                end procedure GetWriteData ;
    440                                              
    441                                                ------------------------------------------------------------
    442                                                procedure TryGetWriteData (
    443                                                -- Return data if available otherwise return false
    444                                                ------------------------------------------------------------
    445                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    446                                                  constant Index           : In    integer   ;
    447                                                  variable oData           : Out   std_logic_vector ;
    448                                                  variable Available       : Out   boolean ;
    449                                                  constant StatusMsgOn     : In    boolean := false
    450                                                ) is
    451                                                begin
    452             1                    ***0***         TryGetWriteData(TransactionRec, Index, X"00", oData, Available, StatusMsgOn) ;
    453                                                end procedure TryGetWriteData ;
    454                                              
    455                                                ------------------------------------------------------------
    456                                                procedure SendRead (
    457                                                -- Block until address is available and data is done
    458                                                ------------------------------------------------------------
    459                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    460                                                  constant Index           : In    integer   ;
    461                                                  variable oAddr           : Out   std_logic_vector ;
    462                                                  constant iData           : In    std_logic_vector ;
    463                                                  constant StatusMsgOn     : In    boolean := false
    464                                                ) is
    465                                                begin
    466                                                  -- Put values in record
    467             1                    ***0***         TransactionRec(Index).Operation     <= READ_OP ;
    468             1                    ***0***         TransactionRec(Index).AddrWidth     <= oAddr'length ;
    469             1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    470             1                    ***0***         TransactionRec(Index).DataToModel   <= ToTransaction(iData, TransactionRec(Index).DataToModel'length) ;
    471             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    472             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    473             1                    ***0***         oAddr  := FromTransaction(TransactionRec(Index).Address, oAddr'length) ;
    474                                                end procedure SendRead ;
    475                                                
    476                                                ------------------------------------------------------------
    477                                                procedure TrySendRead (
    478                                                -- Return address if available, send data if address available
    479                                                ------------------------------------------------------------
    480                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    481                                                  constant Index           : In    integer   ;
    482                                                  variable oAddr           : Out   std_logic_vector ;
    483                                                  constant iData           : In    std_logic_vector ;
    484                                                  variable Available       : Out   boolean ;
    485                                                  constant StatusMsgOn     : In    boolean := false
    486                                                ) is
    487                                                begin
    488                                                  -- Put values in record
    489             1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_READ ;
    490             1                    ***0***         TransactionRec(Index).AddrWidth     <= oAddr'length ;
    491             1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    492             1                    ***0***         TransactionRec(Index).DataToModel   <= ToTransaction(iData, TransactionRec(Index).DataToModel'length) ;
    493             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    494             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    495             1                    ***0***         oAddr  := FromTransaction(TransactionRec(Index).Address, oAddr'length) ;
    496             1                    ***0***         Available  := TransactionRec(Index).BoolFromModel ;
    497                                                end procedure TrySendRead ;
    498                                                  
    499                                                ------------------------------------------------------------
    500                                                procedure GetReadAddress (
    501                                                -- Block until address is available
    502                                                ------------------------------------------------------------
    503                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    504                                                  constant Index           : In    integer   ;
    505                                                  variable oAddr           : Out   std_logic_vector ;
    506                                                  constant StatusMsgOn     : In    boolean := false
    507                                                ) is
    508                                                begin
    509                                                  -- Put values in record
    510             1                    ***0***         TransactionRec(Index).Operation     <= READ_ADDRESS ;
    511             1                    ***0***         TransactionRec(Index).AddrWidth     <= oAddr'length ;
    512             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    513             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    514             1                    ***0***         oAddr  := FromTransaction(TransactionRec(Index).Address, oAddr'length) ;
    515                                                end procedure GetReadAddress ;
    516                                                
    517                                                ------------------------------------------------------------
    518                                                procedure TryGetReadAddress (
    519                                                -- Return read address if available, otherwise return false on Available
    520                                                ------------------------------------------------------------
    521                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    522                                                  constant Index           : In    integer   ;
    523                                                  variable oAddr           : Out   std_logic_vector ;
    524                                                  variable Available       : Out   boolean ;
    525                                                  constant StatusMsgOn     : In    boolean := false
    526                                                ) is
    527                                                begin
    528                                                  -- Put values in record
    529             1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_READ_ADDRESS ;
    530             1                    ***0***         TransactionRec(Index).AddrWidth     <= oAddr'length ;
    531             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    532             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    533             1                    ***0***         oAddr  := FromTransaction(TransactionRec(Index).Address, oAddr'length) ;
    534             1                    ***0***         Available  := TransactionRec(Index).BoolFromModel ;
    535                                                end procedure TryGetReadAddress ;
    536                                                
    537                                                ------------------------------------------------------------
    538                                                procedure SendReadData (
    539                                                -- Block until data is done
    540                                                ------------------------------------------------------------
    541                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    542                                                  constant Index           : In    integer   ;
    543                                                  constant iData           : In    std_logic_vector ;
    544                                                  constant StatusMsgOn     : In    boolean := false
    545                                                ) is
    546                                                begin
    547                                                  -- Put values in record
    548             1                    ***0***         TransactionRec(Index).Operation     <= READ_DATA ;
    549             1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    550             1                    ***0***         TransactionRec(Index).DataToModel   <= ToTransaction(iData, TransactionRec(Index).DataToModel'length) ;
    551             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    552             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    553                                                end procedure SendReadData ;
    554                                                
    555                                                ------------------------------------------------------------
    556                                                procedure SendReadDataAsync (
    557                                                -- Queue Read Data
    558                                                ------------------------------------------------------------
    559                                                  signal   TransactionRec  : InOut AddressBusRecArrayType ;
    560                                                  constant Index           : In    integer   ;
    561                                                  constant iData           : In    std_logic_vector ;
    562                                                  constant StatusMsgOn     : In    boolean := false
    563                                                ) is
    564                                                begin
    565                                                  -- Put values in record
    566             1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_READ_DATA ;
    567             1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    568             1                    ***0***         TransactionRec(Index).DataToModel   <= ToTransaction(iData, TransactionRec(Index).DataToModel'length) ;
    569             1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    570             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    571                                                end procedure SendReadDataAsync ;  
    572                                                
    573                                              end package body AddressBusResponderTransactionArrayPkg ;


=================================================================================
=== File: ../osvvm/Common/src/AddressBusResponderTransactionPkg.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      77         0        77     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/AddressBusResponderTransactionPkg.vhd --

    1                                                --
    2                                                --  File Name:         AddressBusResponderTransactionPkg.vhd
    3                                                --  Design Unit Name:  AddressBusResponderTransactionPkg
    4                                                --  Revision:          OSVVM MODELS STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com
    7                                                --  Contributor(s):
    8                                                --     Jim Lewis      jim@synthworks.com
    9                                                --
    10                                               --
    11                                               --  Description:
    12                                               --      Defines types, constants, and subprograms used by
    13                                               --      OSVVM Address Bus Slave Transaction Based Models (aka: TBM, TLM, VVC)
    14                                               --
    15                                               --
    16                                               --  Developed by:
    17                                               --        SynthWorks Design Inc.
    18                                               --        VHDL Training Classes
    19                                               --        http://www.SynthWorks.com
    20                                               --
    21                                               --  Revision History:
    22                                               --    Date      Version    Description
    23                                               --    09/2017   2017       Initial revision as Axi4LiteTransactionPkg
    24                                               --    01/2020   2020.01    Updated license notice
    25                                               --    02/2020   2020.02    Refactored from Axi4LiteSlaveTransactionPkg
    26                                               --    05/2020   2020.05    Removed Generics due to simulator bugs
    27                                               --    09/2020   2020.09    Updating comments to serve as documentation
    28                                               --
    29                                               --  This file is part of OSVVM.
    30                                               --
    31                                               --  Copyright (c) 2017 - 2020 by SynthWorks Design Inc.
    32                                               --
    33                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    34                                               --  you may not use this file except in compliance with the License.
    35                                               --  You may obtain a copy of the License at
    36                                               --
    37                                               --      https://www.apache.org/licenses/LICENSE-2.0
    38                                               --
    39                                               --  Unless required by applicable law or agreed to in writing, software
    40                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    41                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    42                                               --  See the License for the specific language governing permissions and
    43                                               --  limitations under the License.
    44                                               --
    45                                               
    46                                               library ieee ;
    47                                                 use ieee.std_logic_1164.all ;
    48                                                 use ieee.numeric_std.all ;
    49                                                 use ieee.numeric_std_unsigned.all ;
    50                                                 use ieee.math_real.all ;
    51                                               
    52                                               library osvvm ;
    53                                                   context osvvm.OsvvmContext ;
    54                                                   
    55                                                 use work.AddressBusTransactionPkg.all; 
    56                                               
    57                                               package AddressBusResponderTransactionPkg is
    58                                                 -- ========================================================
    59                                                 --  Types of Transactions
    60                                                 --  A transaction may be either a directive or an interface transaction.
    61                                                 --
    62                                                 --  Directive transactions interact with the verification component 
    63                                                 --  without generating any transactions or interface waveforms.
    64                                                 --
    65                                                 --  An interface transaction results in interface signaling to the DUT.
    66                                                 --
    67                                                 --  A blocking transaction is an interface transaction that does not 
    68                                                 --  does not return (complete) until the interface operation   
    69                                                 --  requested by the transaction has completed.
    70                                                 --
    71                                                 --  An asynchronous transaction is nonblocking interface transaction
    72                                                 --  that returns before the transaction has completed - typically 
    73                                                 --  immediately and before the transaction has started. 
    74                                                 --
    75                                                 --  A Try transaction is nonblocking interface transaction that 
    76                                                 --  checks to see if transaction information is available, 
    77                                                 --  such as read data, and if it is returns it.  
    78                                                 --
    79                                                 -- ========================================================
    80                                                 
    81                                                 
    82                                                 -- ========================================================
    83                                                 --  Interface Independent Transactions
    84                                                 --  These transactions work independent of the interface.
    85                                                 --  Recommended for all tests that verify internal design functionality.
    86                                                 --  Many are blocking transactions which do not return (complete)
    87                                                 --  until the interface operation requested by the transaction  
    88                                                 --  has completed.
    89                                                 --  Some are asynchronous, which means they return before the
    90                                                 --  transaction is complete - typically even before it starts.
    91                                                 --  Supported by all verification components
    92                                                 -- ========================================================
    93                                                 ------------------------------------------------------------
    94                                                 procedure GetWrite (
    95                                                 -- Blocking write transaction.  
    96                                                 -- Block until the write address and data are available.
    97                                                 -- oData variable should be sized to match the size of the data 
    98                                                 -- being transferred.
    99                                                 ------------------------------------------------------------
    100                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    101                                                  variable oAddr           : Out   std_logic_vector ;
    102                                                  variable oData           : Out   std_logic_vector ;
    103                                                  constant StatusMsgOn     : In    boolean := false
    104                                                ) ;
    105                                                
    106                                                ------------------------------------------------------------
    107                                                procedure TryGetWrite (
    108                                                -- Try write transaction.  
    109                                                -- If a write cycle has already completed return Address and Data, 
    110                                                -- and return Available as TRUE, otherwise, return Available as FALSE. 
    111                                                -- oData variable should be sized to match the size of the data 
    112                                                -- being transferred.
    113                                                ------------------------------------------------------------
    114                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    115                                                  variable oAddr           : Out   std_logic_vector ;
    116                                                  variable oData           : Out   std_logic_vector ;
    117                                                  variable Available       : Out   boolean ;
    118                                                  constant StatusMsgOn     : In    boolean := false
    119                                                ) ;
    120                                              
    121                                                ------------------------------------------------------------
    122                                                procedure SendRead (
    123                                                -- Blocking Read transaction.   
    124                                                -- Block until address is available and data is sent.
    125                                                -- iData variable should be sized to match the size of the data 
    126                                                -- being transferred.
    127                                                ------------------------------------------------------------
    128                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    129                                                  variable oAddr           : Out   std_logic_vector ;
    130                                                  constant iData           : In    std_logic_vector ;
    131                                                  constant StatusMsgOn     : In    boolean := false
    132                                                ) ;
    133                                                
    134                                                ------------------------------------------------------------
    135                                                procedure TrySendRead (
    136                                                -- Try Read transaction.   
    137                                                -- If a read address already been received return Address, 
    138                                                -- send iData as the read data, and return Available as TRUE,
    139                                                -- otherwise return Available as FALSE.
    140                                                -- iData variable should be sized to match the size of the data 
    141                                                -- being transferred.
    142                                                ------------------------------------------------------------
    143                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    144                                                  variable oAddr           : Out   std_logic_vector ;
    145                                                  constant iData           : In    std_logic_vector ;
    146                                                  variable Available       : Out   boolean ;
    147                                                  constant StatusMsgOn     : In    boolean := false
    148                                                ) ;
    149                                                
    150                                                
    151                                                -- ========================================================
    152                                                --  Interface Specific Transactions
    153                                                --  Support split transaction interfaces - such as AXI which
    154                                                --  independently operates the write address, write data, 
    155                                                --  write response, read address, and read data interfaces. 
    156                                                --  For split transaction interfaces, these transactions are 
    157                                                --  required to fully test the interface characteristics.  
    158                                                --  Most of these transactions are asynchronous.  
    159                                                -- ========================================================
    160                                                ------------------------------------------------------------
    161                                                procedure GetWriteAddress (
    162                                                -- Blocking write address transaction.  
    163                                                ------------------------------------------------------------
    164                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    165                                                  variable oAddr           : Out   std_logic_vector ;
    166                                                  constant StatusMsgOn     : In    boolean := false
    167                                                ) ;
    168                                                
    169                                                ------------------------------------------------------------
    170                                                procedure TryGetWriteAddress (
    171                                                -- Try write address transaction.  
    172                                                -- If a write address cycle has already completed return oAddr and 
    173                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    174                                                ------------------------------------------------------------
    175                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    176                                                  variable oAddr           : Out   std_logic_vector ;
    177                                                  variable Available       : Out   boolean ;
    178                                                  constant StatusMsgOn     : In    boolean := false
    179                                                ) ;
    180                                              
    181                                                ------------------------------------------------------------
    182                                                procedure GetWriteData (
    183                                                -- Blocking write data transaction.  
    184                                                -- oData should be sized to match the size of the data 
    185                                                -- being transferred.  
    186                                                ------------------------------------------------------------
    187                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    188                                                  constant iAddr           : In    std_logic_vector ;
    189                                                  variable oData           : Out   std_logic_vector ;
    190                                                  constant StatusMsgOn     : In    boolean := false
    191                                                ) ;
    192                                                
    193                                                ------------------------------------------------------------
    194                                                procedure TryGetWriteData (
    195                                                -- Try write data transaction.  
    196                                                -- If a write data cycle has already completed return oData and 
    197                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    198                                                -- oData should be sized to match the size of the data 
    199                                                -- being transferred.  
    200                                                ------------------------------------------------------------
    201                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    202                                                  constant iAddr           : In    std_logic_vector ;
    203                                                  variable oData           : Out   std_logic_vector ;
    204                                                  variable Available       : Out   boolean ;
    205                                                  constant StatusMsgOn     : In    boolean := false
    206                                                ) ;
    207                                                
    208                                                ------------------------------------------------------------
    209                                                procedure GetWriteData (
    210                                                -- Blocking write data transaction.  
    211                                                -- oData should be sized to match the size of the data 
    212                                                -- being transferred.  iAddr = 0
    213                                                ------------------------------------------------------------
    214                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    215                                                  variable oData           : Out   std_logic_vector ;
    216                                                  constant StatusMsgOn     : In    boolean := false
    217                                                ) ;
    218                                              
    219                                                ------------------------------------------------------------
    220                                                procedure TryGetWriteData (
    221                                                -- Try write data transaction.  
    222                                                -- If a write data cycle has already completed return oData and 
    223                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    224                                                -- oData should be sized to match the size of the data 
    225                                                -- being transferred.  iAddr = 0
    226                                                ------------------------------------------------------------
    227                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    228                                                  variable oData           : Out   std_logic_vector ;
    229                                                  variable Available       : Out   boolean ;
    230                                                  constant StatusMsgOn     : In    boolean := false
    231                                                ) ;
    232                                                
    233                                                ------------------------------------------------------------
    234                                                procedure GetReadAddress (
    235                                                -- Blocking Read address transaction.   
    236                                                ------------------------------------------------------------
    237                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    238                                                  variable oAddr           : Out   std_logic_vector ;
    239                                                  constant StatusMsgOn     : In    boolean := false
    240                                                ) ;
    241                                                
    242                                                ------------------------------------------------------------
    243                                                procedure TryGetReadAddress (
    244                                                -- Try read address transaction.  
    245                                                -- If a read address cycle has already completed return oAddr and 
    246                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    247                                                ------------------------------------------------------------
    248                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    249                                                  variable oAddr           : Out   std_logic_vector ;
    250                                                  variable Available       : Out   boolean ;
    251                                                  constant StatusMsgOn     : In    boolean := false
    252                                                ) ;
    253                                                
    254                                                ------------------------------------------------------------
    255                                                procedure SendReadData (
    256                                                -- Blocking Send Read Data transaction.  
    257                                                -- iData should be sized to match the size of the data 
    258                                                -- being transferred.
    259                                                ------------------------------------------------------------
    260                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    261                                                  constant iData           : In    std_logic_vector ;
    262                                                  constant StatusMsgOn     : In    boolean := false
    263                                                ) ;
    264                                                
    265                                                ------------------------------------------------------------
    266                                                procedure SendReadDataAsync (
    267                                                -- Asynchronous Send Read Data transaction.  
    268                                                -- iData should be sized to match the size of the data 
    269                                                -- being transferred.
    270                                                ------------------------------------------------------------
    271                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    272                                                  constant iData           : In    std_logic_vector ;
    273                                                  constant StatusMsgOn     : In    boolean := false
    274                                                ) ;   
    275                                                
    276                                              end package AddressBusResponderTransactionPkg ;
    277                                              
    278                                              -- /////////////////////////////////////////////////////////////////////////////////////////
    279                                              -- /////////////////////////////////////////////////////////////////////////////////////////
    280                                              
    281                                              package body AddressBusResponderTransactionPkg is
    282                                              
    283                                                ------------------------------------------------------------
    284                                                procedure GetWrite (
    285                                                -- Blocks until Address and Data are both available
    286                                                ------------------------------------------------------------
    287                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    288                                                  variable oAddr           : Out   std_logic_vector ;
    289                                                  variable oData           : Out   std_logic_vector ;
    290                                                  constant StatusMsgOn     : In    boolean := false
    291                                                ) is
    292                                                begin
    293                                                  -- Put values in record
    294             1                    ***0***         TransactionRec.Operation     <= WRITE_OP ;
    295             1                    ***0***         TransactionRec.AddrWidth     <= oAddr'length ;
    296             1                    ***0***         TransactionRec.DataWidth     <= oData'length ;
    297             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    298             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    299             1                    ***0***         oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;
    300             1                    ***0***         oData  := FromTransaction(TransactionRec.DataFromModel, oData'length) ;
    301                                                end procedure GetWrite ;
    302                                              
    303                                                ------------------------------------------------------------
    304                                                procedure TryGetWrite (
    305                                                -- Return address and data if both available otherwise return false
    306                                                ------------------------------------------------------------
    307                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    308                                                  variable oAddr           : Out   std_logic_vector ;
    309                                                  variable oData           : Out   std_logic_vector ;
    310                                                  variable Available       : Out   boolean ;
    311                                                  constant StatusMsgOn     : In    boolean := false
    312                                                ) is
    313                                                begin
    314                                                  -- Put values in record
    315             1                    ***0***         TransactionRec.Operation     <= ASYNC_WRITE ;
    316             1                    ***0***         TransactionRec.AddrWidth     <= oAddr'length ;
    317             1                    ***0***         TransactionRec.DataWidth     <= oData'length ;
    318             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    319             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    320             1                    ***0***         oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;
    321             1                    ***0***         oData  := FromTransaction(TransactionRec.DataFromModel, oData'length) ;
    322             1                    ***0***         Available := TransactionRec.BoolFromModel ;
    323                                                end procedure TryGetWrite ;
    324                                              
    325                                                ------------------------------------------------------------
    326                                                procedure GetWriteAddress (
    327                                                -- Blocks until Address is available
    328                                                ------------------------------------------------------------
    329                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    330                                                  variable oAddr           : Out   std_logic_vector ;
    331                                                  constant StatusMsgOn     : In    boolean := false
    332                                                ) is
    333                                                begin
    334                                                  -- Put values in record
    335             1                    ***0***         TransactionRec.Operation     <= WRITE_ADDRESS ;
    336             1                    ***0***         TransactionRec.AddrWidth     <= oAddr'length ;
    337             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    338             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    339             1                    ***0***         oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;
    340                                                end procedure GetWriteAddress ;
    341                                                
    342                                                ------------------------------------------------------------
    343                                                procedure TryGetWriteAddress (
    344                                                -- Return address if available otherwise return false
    345                                                ------------------------------------------------------------
    346                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    347                                                  variable oAddr           : Out   std_logic_vector ;
    348                                                  variable Available       : Out   boolean ;
    349                                                  constant StatusMsgOn     : In    boolean := false
    350                                                ) is
    351                                                begin
    352                                                  -- Put values in record
    353             1                    ***0***         TransactionRec.Operation     <= ASYNC_WRITE_ADDRESS ;
    354             1                    ***0***         TransactionRec.AddrWidth     <= oAddr'length ;
    355             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    356             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    357             1                    ***0***         oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;
    358             1                    ***0***         Available := TransactionRec.BoolFromModel ;
    359                                                end procedure TryGetWriteAddress ;
    360                                              
    361                                                ------------------------------------------------------------
    362                                                procedure GetWriteData (
    363                                                -- Blocking write data transaction.  
    364                                                -- oData should be sized to match the size of the data 
    365                                                -- being transferred.  
    366                                                ------------------------------------------------------------
    367                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    368                                                  constant iAddr           : In    std_logic_vector ;
    369                                                  variable oData           : Out   std_logic_vector ;
    370                                                  constant StatusMsgOn     : In    boolean := false
    371                                                ) is
    372                                                  alias aAddr : std_logic_vector(iAddr'length-1 downto 0) is iAddr ;
    373                                                  constant ADDR_LEN : integer := minimum(aAddr'left, 30) ;
    374                                                begin
    375                                                  -- Put values in record
    376             1                    ***0***         TransactionRec.Operation     <= WRITE_DATA ;
    377             1                    ***0***         TransactionRec.AddrWidth     <= to_integer(aAddr(ADDR_LEN downto 0)) ; -- Allows bursts upto 2**31
    378             1                    ***0***         TransactionRec.DataWidth     <= oData'length ;
    379             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    380             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    381             1                    ***0***         oData  := FromTransaction(TransactionRec.DataFromModel, oData'length) ;
    382                                                end procedure GetWriteData ;
    383                                                
    384                                                ------------------------------------------------------------
    385                                                procedure TryGetWriteData (
    386                                                -- Try write data transaction.  
    387                                                -- If a write data cycle has already completed return oData and 
    388                                                -- return Available as TRUE, otherwise, return Available as FALSE.
    389                                                -- oData should be sized to match the size of the data 
    390                                                -- being transferred.  
    391                                                ------------------------------------------------------------
    392                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    393                                                  constant iAddr           : In    std_logic_vector ;
    394                                                  variable oData           : Out   std_logic_vector ;
    395                                                  variable Available       : Out   boolean ;
    396                                                  constant StatusMsgOn     : In    boolean := false
    397                                                ) is
    398                                                  alias aAddr : std_logic_vector(iAddr'length-1 downto 0) is iAddr ;
    399                                                  constant ADDR_LEN : integer := minimum(aAddr'left, 30) ;
    400                                                begin
    401                                                  -- Put values in record
    402             1                    ***0***         TransactionRec.Operation     <= ASYNC_WRITE_DATA ;
    403             1                    ***0***         TransactionRec.AddrWidth     <= to_integer(aAddr(ADDR_LEN downto 0)) ; -- Allows bursts upto 2**31
    404             1                    ***0***         TransactionRec.DataWidth     <= oData'length ;
    405             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    406             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    407             1                    ***0***         oData  := FromTransaction(TransactionRec.DataFromModel, oData'length) ;
    408             1                    ***0***         Available := TransactionRec.BoolFromModel ;
    409                                                end procedure TryGetWriteData ;
    410                                                
    411                                                ------------------------------------------------------------
    412                                                procedure GetWriteData (
    413                                                -- Blocks until Data is available
    414                                                ------------------------------------------------------------
    415                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    416                                                  variable oData           : Out   std_logic_vector ;
    417                                                  constant StatusMsgOn     : In    boolean := false
    418                                                ) is
    419                                                begin
    420             1                    ***0***         GetWriteData(TransactionRec, X"00", oData, StatusMsgOn) ;
    421                                                end procedure GetWriteData ;
    422                                              
    423                                                ------------------------------------------------------------
    424                                                procedure TryGetWriteData (
    425                                                -- Return data if available otherwise return false
    426                                                ------------------------------------------------------------
    427                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    428                                                  variable oData           : Out   std_logic_vector ;
    429                                                  variable Available       : Out   boolean ;
    430                                                  constant StatusMsgOn     : In    boolean := false
    431                                                ) is
    432                                                begin
    433             1                    ***0***         TryGetWriteData(TransactionRec, X"00", oData, Available, StatusMsgOn) ;
    434                                                end procedure TryGetWriteData ;
    435                                              
    436                                                ------------------------------------------------------------
    437                                                procedure SendRead (
    438                                                -- Block until address is available and data is done
    439                                                ------------------------------------------------------------
    440                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    441                                                  variable oAddr           : Out   std_logic_vector ;
    442                                                  constant iData           : In    std_logic_vector ;
    443                                                  constant StatusMsgOn     : In    boolean := false
    444                                                ) is
    445                                                begin
    446                                                  -- Put values in record
    447             1                    ***0***         TransactionRec.Operation     <= READ_OP ;
    448             1                    ***0***         TransactionRec.AddrWidth     <= oAddr'length ;
    449             1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    450             1                    ***0***         TransactionRec.DataToModel   <= ToTransaction(iData, TransactionRec.DataToModel'length) ;
    451             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    452             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    453             1                    ***0***         oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;
    454                                                end procedure SendRead ;
    455                                                
    456                                                ------------------------------------------------------------
    457                                                procedure TrySendRead (
    458                                                -- Return address if available, send data if address available
    459                                                ------------------------------------------------------------
    460                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    461                                                  variable oAddr           : Out   std_logic_vector ;
    462                                                  constant iData           : In    std_logic_vector ;
    463                                                  variable Available       : Out   boolean ;
    464                                                  constant StatusMsgOn     : In    boolean := false
    465                                                ) is
    466                                                begin
    467                                                  -- Put values in record
    468             1                    ***0***         TransactionRec.Operation     <= ASYNC_READ ;
    469             1                    ***0***         TransactionRec.AddrWidth     <= oAddr'length ;
    470             1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    471             1                    ***0***         TransactionRec.DataToModel   <= ToTransaction(iData, TransactionRec.DataToModel'length) ;
    472             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    473             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    474             1                    ***0***         oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;
    475             1                    ***0***         Available  := TransactionRec.BoolFromModel ;
    476                                                end procedure TrySendRead ;
    477                                                  
    478                                                ------------------------------------------------------------
    479                                                procedure GetReadAddress (
    480                                                -- Block until address is available
    481                                                ------------------------------------------------------------
    482                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    483                                                  variable oAddr           : Out   std_logic_vector ;
    484                                                  constant StatusMsgOn     : In    boolean := false
    485                                                ) is
    486                                                begin
    487                                                  -- Put values in record
    488             1                    ***0***         TransactionRec.Operation     <= READ_ADDRESS ;
    489             1                    ***0***         TransactionRec.AddrWidth     <= oAddr'length ;
    490             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    491             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    492             1                    ***0***         oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;
    493                                                end procedure GetReadAddress ;
    494                                                
    495                                                ------------------------------------------------------------
    496                                                procedure TryGetReadAddress (
    497                                                -- Return read address if available, otherwise return false on Available
    498                                                ------------------------------------------------------------
    499                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    500                                                  variable oAddr           : Out   std_logic_vector ;
    501                                                  variable Available       : Out   boolean ;
    502                                                  constant StatusMsgOn     : In    boolean := false
    503                                                ) is
    504                                                begin
    505                                                  -- Put values in record
    506             1                    ***0***         TransactionRec.Operation     <= ASYNC_READ_ADDRESS ;
    507             1                    ***0***         TransactionRec.AddrWidth     <= oAddr'length ;
    508             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    509             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    510             1                    ***0***         oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;
    511             1                    ***0***         Available  := TransactionRec.BoolFromModel ;
    512                                                end procedure TryGetReadAddress ;
    513                                                
    514                                                ------------------------------------------------------------
    515                                                procedure SendReadData (
    516                                                -- Block until data is done
    517                                                ------------------------------------------------------------
    518                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    519                                                  constant iData           : In    std_logic_vector ;
    520                                                  constant StatusMsgOn     : In    boolean := false
    521                                                ) is
    522                                                begin
    523                                                  -- Put values in record
    524             1                    ***0***         TransactionRec.Operation     <= READ_DATA ;
    525             1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    526             1                    ***0***         TransactionRec.DataToModel   <= ToTransaction(iData, TransactionRec.DataToModel'length) ;
    527             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    528             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    529                                                end procedure SendReadData ;
    530                                                
    531                                                ------------------------------------------------------------
    532                                                procedure SendReadDataAsync (
    533                                                -- Queue Read Data
    534                                                ------------------------------------------------------------
    535                                                  signal   TransactionRec  : InOut AddressBusRecType ;
    536                                                  constant iData           : In    std_logic_vector ;
    537                                                  constant StatusMsgOn     : In    boolean := false
    538                                                ) is
    539                                                begin
    540                                                  -- Put values in record
    541             1                    ***0***         TransactionRec.Operation     <= ASYNC_READ_DATA ;
    542             1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    543             1                    ***0***         TransactionRec.DataToModel   <= ToTransaction(iData, TransactionRec.DataToModel'length) ;
    544             1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    545             1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    546                                                end procedure SendReadDataAsync ;  
    547                                                
    548                                              end package body AddressBusResponderTransactionPkg ;


=================================================================================
=== File: ../osvvm/Common/src/AddressBusTransactionArrayPkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                       131         0       131     0.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/Common/src/AddressBusTransactionArrayPkg.vhd --

------------------------------------CASE Branch------------------------------------
    777                                  ***0***     Count coming in to CASE
    778             1                    ***0***           when  0 =>  RequestTransaction(Rdy => TransactionRec( 0).Rdy, Ack => TransactionRec( 0).Ack) ; 
    779             1                    ***0***           when  1 =>  RequestTransaction(Rdy => TransactionRec( 1).Rdy, Ack => TransactionRec( 1).Ack) ; 
    780             1                    ***0***           when  2 =>  RequestTransaction(Rdy => TransactionRec( 2).Rdy, Ack => TransactionRec( 2).Ack) ; 
    781             1                    ***0***           when  3 =>  RequestTransaction(Rdy => TransactionRec( 3).Rdy, Ack => TransactionRec( 3).Ack) ; 
    782             1                    ***0***           when  4 =>  RequestTransaction(Rdy => TransactionRec( 4).Rdy, Ack => TransactionRec( 4).Ack) ; 
    783             1                    ***0***           when  5 =>  RequestTransaction(Rdy => TransactionRec( 5).Rdy, Ack => TransactionRec( 5).Ack) ; 
    784             1                    ***0***           when  6 =>  RequestTransaction(Rdy => TransactionRec( 6).Rdy, Ack => TransactionRec( 6).Ack) ; 
    785             1                    ***0***           when  7 =>  RequestTransaction(Rdy => TransactionRec( 7).Rdy, Ack => TransactionRec( 7).Ack) ; 
    786             1                    ***0***           when  8 =>  RequestTransaction(Rdy => TransactionRec( 8).Rdy, Ack => TransactionRec( 8).Ack) ; 
    787             1                    ***0***           when  9 =>  RequestTransaction(Rdy => TransactionRec( 9).Rdy, Ack => TransactionRec( 9).Ack) ; 
    788             1                    ***0***           when 10 =>  RequestTransaction(Rdy => TransactionRec(10).Rdy, Ack => TransactionRec(10).Ack) ; 
    789             1                    ***0***           when 11 =>  RequestTransaction(Rdy => TransactionRec(11).Rdy, Ack => TransactionRec(11).Ack) ; 
    790             1                    ***0***           when 12 =>  RequestTransaction(Rdy => TransactionRec(12).Rdy, Ack => TransactionRec(12).Ack) ; 
    791             1                    ***0***           when 13 =>  RequestTransaction(Rdy => TransactionRec(13).Rdy, Ack => TransactionRec(13).Ack) ; 
    792             1                    ***0***           when 14 =>  RequestTransaction(Rdy => TransactionRec(14).Rdy, Ack => TransactionRec(14).Ack) ; 
    793             1                    ***0***           when 15 =>  RequestTransaction(Rdy => TransactionRec(15).Rdy, Ack => TransactionRec(15).Ack) ; 
    794             1                    ***0***           when 16 =>  RequestTransaction(Rdy => TransactionRec(16).Rdy, Ack => TransactionRec(16).Ack) ; 
    795             1                    ***0***           when 17 =>  RequestTransaction(Rdy => TransactionRec(17).Rdy, Ack => TransactionRec(17).Ack) ; 
    796             1                    ***0***           when 18 =>  RequestTransaction(Rdy => TransactionRec(18).Rdy, Ack => TransactionRec(18).Ack) ; 
    797             1                    ***0***           when 19 =>  RequestTransaction(Rdy => TransactionRec(19).Rdy, Ack => TransactionRec(19).Ack) ; 
    798             1                    ***0***           when 20 =>  RequestTransaction(Rdy => TransactionRec(20).Rdy, Ack => TransactionRec(20).Ack) ; 
    799             1                    ***0***           when 21 =>  RequestTransaction(Rdy => TransactionRec(21).Rdy, Ack => TransactionRec(21).Ack) ; 
    800             1                    ***0***           when 22 =>  RequestTransaction(Rdy => TransactionRec(22).Rdy, Ack => TransactionRec(22).Ack) ; 
    801             1                    ***0***           when 23 =>  RequestTransaction(Rdy => TransactionRec(23).Rdy, Ack => TransactionRec(23).Ack) ; 
    802             1                    ***0***           when 24 =>  RequestTransaction(Rdy => TransactionRec(24).Rdy, Ack => TransactionRec(24).Ack) ; 
    803             1                    ***0***           when 25 =>  RequestTransaction(Rdy => TransactionRec(25).Rdy, Ack => TransactionRec(25).Ack) ; 
    804             1                    ***0***           when 26 =>  RequestTransaction(Rdy => TransactionRec(26).Rdy, Ack => TransactionRec(26).Ack) ; 
    805             1                    ***0***           when 27 =>  RequestTransaction(Rdy => TransactionRec(27).Rdy, Ack => TransactionRec(27).Ack) ; 
    806             1                    ***0***           when 28 =>  RequestTransaction(Rdy => TransactionRec(28).Rdy, Ack => TransactionRec(28).Ack) ; 
    807             1                    ***0***           when 29 =>  RequestTransaction(Rdy => TransactionRec(29).Rdy, Ack => TransactionRec(29).Ack) ; 
    808             1                    ***0***           when 30 =>  RequestTransaction(Rdy => TransactionRec(30).Rdy, Ack => TransactionRec(30).Ack) ; 
    809             1                    ***0***           when 31 =>  RequestTransaction(Rdy => TransactionRec(31).Rdy, Ack => TransactionRec(31).Ack) ; 
    810             1                    ***0***           when 32 =>  RequestTransaction(Rdy => TransactionRec(32).Rdy, Ack => TransactionRec(32).Ack) ; 
    811             1                    ***0***           when 33 =>  RequestTransaction(Rdy => TransactionRec(33).Rdy, Ack => TransactionRec(33).Ack) ; 
    812             1                    ***0***           when 34 =>  RequestTransaction(Rdy => TransactionRec(34).Rdy, Ack => TransactionRec(34).Ack) ; 
    813             1                    ***0***           when 35 =>  RequestTransaction(Rdy => TransactionRec(35).Rdy, Ack => TransactionRec(35).Ack) ; 
    814             1                    ***0***           when 36 =>  RequestTransaction(Rdy => TransactionRec(36).Rdy, Ack => TransactionRec(36).Ack) ; 
    815             1                    ***0***           when 37 =>  RequestTransaction(Rdy => TransactionRec(37).Rdy, Ack => TransactionRec(37).Ack) ; 
    816             1                    ***0***           when 38 =>  RequestTransaction(Rdy => TransactionRec(38).Rdy, Ack => TransactionRec(38).Ack) ; 
    817             1                    ***0***           when 39 =>  RequestTransaction(Rdy => TransactionRec(39).Rdy, Ack => TransactionRec(39).Ack) ; 
    818             1                    ***0***           when 40 =>  RequestTransaction(Rdy => TransactionRec(40).Rdy, Ack => TransactionRec(40).Ack) ; 
    819             1                    ***0***           when 41 =>  RequestTransaction(Rdy => TransactionRec(41).Rdy, Ack => TransactionRec(41).Ack) ; 
    820             1                    ***0***           when 42 =>  RequestTransaction(Rdy => TransactionRec(42).Rdy, Ack => TransactionRec(42).Ack) ; 
    821             1                    ***0***           when 43 =>  RequestTransaction(Rdy => TransactionRec(43).Rdy, Ack => TransactionRec(43).Ack) ; 
    822             1                    ***0***           when 44 =>  RequestTransaction(Rdy => TransactionRec(44).Rdy, Ack => TransactionRec(44).Ack) ; 
    823             1                    ***0***           when 45 =>  RequestTransaction(Rdy => TransactionRec(45).Rdy, Ack => TransactionRec(45).Ack) ; 
    824             1                    ***0***           when 46 =>  RequestTransaction(Rdy => TransactionRec(46).Rdy, Ack => TransactionRec(46).Ack) ; 
    825             1                    ***0***           when 47 =>  RequestTransaction(Rdy => TransactionRec(47).Rdy, Ack => TransactionRec(47).Ack) ; 
    826             1                    ***0***           when 48 =>  RequestTransaction(Rdy => TransactionRec(48).Rdy, Ack => TransactionRec(48).Ack) ; 
    827             1                    ***0***           when 49 =>  RequestTransaction(Rdy => TransactionRec(49).Rdy, Ack => TransactionRec(49).Ack) ; 
    828             1                    ***0***           when 50 =>  RequestTransaction(Rdy => TransactionRec(50).Rdy, Ack => TransactionRec(50).Ack) ; 
    829             1                    ***0***           when 51 =>  RequestTransaction(Rdy => TransactionRec(51).Rdy, Ack => TransactionRec(51).Ack) ; 
    830             1                    ***0***           when 52 =>  RequestTransaction(Rdy => TransactionRec(52).Rdy, Ack => TransactionRec(52).Ack) ; 
    831             1                    ***0***           when 53 =>  RequestTransaction(Rdy => TransactionRec(53).Rdy, Ack => TransactionRec(53).Ack) ; 
    832             1                    ***0***           when 54 =>  RequestTransaction(Rdy => TransactionRec(54).Rdy, Ack => TransactionRec(54).Ack) ; 
    833             1                    ***0***           when 55 =>  RequestTransaction(Rdy => TransactionRec(55).Rdy, Ack => TransactionRec(55).Ack) ; 
    834             1                    ***0***           when 56 =>  RequestTransaction(Rdy => TransactionRec(56).Rdy, Ack => TransactionRec(56).Ack) ; 
    835             1                    ***0***           when 57 =>  RequestTransaction(Rdy => TransactionRec(57).Rdy, Ack => TransactionRec(57).Ack) ; 
    836             1                    ***0***           when 58 =>  RequestTransaction(Rdy => TransactionRec(58).Rdy, Ack => TransactionRec(58).Ack) ; 
    837             1                    ***0***           when 59 =>  RequestTransaction(Rdy => TransactionRec(59).Rdy, Ack => TransactionRec(59).Ack) ; 
    838             1                    ***0***           when 60 =>  RequestTransaction(Rdy => TransactionRec(60).Rdy, Ack => TransactionRec(60).Ack) ; 
    839             1                    ***0***           when 61 =>  RequestTransaction(Rdy => TransactionRec(61).Rdy, Ack => TransactionRec(61).Ack) ; 
    840             1                    ***0***           when 62 =>  RequestTransaction(Rdy => TransactionRec(62).Rdy, Ack => TransactionRec(62).Ack) ; 
    841             1                    ***0***           when 63 =>  RequestTransaction(Rdy => TransactionRec(63).Rdy, Ack => TransactionRec(63).Ack) ; 
    842             1                    ***0***           when 64 =>  RequestTransaction(Rdy => TransactionRec(64).Rdy, Ack => TransactionRec(64).Ack) ; 
    843             1                    ***0***           when 65 =>  RequestTransaction(Rdy => TransactionRec(65).Rdy, Ack => TransactionRec(65).Ack) ; 
    844             1                    ***0***           when 66 =>  RequestTransaction(Rdy => TransactionRec(66).Rdy, Ack => TransactionRec(66).Ack) ; 
    845             1                    ***0***           when 67 =>  RequestTransaction(Rdy => TransactionRec(67).Rdy, Ack => TransactionRec(67).Ack) ; 
    846             1                    ***0***           when 68 =>  RequestTransaction(Rdy => TransactionRec(68).Rdy, Ack => TransactionRec(68).Ack) ; 
    847             1                    ***0***           when 69 =>  RequestTransaction(Rdy => TransactionRec(69).Rdy, Ack => TransactionRec(69).Ack) ; 
    848             1                    ***0***           when 70 =>  RequestTransaction(Rdy => TransactionRec(70).Rdy, Ack => TransactionRec(70).Ack) ; 
    849             1                    ***0***           when 71 =>  RequestTransaction(Rdy => TransactionRec(71).Rdy, Ack => TransactionRec(71).Ack) ; 
    850             1                    ***0***           when 72 =>  RequestTransaction(Rdy => TransactionRec(72).Rdy, Ack => TransactionRec(72).Ack) ; 
    851             1                    ***0***           when 73 =>  RequestTransaction(Rdy => TransactionRec(73).Rdy, Ack => TransactionRec(73).Ack) ; 
    852             1                    ***0***           when 74 =>  RequestTransaction(Rdy => TransactionRec(74).Rdy, Ack => TransactionRec(74).Ack) ; 
    853             1                    ***0***           when 75 =>  RequestTransaction(Rdy => TransactionRec(75).Rdy, Ack => TransactionRec(75).Ack) ; 
    854             1                    ***0***           when 76 =>  RequestTransaction(Rdy => TransactionRec(76).Rdy, Ack => TransactionRec(76).Ack) ; 
    855             1                    ***0***           when 77 =>  RequestTransaction(Rdy => TransactionRec(77).Rdy, Ack => TransactionRec(77).Ack) ; 
    856             1                    ***0***           when 78 =>  RequestTransaction(Rdy => TransactionRec(78).Rdy, Ack => TransactionRec(78).Ack) ; 
    857             1                    ***0***           when 79 =>  RequestTransaction(Rdy => TransactionRec(79).Rdy, Ack => TransactionRec(79).Ack) ; 
    858             1                    ***0***           when 80 =>  RequestTransaction(Rdy => TransactionRec(80).Rdy, Ack => TransactionRec(80).Ack) ; 
    859             1                    ***0***           when 81 =>  RequestTransaction(Rdy => TransactionRec(81).Rdy, Ack => TransactionRec(81).Ack) ; 
    860             1                    ***0***           when 82 =>  RequestTransaction(Rdy => TransactionRec(82).Rdy, Ack => TransactionRec(82).Ack) ; 
    861             1                    ***0***           when 83 =>  RequestTransaction(Rdy => TransactionRec(83).Rdy, Ack => TransactionRec(83).Ack) ; 
    862             1                    ***0***           when 84 =>  RequestTransaction(Rdy => TransactionRec(84).Rdy, Ack => TransactionRec(84).Ack) ; 
    863             1                    ***0***           when 85 =>  RequestTransaction(Rdy => TransactionRec(85).Rdy, Ack => TransactionRec(85).Ack) ; 
    864             1                    ***0***           when 86 =>  RequestTransaction(Rdy => TransactionRec(86).Rdy, Ack => TransactionRec(86).Ack) ; 
    865             1                    ***0***           when 87 =>  RequestTransaction(Rdy => TransactionRec(87).Rdy, Ack => TransactionRec(87).Ack) ; 
    866             1                    ***0***           when 88 =>  RequestTransaction(Rdy => TransactionRec(88).Rdy, Ack => TransactionRec(88).Ack) ; 
    867             1                    ***0***           when 89 =>  RequestTransaction(Rdy => TransactionRec(89).Rdy, Ack => TransactionRec(89).Ack) ; 
    868             1                    ***0***           when 90 =>  RequestTransaction(Rdy => TransactionRec(90).Rdy, Ack => TransactionRec(90).Ack) ; 
    869             1                    ***0***           when 91 =>  RequestTransaction(Rdy => TransactionRec(91).Rdy, Ack => TransactionRec(91).Ack) ; 
    870             1                    ***0***           when 92 =>  RequestTransaction(Rdy => TransactionRec(92).Rdy, Ack => TransactionRec(92).Ack) ; 
    871             1                    ***0***           when 93 =>  RequestTransaction(Rdy => TransactionRec(93).Rdy, Ack => TransactionRec(93).Ack) ; 
    872             1                    ***0***           when 94 =>  RequestTransaction(Rdy => TransactionRec(94).Rdy, Ack => TransactionRec(94).Ack) ; 
    873             1                    ***0***           when 95 =>  RequestTransaction(Rdy => TransactionRec(95).Rdy, Ack => TransactionRec(95).Ack) ; 
    874             1                    ***0***           when 96 =>  RequestTransaction(Rdy => TransactionRec(96).Rdy, Ack => TransactionRec(96).Ack) ; 
    875             1                    ***0***           when 97 =>  RequestTransaction(Rdy => TransactionRec(97).Rdy, Ack => TransactionRec(97).Ack) ; 
    876             1                    ***0***           when 98 =>  RequestTransaction(Rdy => TransactionRec(98).Rdy, Ack => TransactionRec(98).Ack) ; 
    877             1                    ***0***           when 99 =>  RequestTransaction(Rdy => TransactionRec(99).Rdy, Ack => TransactionRec(99).Ack) ; 
    878             1                    ***0***           when 100 =>  RequestTransaction(Rdy => TransactionRec(100).Rdy, Ack => TransactionRec(100).Ack) ; 
    879             1                    ***0***           when 101 =>  RequestTransaction(Rdy => TransactionRec(101).Rdy, Ack => TransactionRec(101).Ack) ; 
    880             1                    ***0***           when 102 =>  RequestTransaction(Rdy => TransactionRec(102).Rdy, Ack => TransactionRec(102).Ack) ; 
    881             1                    ***0***           when 103 =>  RequestTransaction(Rdy => TransactionRec(103).Rdy, Ack => TransactionRec(103).Ack) ; 
    882             1                    ***0***           when 104 =>  RequestTransaction(Rdy => TransactionRec(104).Rdy, Ack => TransactionRec(104).Ack) ; 
    883             1                    ***0***           when 105 =>  RequestTransaction(Rdy => TransactionRec(105).Rdy, Ack => TransactionRec(105).Ack) ; 
    884             1                    ***0***           when 106 =>  RequestTransaction(Rdy => TransactionRec(106).Rdy, Ack => TransactionRec(106).Ack) ; 
    885             1                    ***0***           when 107 =>  RequestTransaction(Rdy => TransactionRec(107).Rdy, Ack => TransactionRec(107).Ack) ; 
    886             1                    ***0***           when 108 =>  RequestTransaction(Rdy => TransactionRec(108).Rdy, Ack => TransactionRec(108).Ack) ; 
    887             1                    ***0***           when 109 =>  RequestTransaction(Rdy => TransactionRec(109).Rdy, Ack => TransactionRec(109).Ack) ; 
    888             1                    ***0***           when 110 =>  RequestTransaction(Rdy => TransactionRec(110).Rdy, Ack => TransactionRec(110).Ack) ; 
    889             1                    ***0***           when 111 =>  RequestTransaction(Rdy => TransactionRec(111).Rdy, Ack => TransactionRec(111).Ack) ; 
    890             1                    ***0***           when 112 =>  RequestTransaction(Rdy => TransactionRec(112).Rdy, Ack => TransactionRec(112).Ack) ; 
    891             1                    ***0***           when 113 =>  RequestTransaction(Rdy => TransactionRec(113).Rdy, Ack => TransactionRec(113).Ack) ; 
    892             1                    ***0***           when 114 =>  RequestTransaction(Rdy => TransactionRec(114).Rdy, Ack => TransactionRec(114).Ack) ; 
    893             1                    ***0***           when 115 =>  RequestTransaction(Rdy => TransactionRec(115).Rdy, Ack => TransactionRec(115).Ack) ; 
    894             1                    ***0***           when 116 =>  RequestTransaction(Rdy => TransactionRec(116).Rdy, Ack => TransactionRec(116).Ack) ; 
    895             1                    ***0***           when 117 =>  RequestTransaction(Rdy => TransactionRec(117).Rdy, Ack => TransactionRec(117).Ack) ; 
    896             1                    ***0***           when 118 =>  RequestTransaction(Rdy => TransactionRec(118).Rdy, Ack => TransactionRec(118).Ack) ; 
    897             1                    ***0***           when 119 =>  RequestTransaction(Rdy => TransactionRec(119).Rdy, Ack => TransactionRec(119).Ack) ; 
    898             1                    ***0***           when 120 =>  RequestTransaction(Rdy => TransactionRec(120).Rdy, Ack => TransactionRec(120).Ack) ; 
    899             1                    ***0***           when 121 =>  RequestTransaction(Rdy => TransactionRec(121).Rdy, Ack => TransactionRec(121).Ack) ; 
    900             1                    ***0***           when 122 =>  RequestTransaction(Rdy => TransactionRec(122).Rdy, Ack => TransactionRec(122).Ack) ; 
    901             1                    ***0***           when 123 =>  RequestTransaction(Rdy => TransactionRec(123).Rdy, Ack => TransactionRec(123).Ack) ; 
    902             1                    ***0***           when 124 =>  RequestTransaction(Rdy => TransactionRec(124).Rdy, Ack => TransactionRec(124).Ack) ; 
    903             1                    ***0***           when 125 =>  RequestTransaction(Rdy => TransactionRec(125).Rdy, Ack => TransactionRec(125).Ack) ; 
    904             1                    ***0***           when 126 =>  RequestTransaction(Rdy => TransactionRec(126).Rdy, Ack => TransactionRec(126).Ack) ; 
    905             1                    ***0***           when 127 =>  RequestTransaction(Rdy => TransactionRec(127).Rdy, Ack => TransactionRec(127).Ack) ; 
    906             1                    ***0***           when 128 =>  RequestTransaction(Rdy => TransactionRec(128).Rdy, Ack => TransactionRec(128).Ack) ; 
    907             1                    ***0***           when 129 =>  RequestTransaction(Rdy => TransactionRec(129).Rdy, Ack => TransactionRec(129).Ack) ; 
    908             1                    ***0***           when others => Alert("AddressBusTransactionArrayPkg: Please extend AddressBusArrayRequestTransaction to handle " & to_string(Index) & " indices") ; 
Branch totals: 0 hits of 131 branches = 0.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                     374         0       374     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/AddressBusTransactionArrayPkg.vhd --

    1                                                --
    2                                                --  File Name:         AddressBusTransactionArrayPkg.vhd
    3                                                --  Design Unit Name:  AddressBusTransactionArrayPkg
    4                                                --  Revision:          OSVVM MODELS STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com
    7                                                --  Contributor(s):
    8                                                --     Jim Lewis      jim@synthworks.com
    9                                                --
    10                                               --
    11                                               --  Description:
    12                                               --    Defines Address Bus transaction initiation procedures (Read, Write, ...)
    13                                               --    for arrays of Address Bus Interfaces (AddressBusRecArrayType).
    14                                               --    Companion to AddressBusTransactionPkg.vhd
    15                                               --    
    16                                               --    This works around a VHDL issue documented in 
    17                                               --    https://gitlab.com/IEEE-P1076/VHDL-Issues/-/issues/275
    18                                               --    When this issue is fixed and implemented, this package will
    19                                               --    no longer be needed
    20                                               --
    21                                               --
    22                                               --  Developed by:
    23                                               --        SynthWorks Design Inc.
    24                                               --        VHDL Training Classes
    25                                               --        http://www.SynthWorks.com
    26                                               --
    27                                               --  Revision History:
    28                                               --    Date      Version    Description
    29                                               --    11/2022   2022.11    Initial.   Derived from AddressBusTransactionPkg
    30                                               --
    31                                               --  This file is part of OSVVM.
    32                                               --  
    33                                               --  Copyright (c) 2022 by SynthWorks Design Inc.  
    34                                               --  
    35                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    36                                               --  you may not use this file except in compliance with the License.
    37                                               --  You may obtain a copy of the License at
    38                                               --  
    39                                               --      https://www.apache.org/licenses/LICENSE-2.0
    40                                               --  
    41                                               --  Unless required by applicable law or agreed to in writing, software
    42                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    43                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    44                                               --  See the License for the specific language governing permissions and
    45                                               --  limitations under the License.
    46                                               --  
    47                                               library ieee ;
    48                                                 use ieee.std_logic_1164.all ;
    49                                                 use ieee.numeric_std.all ;
    50                                                 use ieee.numeric_std_unsigned.all ;
    51                                                 use ieee.math_real.all ;
    52                                               
    53                                               library osvvm ;
    54                                                 context osvvm.OsvvmContext ;
    55                                                 use osvvm.ScoreboardPkg_slv.all ; 
    56                                               
    57                                                 use work.FifoFillPkg_slv.all ; 
    58                                                 use work.AddressBusTransactionPkg.all ; 
    59                                               
    60                                               package AddressBusTransactionArrayPkg is
    61                                               
    62                                                 -- ========================================================
    63                                                 --  Directive Transactions  
    64                                                 --  Directive transactions interact with the verification component 
    65                                                 --  without generating any transactions or interface waveforms.
    66                                                 --  Supported by all verification components
    67                                                 -- ========================================================
    68                                                 ------------------------------------------------------------
    69                                                 procedure WaitForTransaction (
    70                                                 --  Wait until pending transaction completes
    71                                                 ------------------------------------------------------------
    72                                                   signal   TransactionRec : InOut AddressBusRecArrayType ;
    73                                                   constant Index          : In    integer  
    74                                                 ) ; 
    75                                               
    76                                                 ------------------------------------------------------------
    77                                                 procedure WaitForWriteTransaction (
    78                                                 --  Wait until pending transaction completes
    79                                                 ------------------------------------------------------------
    80                                                   signal   TransactionRec : InOut AddressBusRecArrayType ;
    81                                                   constant Index          : In    integer  
    82                                                 ) ; 
    83                                               
    84                                                 ------------------------------------------------------------
    85                                                 procedure WaitForReadTransaction (
    86                                                 --  Wait until pending transaction completes
    87                                                 ------------------------------------------------------------
    88                                                   signal   TransactionRec : InOut AddressBusRecArrayType ;
    89                                                   constant Index          : In    integer  
    90                                                 ) ;
    91                                                 
    92                                                 ------------------------------------------------------------
    93                                                 procedure WaitForClock (
    94                                                 -- Wait for NumberOfClocks number of clocks 
    95                                                 -- relative to the verification component clock
    96                                                 ------------------------------------------------------------
    97                                                   signal   TransactionRec : InOut AddressBusRecArrayType ;
    98                                                   constant Index          : In    integer  ;
    99                                                   constant NumberOfClocks : In    natural := 1
    100                                                ) ;
    101                                              
    102                                                alias NoOp is WaitForClock [AddressBusRecArrayType, integer, natural] ;
    103                                              
    104                                                ------------------------------------------------------------
    105                                                procedure GetTransactionCount (
    106                                                -- Get the number of transactions handled by the model.  
    107                                                ------------------------------------------------------------
    108                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    109                                                  constant Index          : In    integer  ;
    110                                                  variable Count          : Out   integer
    111                                                ) ;
    112                                              
    113                                                ------------------------------------------------------------
    114                                                procedure GetWriteTransactionCount (
    115                                                ------------------------------------------------------------
    116                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    117                                                  constant Index          : In    integer  ;
    118                                                  variable Count          : Out   integer
    119                                                ) ;
    120                                              
    121                                                ------------------------------------------------------------
    122                                                procedure GetReadTransactionCount (
    123                                                -- Get the number of read transactions handled by the model.  
    124                                                ------------------------------------------------------------
    125                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    126                                                  constant Index          : In    integer  ;
    127                                                  variable Count          : Out   integer
    128                                                ) ;
    129                                              
    130                                                ------------------------------------------------------------
    131                                                procedure GetAlertLogID (
    132                                                -- Get the AlertLogID from the verification component.
    133                                                ------------------------------------------------------------
    134                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    135                                                  constant Index          : In    integer  ;
    136                                                  variable AlertLogID     : Out   AlertLogIDType
    137                                                ) ;
    138                                              
    139                                                ------------------------------------------------------------
    140                                                procedure GetErrorCount (
    141                                                -- Error reporting for testbenches that do not use OSVVM AlertLogPkg
    142                                                -- Returns error count.  If an error count /= 0, also print errors
    143                                                ------------------------------------------------------------
    144                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    145                                                  constant Index          : In    integer  ;
    146                                                  variable ErrorCount     : Out   natural
    147                                                ) ;
    148                                              
    149                                                -- ========================================================
    150                                                --  Delay Coverage Transactions   
    151                                                --  Get Delay Coverage ID to change delay coverage parameters.
    152                                                -- ========================================================
    153                                                ------------------------------------------------------------
    154                                                procedure SetUseRandomDelays (
    155                                                ------------------------------------------------------------
    156                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    157                                                  constant Index          : In    integer  ;
    158                                                  constant OptVal         : In    boolean := TRUE
    159                                                ) ;
    160                                              
    161                                                ------------------------------------------------------------
    162                                                procedure GetUseRandomDelays (
    163                                                ------------------------------------------------------------
    164                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    165                                                  constant Index          : In    integer  ;
    166                                                  variable OptVal         : Out   boolean
    167                                                ) ;
    168                                                
    169                                                ------------------------------------------------------------
    170                                                procedure SetDelayCoverageID (
    171                                                ------------------------------------------------------------
    172                                                  signal   TransactionRec : inout AddressBusRecArrayType ;
    173                                                  constant ArrayIndex     : In    integer  ;
    174                                                  constant DelayCov       : in    DelayCoverageIdType ;
    175                                                  constant Index          : in    integer := 1 
    176                                                ) ;
    177                                              
    178                                                ------------------------------------------------------------
    179                                                procedure GetDelayCoverageID (
    180                                                ------------------------------------------------------------
    181                                                  signal   TransactionRec : inout AddressBusRecArrayType ;
    182                                                  constant ArrayIndex     : In    integer  ;
    183                                                  variable DelayCov       : out   DelayCoverageIdType ;
    184                                                  constant Index          : in    integer := 1 
    185                                                ) ;
    186                                              
    187                                                ------------------------------------------------------------
    188                                                procedure SetDelayCoverageID (
    189                                                ------------------------------------------------------------
    190                                                  signal   TransactionRec : inout AddressBusRecArrayType ;
    191                                                  constant Index          : In    integer  ;
    192                                                  constant DelayCov       : in    DelayCoverageIdArrayType 
    193                                                ) ;
    194                                              
    195                                                ------------------------------------------------------------
    196                                                procedure GetDelayCoverageID (
    197                                                ------------------------------------------------------------
    198                                                  signal   TransactionRec : inout AddressBusRecArrayType ;
    199                                                  constant Index          : In    integer  ;
    200                                                  variable DelayCov       : out   DelayCoverageIdArrayType 
    201                                                ) ;
    202                                              
    203                                                -- ========================================================
    204                                                --  Set and Get Burst Mode   
    205                                                --  Set Burst Mode for models that do bursting.
    206                                                -- ========================================================
    207                                                ------------------------------------------------------------
    208                                                procedure SetBurstMode (
    209                                                ------------------------------------------------------------
    210                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    211                                                  constant Index          : In    integer  ;
    212                                                  constant OptVal         : In    AddressBusFifoBurstModeType
    213                                                ) ;
    214                                              
    215                                                ------------------------------------------------------------
    216                                                procedure GetBurstMode (
    217                                                ------------------------------------------------------------
    218                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    219                                                  constant Index          : In    integer  ;
    220                                                  variable OptVal         : Out   AddressBusFifoBurstModeType
    221                                                ) ;
    222                                              
    223                                                -- ========================================================
    224                                                --  Set and Get Model Options  
    225                                                --  Model operations are directive transactions that are  
    226                                                --  used to configure the verification component.  
    227                                                --  They can either be used directly or with a model specific
    228                                                --  wrapper around them - see AXI models for examples.
    229                                                -- ========================================================
    230                                                ------------------------------------------------------------
    231                                                procedure SetModelOptions (
    232                                                ------------------------------------------------------------
    233                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    234                                                  constant Index          : In    integer  ;
    235                                                  constant Option         : In    integer ;
    236                                                  constant OptVal         : In    boolean
    237                                                ) ;
    238                                              
    239                                                ------------------------------------------------------------
    240                                                procedure SetModelOptions (
    241                                                ------------------------------------------------------------
    242                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    243                                                  constant Index          : In    integer  ;
    244                                                  constant Option         : In    integer ;
    245                                                  constant OptVal         : In    integer
    246                                                ) ;
    247                                              
    248                                                ------------------------------------------------------------
    249                                                procedure SetModelOptions (
    250                                                ------------------------------------------------------------
    251                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    252                                                  constant Index          : In    integer  ;
    253                                                  constant Option         : In    integer ;
    254                                                  constant OptVal         : In    std_logic_vector
    255                                                ) ;
    256                                                
    257                                                ------------------------------------------------------------
    258                                                procedure SetModelOptions (
    259                                                ------------------------------------------------------------
    260                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    261                                                  constant Index          : In    integer  ;
    262                                                  constant Option         : In    integer ;
    263                                                  constant OptVal         : In    time
    264                                                ) ;
    265                                              
    266                                                ------------------------------------------------------------
    267                                                procedure GetModelOptions (
    268                                                ------------------------------------------------------------
    269                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    270                                                  constant Index          : In    integer  ;
    271                                                  constant Option         : In    integer ;
    272                                                  variable OptVal         : Out   boolean
    273                                                ) ;
    274                                              
    275                                                ------------------------------------------------------------
    276                                                procedure GetModelOptions (
    277                                                ------------------------------------------------------------
    278                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    279                                                  constant Index          : In    integer  ;
    280                                                  constant Option         : In    integer ;
    281                                                  variable OptVal         : Out   integer
    282                                                ) ;
    283                                              
    284                                                ------------------------------------------------------------
    285                                                procedure GetModelOptions (
    286                                                ------------------------------------------------------------
    287                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    288                                                  constant Index          : In    integer  ;
    289                                                  constant Option         : In    integer ;
    290                                                  variable OptVal         : Out   std_logic_vector
    291                                                ) ;
    292                                              
    293                                                ------------------------------------------------------------
    294                                                procedure GetModelOptions (
    295                                                ------------------------------------------------------------
    296                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    297                                                  constant Index          : In    integer  ;
    298                                                  constant Option         : In    integer ;
    299                                                  variable OptVal         : Out   time
    300                                                ) ;
    301                                                ------------------------------------------------------------
    302                                                procedure InterruptReturn (
    303                                                ------------------------------------------------------------
    304                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    305                                                  constant Index          : In    integer  
    306                                                ) ;
    307                                              
    308                                              
    309                                                -- ========================================================
    310                                                --  Master / Initiator Transactions  
    311                                                -- ========================================================
    312                                                -- ========================================================
    313                                                --  Interface Independent Transactions
    314                                                --  These transactions work independent of the interface.
    315                                                --  Recommended for all tests that verify internal design functionality.
    316                                                --  Many are blocking transactions which do not return (complete)
    317                                                --  until the interface operation requested by the transaction  
    318                                                --  has completed.
    319                                                --  Some are asynchronous, which means they return before the
    320                                                --  transaction is complete - typically even before it starts.
    321                                                --  Supported by all verification components
    322                                                -- ========================================================
    323                                                ------------------------------------------------------------
    324                                                procedure Write (
    325                                                -- Blocking Write Transaction. 
    326                                                ------------------------------------------------------------
    327                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    328                                                  constant Index          : In    integer  ;
    329                                                           iAddr          : In    std_logic_vector ;
    330                                                           iData          : In    std_logic_vector ;
    331                                                           StatusMsgOn    : In    boolean := false
    332                                                ) ;
    333                                              
    334                                                ------------------------------------------------------------
    335                                                procedure WriteAsync (
    336                                                -- Asynchronous / Non-Blocking Write Transaction
    337                                                ------------------------------------------------------------
    338                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    339                                                  constant Index          : In    integer  ;
    340                                                           iAddr          : In    std_logic_vector ;
    341                                                           iData          : In    std_logic_vector ;
    342                                                           StatusMsgOn    : In    boolean := false
    343                                                ) ;
    344                                              
    345                                                ------------------------------------------------------------
    346                                                procedure Read (
    347                                                -- Blocking Read Transaction.
    348                                                ------------------------------------------------------------
    349                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    350                                                  constant Index          : In    integer  ;
    351                                                           iAddr          : In    std_logic_vector ;
    352                                                  variable oData          : Out   std_logic_vector ;
    353                                                           StatusMsgOn    : In    boolean := false
    354                                                ) ;
    355                                              
    356                                                ------------------------------------------------------------
    357                                                procedure ReadCheck (
    358                                                -- Blocking Read Transaction and check iData, rather than returning a value.
    359                                                ------------------------------------------------------------
    360                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    361                                                  constant Index          : In    integer  ;
    362                                                           iAddr          : In    std_logic_vector ;
    363                                                           iData          : In    std_logic_vector ;
    364                                                           StatusMsgOn    : In    boolean := false
    365                                                ) ;
    366                                                
    367                                                ------------------------------------------------------------
    368                                                procedure ReadPoll (
    369                                                -- Read location (iAddr) until Data(IndexI) = ValueI
    370                                                -- WaitTime is the number of clocks to wait between reads.
    371                                                -- oData is the value read.
    372                                                ------------------------------------------------------------
    373                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    374                                                  constant Index          : In    integer  ;
    375                                                           iAddr          : In    std_logic_vector ;
    376                                                  variable oData          : Out   std_logic_vector ;
    377                                                           RegIndex       : In    Integer ;
    378                                                           BitValue       : In    std_logic ;
    379                                                           StatusMsgOn    : In    boolean := false ;
    380                                                           WaitTime       : In    natural := 10
    381                                                ) ;
    382                                              
    383                                                ------------------------------------------------------------
    384                                                procedure ReadPoll (
    385                                                -- Read location (iAddr) until Data(IndexI) = ValueI
    386                                                -- WaitTime is the number of clocks to wait between reads.
    387                                                ------------------------------------------------------------
    388                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    389                                                  constant Index          : In    integer  ;
    390                                                           iAddr          : In    std_logic_vector ;
    391                                                           RegIndex       : In    Integer ;
    392                                                           BitValue       : In    std_logic ;
    393                                                           StatusMsgOn    : In    boolean := false ;
    394                                                           WaitTime       : In    natural := 10
    395                                                ) ;
    396                                                
    397                                                ------------------------------------------------------------
    398                                                procedure WriteAndRead (
    399                                                -- Write and Read Cycle that use same address and are dispatched together
    400                                                ------------------------------------------------------------
    401                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    402                                                  constant Index          : In    integer  ;
    403                                                           iAddr          : In    std_logic_vector ;
    404                                                           iData          : In    std_logic_vector ;
    405                                                  variable oData          : Out   std_logic_vector ;
    406                                                           StatusMsgOn    : In    boolean := false
    407                                                ) ;
    408                                              
    409                                                ------------------------------------------------------------
    410                                                procedure WriteAndReadAsync (
    411                                                -- Dispatch Write Address and Data.  Do not wait for completion
    412                                                -- Dispatch Read Address.  Do not wait for Read Data.  
    413                                                -- Retrieve read data with ReadData or TryReadData
    414                                                ------------------------------------------------------------
    415                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    416                                                  constant Index          : In    integer  ;
    417                                                           iAddr          : In    std_logic_vector ;
    418                                                           iData          : In    std_logic_vector ;
    419                                                           StatusMsgOn    : In    boolean := false
    420                                                ) ;
    421                                                
    422                                                
    423                                                -- ========================================================
    424                                                --  Burst Transactions
    425                                                --  Some interfaces support bursting, and some do not.  
    426                                                --  Hence, support for burst transactions is optional.
    427                                                --  However, for an interface that does not support bursting,  
    428                                                --  it is appropriate to implement a burst as multiple single  
    429                                                --  cycle operations.    
    430                                                -- ========================================================
    431                                                
    432                                                ------------------------------------------------------------
    433                                                procedure WriteBurst (
    434                                                -- Blocking Write Burst.   
    435                                                -- Data is provided separately via a WriteBurstFifo.   
    436                                                -- NumFifoWords specifies the number of items from the FIFO to be transferred.
    437                                                ------------------------------------------------------------
    438                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    439                                                  constant Index          : In    integer  ;
    440                                                           iAddr          : In    std_logic_vector ;
    441                                                           NumFifoWords   : In    integer ;
    442                                                           StatusMsgOn    : In    boolean := false
    443                                                ) ;
    444                                              
    445                                                ------------------------------------------------------------
    446                                                procedure WriteBurstVector (
    447                                                ------------------------------------------------------------
    448                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    449                                                  constant Index          : In    integer  ;
    450                                                           iAddr          : In    std_logic_vector ;
    451                                                           VectorOfWords  : In    slv_vector ;
    452                                                           StatusMsgOn    : In    boolean := false
    453                                                ) ;
    454                                                
    455                                                ------------------------------------------------------------
    456                                                procedure WriteBurstVector (
    457                                                ------------------------------------------------------------
    458                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    459                                                  constant Index          : In    integer  ;
    460                                                           iAddr          : In    std_logic_vector ;
    461                                                           VectorOfWords  : In    integer_vector ;
    462                                                           FifoWidth      : In    integer ; 
    463                                                           StatusMsgOn    : In    boolean := false
    464                                                ) ;
    465                                              
    466                                                ------------------------------------------------------------
    467                                                procedure WriteBurstIncrement (
    468                                                ------------------------------------------------------------
    469                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    470                                                  constant Index          : In    integer  ;
    471                                                           iAddr          : In    std_logic_vector ;
    472                                                           FirstWord      : In    std_logic_vector ;
    473                                                           NumFifoWords   : In    integer ;
    474                                                           StatusMsgOn    : In    boolean := false
    475                                                ) ;
    476                                              
    477                                                ------------------------------------------------------------
    478                                                procedure WriteBurstRandom (
    479                                                ------------------------------------------------------------
    480                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    481                                                  constant Index          : In    integer  ;
    482                                                           iAddr          : In    std_logic_vector ;
    483                                                           FirstWord      : In    std_logic_vector ;
    484                                                           NumFifoWords   : In    integer ;
    485                                                           StatusMsgOn    : In    boolean := false
    486                                                ) ;
    487                                              
    488                                                ------------------------------------------------------------
    489                                                procedure WriteBurstRandom (
    490                                                ------------------------------------------------------------
    491                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    492                                                  constant Index          : In    integer  ;
    493                                                           iAddr          : In    std_logic_vector ;
    494                                                           CoverID        : In    CoverageIDType ;
    495                                                           NumFifoWords   : In    integer ;
    496                                                           FifoWidth      : In    integer ;
    497                                                           StatusMsgOn    : In    boolean := false
    498                                                ) ;
    499                                              
    500                                                ------------------------------------------------------------
    501                                                procedure WriteBurstAsync (
    502                                                -- Asynchronous / Non-Blocking Write Burst.   
    503                                                -- Data is provided separately via a WriteBurstFifo.   
    504                                                -- NumFifoWords specifies the number of bytes to be transferred.
    505                                                ------------------------------------------------------------
    506                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    507                                                  constant Index          : In    integer  ;
    508                                                           iAddr          : In    std_logic_vector ;
    509                                                           NumFifoWords   : In    integer ;
    510                                                           StatusMsgOn    : In    boolean := false
    511                                                ) ;
    512                                                
    513                                              ------------------------------------------------------------
    514                                                procedure WriteBurstVectorAsync (
    515                                                ------------------------------------------------------------
    516                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    517                                                  constant Index          : In    integer  ;
    518                                                           iAddr          : In    std_logic_vector ;
    519                                                           VectorOfWords  : In    slv_vector ;
    520                                                           StatusMsgOn    : In    boolean := false
    521                                                ) ;
    522                                                
    523                                                ------------------------------------------------------------
    524                                                procedure WriteBurstVectorAsync (
    525                                                ------------------------------------------------------------
    526                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    527                                                  constant Index          : In    integer  ;
    528                                                           iAddr          : In    std_logic_vector ;
    529                                                           VectorOfWords  : In    integer_vector ;
    530                                                           FifoWidth      : In    integer ; 
    531                                                           StatusMsgOn    : In    boolean := false
    532                                                ) ;
    533                                              
    534                                                ------------------------------------------------------------
    535                                                procedure WriteBurstIncrementAsync (
    536                                                ------------------------------------------------------------
    537                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    538                                                  constant Index          : In    integer  ;
    539                                                           iAddr          : In    std_logic_vector ;
    540                                                           FirstWord      : In    std_logic_vector ;
    541                                                           NumFifoWords   : In    integer ;
    542                                                           StatusMsgOn    : In    boolean := false
    543                                                ) ;
    544                                              
    545                                                ------------------------------------------------------------
    546                                                procedure WriteBurstRandomAsync (
    547                                                ------------------------------------------------------------
    548                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    549                                                  constant Index          : In    integer  ;
    550                                                           iAddr          : In    std_logic_vector ;
    551                                                           FirstWord      : In    std_logic_vector ;
    552                                                           NumFifoWords   : In    integer ;
    553                                                           StatusMsgOn    : In    boolean := false
    554                                                ) ;
    555                                              
    556                                                ------------------------------------------------------------
    557                                                procedure WriteBurstRandomAsync (
    558                                                ------------------------------------------------------------
    559                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    560                                                  constant Index          : In    integer  ;
    561                                                           iAddr          : In    std_logic_vector ;
    562                                                           CoverID        : In    CoverageIDType ;
    563                                                           NumFifoWords   : In    integer ;
    564                                                           FifoWidth      : In    integer ;
    565                                                           StatusMsgOn    : In    boolean := false
    566                                                ) ;
    567                                              
    568                                                ------------------------------------------------------------
    569                                                procedure ReadBurst (
    570                                                -- Blocking Read Burst.
    571                                                ------------------------------------------------------------
    572                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    573                                                  constant Index          : In    integer  ;
    574                                                           iAddr          : In    std_logic_vector ;
    575                                                           NumFifoWords   : In    integer ;
    576                                                           StatusMsgOn    : In    boolean := false
    577                                                ) ;
    578                                              
    579                                                ------------------------------------------------------------
    580                                                procedure ReadCheckBurstVector (
    581                                                ------------------------------------------------------------
    582                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    583                                                  constant Index          : In    integer  ;
    584                                                           iAddr          : In    std_logic_vector ;
    585                                                           VectorOfWords  : In    slv_vector ;
    586                                                           StatusMsgOn    : In    boolean := false
    587                                                ) ;
    588                                                
    589                                                ------------------------------------------------------------
    590                                                procedure ReadCheckBurstVector (
    591                                                ------------------------------------------------------------
    592                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    593                                                  constant Index          : In    integer  ;
    594                                                           iAddr          : In    std_logic_vector ;
    595                                                           VectorOfWords  : In    integer_vector ;
    596                                                           FifoWidth      : In    integer ; 
    597                                                           StatusMsgOn    : In    boolean := false
    598                                                ) ;
    599                                              
    600                                                ------------------------------------------------------------
    601                                                procedure ReadCheckBurstIncrement (
    602                                                ------------------------------------------------------------
    603                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    604                                                  constant Index          : In    integer  ;
    605                                                           iAddr          : In    std_logic_vector ;
    606                                                           FirstWord      : In    std_logic_vector ;
    607                                                           NumFifoWords   : In    integer ;
    608                                                           StatusMsgOn    : In    boolean := false
    609                                                ) ;
    610                                              
    611                                                ------------------------------------------------------------
    612                                                procedure ReadCheckBurstRandom (
    613                                                ------------------------------------------------------------
    614                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    615                                                  constant Index          : In    integer  ;
    616                                                           iAddr          : In    std_logic_vector ;
    617                                                           FirstWord      : In    std_logic_vector ;
    618                                                           NumFifoWords   : In    integer ;
    619                                                           StatusMsgOn    : In    boolean := false
    620                                                ) ;
    621                                              
    622                                                ------------------------------------------------------------
    623                                                procedure ReadCheckBurstRandom (
    624                                                ------------------------------------------------------------
    625                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    626                                                  constant Index          : In    integer  ;
    627                                                           iAddr          : In    std_logic_vector ;
    628                                                           CoverID        : In    CoverageIDType ;
    629                                                           NumFifoWords   : In    integer ;
    630                                                           FifoWidth      : In    integer ;
    631                                                           StatusMsgOn    : In    boolean := false
    632                                                ) ;
    633                                              
    634                                                -- ========================================================
    635                                                --  Interface Specific Transactions
    636                                                --  Support split transaction interfaces - such as AXI which
    637                                                --  independently operates the write address, write data, 
    638                                                --  write response, read address, and read data interfaces. 
    639                                                --  For split transaction interfaces, these transactions are 
    640                                                --  required to fully test the interface characteristics.  
    641                                                --  Most of these transactions are asynchronous.  
    642                                                -- ========================================================
    643                                              
    644                                                ------------------------------------------------------------
    645                                                procedure WriteAddressAsync (
    646                                                -- Non-blocking Write Address 
    647                                                ------------------------------------------------------------
    648                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    649                                                  constant Index          : In    integer  ;
    650                                                           iAddr          : In    std_logic_vector ;
    651                                                           StatusMsgOn    : In    boolean := false
    652                                                ) ;
    653                                              
    654                                                ------------------------------------------------------------
    655                                                procedure WriteDataAsync (
    656                                                -- Non-blocking Write Data 
    657                                                ------------------------------------------------------------
    658                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    659                                                  constant Index          : In    integer  ;
    660                                                           iAddr          : In    std_logic_vector ;
    661                                                           iData          : In    std_logic_vector ;
    662                                                           StatusMsgOn    : In    boolean := false
    663                                                ) ;
    664                                              
    665                                                ------------------------------------------------------------
    666                                                procedure WriteDataAsync (
    667                                                -- Non-blocking Write Data.  iAddr = 0.  
    668                                                ------------------------------------------------------------
    669                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    670                                                  constant Index          : In    integer  ;
    671                                                           iData          : In    std_logic_vector ;
    672                                                           StatusMsgOn    : In    boolean := false
    673                                                ) ;
    674                                                
    675                                                ------------------------------------------------------------
    676                                                procedure ReadAddressAsync (
    677                                                -- Non-blocking Read Address
    678                                                ------------------------------------------------------------
    679                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    680                                                  constant Index          : In    integer  ;
    681                                                           iAddr          : In    std_logic_vector ;
    682                                                           StatusMsgOn    : In    boolean := false
    683                                                ) ;
    684                                              
    685                                                ------------------------------------------------------------
    686                                                procedure ReadData (
    687                                                -- Blocking Read Data
    688                                                ------------------------------------------------------------
    689                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    690                                                  constant Index          : In    integer  ;
    691                                                  variable oData          : Out   std_logic_vector ;
    692                                                           StatusMsgOn    : In    boolean := false
    693                                                ) ;
    694                                              
    695                                                ------------------------------------------------------------
    696                                                procedure ReadCheckData (
    697                                                -- Blocking Read data and check iData, rather than returning a value.
    698                                                ------------------------------------------------------------
    699                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    700                                                  constant Index          : In    integer  ;
    701                                                           iData          : In    std_logic_vector ;
    702                                                           StatusMsgOn    : In    boolean := false
    703                                                ) ;
    704                                              
    705                                                ------------------------------------------------------------
    706                                                procedure TryReadData (
    707                                                -- Try (non-blocking) read data attempt.   
    708                                                -- If data is available, get it and return available TRUE.
    709                                                -- Otherwise Return Available FALSE.
    710                                                ------------------------------------------------------------
    711                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    712                                                  constant Index          : In    integer  ;
    713                                                  variable oData          : Out   std_logic_vector ;
    714                                                  variable Available      : Out   boolean ;
    715                                                           StatusMsgOn    : In    boolean := false
    716                                                ) ;
    717                                              
    718                                                ------------------------------------------------------------
    719                                                procedure TryReadCheckData (
    720                                                -- Try (non-blocking) read data and check attempt.   
    721                                                -- If data is available, check it and return available TRUE.
    722                                                -- Otherwise Return Available FALSE.
    723                                                ------------------------------------------------------------
    724                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    725                                                  constant Index          : In    integer  ;
    726                                                           iData          : In    std_logic_vector ;
    727                                                  variable Available      : Out   boolean ;
    728                                                           StatusMsgOn    : In    boolean := false
    729                                                ) ;
    730                                              
    731                                                -- ========================================================
    732                                                --  Pseudo Transactions
    733                                                --  Interact with the record only.
    734                                                -- ========================================================
    735                                                ------------------------------------------------------------
    736                                                procedure ReleaseTransactionRecord (
    737                                                --  Must run on same delta cycle as AcquireTransactionRecord
    738                                                ------------------------------------------------------------
    739                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    740                                                  constant Index          : In    integer  
    741                                                ) ; 
    742                                                
    743                                                ------------------------------------------------------------
    744                                                procedure AcquireTransactionRecord (
    745                                                --  Must run on same delta cycle as ReleaseTransactionRecord
    746                                                ------------------------------------------------------------
    747                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    748                                                  constant Index          : In    integer  
    749                                                ) ; 
    750                                                
    751                                                -- ========================================================
    752                                                --  Supports AddressBusResponderTransactionArrayPkg
    753                                                -- ========================================================
    754                                                ------------------------------------------------------------
    755                                                procedure AddressBusArrayRequestTransaction (
    756                                                --  Package Local
    757                                                ------------------------------------------------------------
    758                                                  signal    TransactionRec   : inout AddressBusRecArrayType ;
    759                                                  constant  Index            : in    integer 
    760                                                ) ;
    761                                              
    762                                              end package AddressBusTransactionArrayPkg ;
    763                                              
    764                                              -- /////////////////////////////////////////////////////////////////////////////////////////
    765                                              -- /////////////////////////////////////////////////////////////////////////////////////////
    766                                              
    767                                              package body AddressBusTransactionArrayPkg is
    768                                              
    769                                                ------------------------------------------------------------
    770                                                procedure AddressBusArrayRequestTransaction (
    771                                                --  Package Local
    772                                                ------------------------------------------------------------
    773                                                  signal    TransactionRec   : inout AddressBusRecArrayType ;
    774                                                  constant  Index            : in    integer 
    775                                                ) is
    776                                                begin
    777                                                  case Index is 
    778             1                    ***0***           when  0 =>  RequestTransaction(Rdy => TransactionRec( 0).Rdy, Ack => TransactionRec( 0).Ack) ; 
    779             1                    ***0***           when  1 =>  RequestTransaction(Rdy => TransactionRec( 1).Rdy, Ack => TransactionRec( 1).Ack) ; 
    780             1                    ***0***           when  2 =>  RequestTransaction(Rdy => TransactionRec( 2).Rdy, Ack => TransactionRec( 2).Ack) ; 
    781             1                    ***0***           when  3 =>  RequestTransaction(Rdy => TransactionRec( 3).Rdy, Ack => TransactionRec( 3).Ack) ; 
    782             1                    ***0***           when  4 =>  RequestTransaction(Rdy => TransactionRec( 4).Rdy, Ack => TransactionRec( 4).Ack) ; 
    783             1                    ***0***           when  5 =>  RequestTransaction(Rdy => TransactionRec( 5).Rdy, Ack => TransactionRec( 5).Ack) ; 
    784             1                    ***0***           when  6 =>  RequestTransaction(Rdy => TransactionRec( 6).Rdy, Ack => TransactionRec( 6).Ack) ; 
    785             1                    ***0***           when  7 =>  RequestTransaction(Rdy => TransactionRec( 7).Rdy, Ack => TransactionRec( 7).Ack) ; 
    786             1                    ***0***           when  8 =>  RequestTransaction(Rdy => TransactionRec( 8).Rdy, Ack => TransactionRec( 8).Ack) ; 
    787             1                    ***0***           when  9 =>  RequestTransaction(Rdy => TransactionRec( 9).Rdy, Ack => TransactionRec( 9).Ack) ; 
    788             1                    ***0***           when 10 =>  RequestTransaction(Rdy => TransactionRec(10).Rdy, Ack => TransactionRec(10).Ack) ; 
    789             1                    ***0***           when 11 =>  RequestTransaction(Rdy => TransactionRec(11).Rdy, Ack => TransactionRec(11).Ack) ; 
    790             1                    ***0***           when 12 =>  RequestTransaction(Rdy => TransactionRec(12).Rdy, Ack => TransactionRec(12).Ack) ; 
    791             1                    ***0***           when 13 =>  RequestTransaction(Rdy => TransactionRec(13).Rdy, Ack => TransactionRec(13).Ack) ; 
    792             1                    ***0***           when 14 =>  RequestTransaction(Rdy => TransactionRec(14).Rdy, Ack => TransactionRec(14).Ack) ; 
    793             1                    ***0***           when 15 =>  RequestTransaction(Rdy => TransactionRec(15).Rdy, Ack => TransactionRec(15).Ack) ; 
    794             1                    ***0***           when 16 =>  RequestTransaction(Rdy => TransactionRec(16).Rdy, Ack => TransactionRec(16).Ack) ; 
    795             1                    ***0***           when 17 =>  RequestTransaction(Rdy => TransactionRec(17).Rdy, Ack => TransactionRec(17).Ack) ; 
    796             1                    ***0***           when 18 =>  RequestTransaction(Rdy => TransactionRec(18).Rdy, Ack => TransactionRec(18).Ack) ; 
    797             1                    ***0***           when 19 =>  RequestTransaction(Rdy => TransactionRec(19).Rdy, Ack => TransactionRec(19).Ack) ; 
    798             1                    ***0***           when 20 =>  RequestTransaction(Rdy => TransactionRec(20).Rdy, Ack => TransactionRec(20).Ack) ; 
    799             1                    ***0***           when 21 =>  RequestTransaction(Rdy => TransactionRec(21).Rdy, Ack => TransactionRec(21).Ack) ; 
    800             1                    ***0***           when 22 =>  RequestTransaction(Rdy => TransactionRec(22).Rdy, Ack => TransactionRec(22).Ack) ; 
    801             1                    ***0***           when 23 =>  RequestTransaction(Rdy => TransactionRec(23).Rdy, Ack => TransactionRec(23).Ack) ; 
    802             1                    ***0***           when 24 =>  RequestTransaction(Rdy => TransactionRec(24).Rdy, Ack => TransactionRec(24).Ack) ; 
    803             1                    ***0***           when 25 =>  RequestTransaction(Rdy => TransactionRec(25).Rdy, Ack => TransactionRec(25).Ack) ; 
    804             1                    ***0***           when 26 =>  RequestTransaction(Rdy => TransactionRec(26).Rdy, Ack => TransactionRec(26).Ack) ; 
    805             1                    ***0***           when 27 =>  RequestTransaction(Rdy => TransactionRec(27).Rdy, Ack => TransactionRec(27).Ack) ; 
    806             1                    ***0***           when 28 =>  RequestTransaction(Rdy => TransactionRec(28).Rdy, Ack => TransactionRec(28).Ack) ; 
    807             1                    ***0***           when 29 =>  RequestTransaction(Rdy => TransactionRec(29).Rdy, Ack => TransactionRec(29).Ack) ; 
    808             1                    ***0***           when 30 =>  RequestTransaction(Rdy => TransactionRec(30).Rdy, Ack => TransactionRec(30).Ack) ; 
    809             1                    ***0***           when 31 =>  RequestTransaction(Rdy => TransactionRec(31).Rdy, Ack => TransactionRec(31).Ack) ; 
    810             1                    ***0***           when 32 =>  RequestTransaction(Rdy => TransactionRec(32).Rdy, Ack => TransactionRec(32).Ack) ; 
    811             1                    ***0***           when 33 =>  RequestTransaction(Rdy => TransactionRec(33).Rdy, Ack => TransactionRec(33).Ack) ; 
    812             1                    ***0***           when 34 =>  RequestTransaction(Rdy => TransactionRec(34).Rdy, Ack => TransactionRec(34).Ack) ; 
    813             1                    ***0***           when 35 =>  RequestTransaction(Rdy => TransactionRec(35).Rdy, Ack => TransactionRec(35).Ack) ; 
    814             1                    ***0***           when 36 =>  RequestTransaction(Rdy => TransactionRec(36).Rdy, Ack => TransactionRec(36).Ack) ; 
    815             1                    ***0***           when 37 =>  RequestTransaction(Rdy => TransactionRec(37).Rdy, Ack => TransactionRec(37).Ack) ; 
    816             1                    ***0***           when 38 =>  RequestTransaction(Rdy => TransactionRec(38).Rdy, Ack => TransactionRec(38).Ack) ; 
    817             1                    ***0***           when 39 =>  RequestTransaction(Rdy => TransactionRec(39).Rdy, Ack => TransactionRec(39).Ack) ; 
    818             1                    ***0***           when 40 =>  RequestTransaction(Rdy => TransactionRec(40).Rdy, Ack => TransactionRec(40).Ack) ; 
    819             1                    ***0***           when 41 =>  RequestTransaction(Rdy => TransactionRec(41).Rdy, Ack => TransactionRec(41).Ack) ; 
    820             1                    ***0***           when 42 =>  RequestTransaction(Rdy => TransactionRec(42).Rdy, Ack => TransactionRec(42).Ack) ; 
    821             1                    ***0***           when 43 =>  RequestTransaction(Rdy => TransactionRec(43).Rdy, Ack => TransactionRec(43).Ack) ; 
    822             1                    ***0***           when 44 =>  RequestTransaction(Rdy => TransactionRec(44).Rdy, Ack => TransactionRec(44).Ack) ; 
    823             1                    ***0***           when 45 =>  RequestTransaction(Rdy => TransactionRec(45).Rdy, Ack => TransactionRec(45).Ack) ; 
    824             1                    ***0***           when 46 =>  RequestTransaction(Rdy => TransactionRec(46).Rdy, Ack => TransactionRec(46).Ack) ; 
    825             1                    ***0***           when 47 =>  RequestTransaction(Rdy => TransactionRec(47).Rdy, Ack => TransactionRec(47).Ack) ; 
    826             1                    ***0***           when 48 =>  RequestTransaction(Rdy => TransactionRec(48).Rdy, Ack => TransactionRec(48).Ack) ; 
    827             1                    ***0***           when 49 =>  RequestTransaction(Rdy => TransactionRec(49).Rdy, Ack => TransactionRec(49).Ack) ; 
    828             1                    ***0***           when 50 =>  RequestTransaction(Rdy => TransactionRec(50).Rdy, Ack => TransactionRec(50).Ack) ; 
    829             1                    ***0***           when 51 =>  RequestTransaction(Rdy => TransactionRec(51).Rdy, Ack => TransactionRec(51).Ack) ; 
    830             1                    ***0***           when 52 =>  RequestTransaction(Rdy => TransactionRec(52).Rdy, Ack => TransactionRec(52).Ack) ; 
    831             1                    ***0***           when 53 =>  RequestTransaction(Rdy => TransactionRec(53).Rdy, Ack => TransactionRec(53).Ack) ; 
    832             1                    ***0***           when 54 =>  RequestTransaction(Rdy => TransactionRec(54).Rdy, Ack => TransactionRec(54).Ack) ; 
    833             1                    ***0***           when 55 =>  RequestTransaction(Rdy => TransactionRec(55).Rdy, Ack => TransactionRec(55).Ack) ; 
    834             1                    ***0***           when 56 =>  RequestTransaction(Rdy => TransactionRec(56).Rdy, Ack => TransactionRec(56).Ack) ; 
    835             1                    ***0***           when 57 =>  RequestTransaction(Rdy => TransactionRec(57).Rdy, Ack => TransactionRec(57).Ack) ; 
    836             1                    ***0***           when 58 =>  RequestTransaction(Rdy => TransactionRec(58).Rdy, Ack => TransactionRec(58).Ack) ; 
    837             1                    ***0***           when 59 =>  RequestTransaction(Rdy => TransactionRec(59).Rdy, Ack => TransactionRec(59).Ack) ; 
    838             1                    ***0***           when 60 =>  RequestTransaction(Rdy => TransactionRec(60).Rdy, Ack => TransactionRec(60).Ack) ; 
    839             1                    ***0***           when 61 =>  RequestTransaction(Rdy => TransactionRec(61).Rdy, Ack => TransactionRec(61).Ack) ; 
    840             1                    ***0***           when 62 =>  RequestTransaction(Rdy => TransactionRec(62).Rdy, Ack => TransactionRec(62).Ack) ; 
    841             1                    ***0***           when 63 =>  RequestTransaction(Rdy => TransactionRec(63).Rdy, Ack => TransactionRec(63).Ack) ; 
    842             1                    ***0***           when 64 =>  RequestTransaction(Rdy => TransactionRec(64).Rdy, Ack => TransactionRec(64).Ack) ; 
    843             1                    ***0***           when 65 =>  RequestTransaction(Rdy => TransactionRec(65).Rdy, Ack => TransactionRec(65).Ack) ; 
    844             1                    ***0***           when 66 =>  RequestTransaction(Rdy => TransactionRec(66).Rdy, Ack => TransactionRec(66).Ack) ; 
    845             1                    ***0***           when 67 =>  RequestTransaction(Rdy => TransactionRec(67).Rdy, Ack => TransactionRec(67).Ack) ; 
    846             1                    ***0***           when 68 =>  RequestTransaction(Rdy => TransactionRec(68).Rdy, Ack => TransactionRec(68).Ack) ; 
    847             1                    ***0***           when 69 =>  RequestTransaction(Rdy => TransactionRec(69).Rdy, Ack => TransactionRec(69).Ack) ; 
    848             1                    ***0***           when 70 =>  RequestTransaction(Rdy => TransactionRec(70).Rdy, Ack => TransactionRec(70).Ack) ; 
    849             1                    ***0***           when 71 =>  RequestTransaction(Rdy => TransactionRec(71).Rdy, Ack => TransactionRec(71).Ack) ; 
    850             1                    ***0***           when 72 =>  RequestTransaction(Rdy => TransactionRec(72).Rdy, Ack => TransactionRec(72).Ack) ; 
    851             1                    ***0***           when 73 =>  RequestTransaction(Rdy => TransactionRec(73).Rdy, Ack => TransactionRec(73).Ack) ; 
    852             1                    ***0***           when 74 =>  RequestTransaction(Rdy => TransactionRec(74).Rdy, Ack => TransactionRec(74).Ack) ; 
    853             1                    ***0***           when 75 =>  RequestTransaction(Rdy => TransactionRec(75).Rdy, Ack => TransactionRec(75).Ack) ; 
    854             1                    ***0***           when 76 =>  RequestTransaction(Rdy => TransactionRec(76).Rdy, Ack => TransactionRec(76).Ack) ; 
    855             1                    ***0***           when 77 =>  RequestTransaction(Rdy => TransactionRec(77).Rdy, Ack => TransactionRec(77).Ack) ; 
    856             1                    ***0***           when 78 =>  RequestTransaction(Rdy => TransactionRec(78).Rdy, Ack => TransactionRec(78).Ack) ; 
    857             1                    ***0***           when 79 =>  RequestTransaction(Rdy => TransactionRec(79).Rdy, Ack => TransactionRec(79).Ack) ; 
    858             1                    ***0***           when 80 =>  RequestTransaction(Rdy => TransactionRec(80).Rdy, Ack => TransactionRec(80).Ack) ; 
    859             1                    ***0***           when 81 =>  RequestTransaction(Rdy => TransactionRec(81).Rdy, Ack => TransactionRec(81).Ack) ; 
    860             1                    ***0***           when 82 =>  RequestTransaction(Rdy => TransactionRec(82).Rdy, Ack => TransactionRec(82).Ack) ; 
    861             1                    ***0***           when 83 =>  RequestTransaction(Rdy => TransactionRec(83).Rdy, Ack => TransactionRec(83).Ack) ; 
    862             1                    ***0***           when 84 =>  RequestTransaction(Rdy => TransactionRec(84).Rdy, Ack => TransactionRec(84).Ack) ; 
    863             1                    ***0***           when 85 =>  RequestTransaction(Rdy => TransactionRec(85).Rdy, Ack => TransactionRec(85).Ack) ; 
    864             1                    ***0***           when 86 =>  RequestTransaction(Rdy => TransactionRec(86).Rdy, Ack => TransactionRec(86).Ack) ; 
    865             1                    ***0***           when 87 =>  RequestTransaction(Rdy => TransactionRec(87).Rdy, Ack => TransactionRec(87).Ack) ; 
    866             1                    ***0***           when 88 =>  RequestTransaction(Rdy => TransactionRec(88).Rdy, Ack => TransactionRec(88).Ack) ; 
    867             1                    ***0***           when 89 =>  RequestTransaction(Rdy => TransactionRec(89).Rdy, Ack => TransactionRec(89).Ack) ; 
    868             1                    ***0***           when 90 =>  RequestTransaction(Rdy => TransactionRec(90).Rdy, Ack => TransactionRec(90).Ack) ; 
    869             1                    ***0***           when 91 =>  RequestTransaction(Rdy => TransactionRec(91).Rdy, Ack => TransactionRec(91).Ack) ; 
    870             1                    ***0***           when 92 =>  RequestTransaction(Rdy => TransactionRec(92).Rdy, Ack => TransactionRec(92).Ack) ; 
    871             1                    ***0***           when 93 =>  RequestTransaction(Rdy => TransactionRec(93).Rdy, Ack => TransactionRec(93).Ack) ; 
    872             1                    ***0***           when 94 =>  RequestTransaction(Rdy => TransactionRec(94).Rdy, Ack => TransactionRec(94).Ack) ; 
    873             1                    ***0***           when 95 =>  RequestTransaction(Rdy => TransactionRec(95).Rdy, Ack => TransactionRec(95).Ack) ; 
    874             1                    ***0***           when 96 =>  RequestTransaction(Rdy => TransactionRec(96).Rdy, Ack => TransactionRec(96).Ack) ; 
    875             1                    ***0***           when 97 =>  RequestTransaction(Rdy => TransactionRec(97).Rdy, Ack => TransactionRec(97).Ack) ; 
    876             1                    ***0***           when 98 =>  RequestTransaction(Rdy => TransactionRec(98).Rdy, Ack => TransactionRec(98).Ack) ; 
    877             1                    ***0***           when 99 =>  RequestTransaction(Rdy => TransactionRec(99).Rdy, Ack => TransactionRec(99).Ack) ; 
    878             1                    ***0***           when 100 =>  RequestTransaction(Rdy => TransactionRec(100).Rdy, Ack => TransactionRec(100).Ack) ; 
    879             1                    ***0***           when 101 =>  RequestTransaction(Rdy => TransactionRec(101).Rdy, Ack => TransactionRec(101).Ack) ; 
    880             1                    ***0***           when 102 =>  RequestTransaction(Rdy => TransactionRec(102).Rdy, Ack => TransactionRec(102).Ack) ; 
    881             1                    ***0***           when 103 =>  RequestTransaction(Rdy => TransactionRec(103).Rdy, Ack => TransactionRec(103).Ack) ; 
    882             1                    ***0***           when 104 =>  RequestTransaction(Rdy => TransactionRec(104).Rdy, Ack => TransactionRec(104).Ack) ; 
    883             1                    ***0***           when 105 =>  RequestTransaction(Rdy => TransactionRec(105).Rdy, Ack => TransactionRec(105).Ack) ; 
    884             1                    ***0***           when 106 =>  RequestTransaction(Rdy => TransactionRec(106).Rdy, Ack => TransactionRec(106).Ack) ; 
    885             1                    ***0***           when 107 =>  RequestTransaction(Rdy => TransactionRec(107).Rdy, Ack => TransactionRec(107).Ack) ; 
    886             1                    ***0***           when 108 =>  RequestTransaction(Rdy => TransactionRec(108).Rdy, Ack => TransactionRec(108).Ack) ; 
    887             1                    ***0***           when 109 =>  RequestTransaction(Rdy => TransactionRec(109).Rdy, Ack => TransactionRec(109).Ack) ; 
    888             1                    ***0***           when 110 =>  RequestTransaction(Rdy => TransactionRec(110).Rdy, Ack => TransactionRec(110).Ack) ; 
    889             1                    ***0***           when 111 =>  RequestTransaction(Rdy => TransactionRec(111).Rdy, Ack => TransactionRec(111).Ack) ; 
    890             1                    ***0***           when 112 =>  RequestTransaction(Rdy => TransactionRec(112).Rdy, Ack => TransactionRec(112).Ack) ; 
    891             1                    ***0***           when 113 =>  RequestTransaction(Rdy => TransactionRec(113).Rdy, Ack => TransactionRec(113).Ack) ; 
    892             1                    ***0***           when 114 =>  RequestTransaction(Rdy => TransactionRec(114).Rdy, Ack => TransactionRec(114).Ack) ; 
    893             1                    ***0***           when 115 =>  RequestTransaction(Rdy => TransactionRec(115).Rdy, Ack => TransactionRec(115).Ack) ; 
    894             1                    ***0***           when 116 =>  RequestTransaction(Rdy => TransactionRec(116).Rdy, Ack => TransactionRec(116).Ack) ; 
    895             1                    ***0***           when 117 =>  RequestTransaction(Rdy => TransactionRec(117).Rdy, Ack => TransactionRec(117).Ack) ; 
    896             1                    ***0***           when 118 =>  RequestTransaction(Rdy => TransactionRec(118).Rdy, Ack => TransactionRec(118).Ack) ; 
    897             1                    ***0***           when 119 =>  RequestTransaction(Rdy => TransactionRec(119).Rdy, Ack => TransactionRec(119).Ack) ; 
    898             1                    ***0***           when 120 =>  RequestTransaction(Rdy => TransactionRec(120).Rdy, Ack => TransactionRec(120).Ack) ; 
    899             1                    ***0***           when 121 =>  RequestTransaction(Rdy => TransactionRec(121).Rdy, Ack => TransactionRec(121).Ack) ; 
    900             1                    ***0***           when 122 =>  RequestTransaction(Rdy => TransactionRec(122).Rdy, Ack => TransactionRec(122).Ack) ; 
    901             1                    ***0***           when 123 =>  RequestTransaction(Rdy => TransactionRec(123).Rdy, Ack => TransactionRec(123).Ack) ; 
    902             1                    ***0***           when 124 =>  RequestTransaction(Rdy => TransactionRec(124).Rdy, Ack => TransactionRec(124).Ack) ; 
    903             1                    ***0***           when 125 =>  RequestTransaction(Rdy => TransactionRec(125).Rdy, Ack => TransactionRec(125).Ack) ; 
    904             1                    ***0***           when 126 =>  RequestTransaction(Rdy => TransactionRec(126).Rdy, Ack => TransactionRec(126).Ack) ; 
    905             1                    ***0***           when 127 =>  RequestTransaction(Rdy => TransactionRec(127).Rdy, Ack => TransactionRec(127).Ack) ; 
    906             1                    ***0***           when 128 =>  RequestTransaction(Rdy => TransactionRec(128).Rdy, Ack => TransactionRec(128).Ack) ; 
    907             1                    ***0***           when 129 =>  RequestTransaction(Rdy => TransactionRec(129).Rdy, Ack => TransactionRec(129).Ack) ; 
    908             1                    ***0***           when others => Alert("AddressBusTransactionArrayPkg: Please extend AddressBusArrayRequestTransaction to handle " & to_string(Index) & " indices") ; 
    909                                                  end case ;  
    910                                                end procedure AddressBusArrayRequestTransaction ; 
    911                                                
    912                                                
    913                                                -- ========================================================
    914                                                --  Directive Transactions
    915                                                --  Interact with verification component but not interface.
    916                                                -- ========================================================
    917                                                ------------------------------------------------------------
    918                                                procedure WaitForTransaction (
    919                                                --  Wait until pending transaction completes
    920                                                ------------------------------------------------------------
    921                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    922                                                  constant Index          : In    integer  
    923                                                ) is
    924                                                begin
    925             1                    ***0***         TransactionRec(Index).Operation     <= WAIT_FOR_TRANSACTION ;
    926             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    927                                                end procedure WaitForTransaction ; 
    928                                              
    929                                                ------------------------------------------------------------
    930                                                procedure WaitForWriteTransaction (
    931                                                --  Wait until pending transaction completes
    932                                                ------------------------------------------------------------
    933                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    934                                                  constant Index          : In    integer  
    935                                                ) is
    936                                                begin
    937             1                    ***0***         TransactionRec(Index).Operation     <= WAIT_FOR_WRITE_TRANSACTION ;
    938             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    939                                                end procedure WaitForWriteTransaction ; 
    940                                              
    941                                                ------------------------------------------------------------
    942                                                procedure WaitForReadTransaction (
    943                                                --  Wait until pending transaction completes
    944                                                ------------------------------------------------------------
    945                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    946                                                  constant Index          : In    integer  
    947                                                ) is
    948                                                begin
    949             1                    ***0***         TransactionRec(Index).Operation     <= WAIT_FOR_READ_TRANSACTION ;
    950             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    951                                                end procedure WaitForReadTransaction ; 
    952                                              
    953                                                ------------------------------------------------------------
    954                                                procedure WaitForClock (
    955                                                -- Directive:  Wait for NumberOfClocks number of clocks in the model
    956                                                ------------------------------------------------------------
    957                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    958                                                  constant Index          : In    integer  ;
    959                                                  constant NumberOfClocks : In    natural := 1
    960                                                ) is
    961                                                begin
    962             1                    ***0***         TransactionRec(Index).Operation     <= WAIT_FOR_CLOCK ;
    963             1                    ***0***         TransactionRec(Index).IntToModel    <= NumberOfClocks ; 
    964             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    965                                                end procedure WaitForClock ;
    966                                              
    967                                                ------------------------------------------------------------
    968                                                procedure GetTransactionCount (
    969                                                ------------------------------------------------------------
    970                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    971                                                  constant Index          : In    integer  ;
    972                                                  variable Count          : Out   integer
    973                                                ) is
    974                                                begin
    975             1                    ***0***         TransactionRec(Index).Operation     <= GET_TRANSACTION_COUNT ;
    976             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    977                                              
    978                                                  -- Return AlertLogID
    979             1                    ***0***         Count := TransactionRec(Index).IntFromModel ;
    980                                              --    Count := integer(TransactionRec(Index).Rdy) ;
    981                                                end procedure GetTransactionCount ;
    982                                              
    983                                                ------------------------------------------------------------
    984                                                procedure GetWriteTransactionCount (
    985                                                ------------------------------------------------------------
    986                                                  signal   TransactionRec : InOut AddressBusRecArrayType ;
    987                                                  constant Index          : In    integer  ;
    988                                                  variable Count          : Out   integer
    989                                                ) is
    990                                                begin
    991             1                    ***0***         TransactionRec(Index).Operation     <= GET_WRITE_TRANSACTION_COUNT ;
    992             1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    993                                              
    994                                                  -- Return AlertLogID
    995             1                    ***0***         Count := TransactionRec(Index).IntFromModel ;
    996                                                end procedure GetWriteTransactionCount ;
    997                                              
    998                                                ------------------------------------------------------------
    999                                                procedure GetReadTransactionCount (
    1000                                               ------------------------------------------------------------
    1001                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1002                                                 constant Index          : In    integer  ;
    1003                                                 variable Count          : Out   integer
    1004                                               ) is
    1005                                               begin
    1006            1                    ***0***         TransactionRec(Index).Operation     <= GET_READ_TRANSACTION_COUNT ;
    1007            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1008                                             
    1009                                                 -- Return AlertLogID
    1010            1                    ***0***         Count := TransactionRec(Index).IntFromModel ;
    1011                                               end procedure GetReadTransactionCount ;
    1012                                             
    1013                                               ------------------------------------------------------------
    1014                                               procedure GetAlertLogID (
    1015                                               ------------------------------------------------------------
    1016                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1017                                                 constant Index          : In    integer  ;
    1018                                                 variable AlertLogID     : Out   AlertLogIDType
    1019                                               ) is
    1020                                               begin
    1021            1                    ***0***         TransactionRec(Index).Operation     <= GET_ALERTLOG_ID ;
    1022            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1023                                             
    1024                                                 -- Return AlertLogID
    1025            1                    ***0***         AlertLogID := AlertLogIDType(TransactionRec(Index).IntFromModel) ;
    1026                                               end procedure GetAlertLogID ;
    1027                                             
    1028                                               ------------------------------------------------------------
    1029                                               procedure GetErrorCount (
    1030                                               -- Error reporting for testbenches that do not use AlertLogPkg
    1031                                               -- Returns error count.  If an error count /= 0, also print it
    1032                                               ------------------------------------------------------------
    1033                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1034                                                 constant Index          : In    integer  ;
    1035                                                 variable ErrorCount     : Out   natural
    1036                                               ) is
    1037                                                 variable ModelID : AlertLogIDType ;
    1038                                               begin
    1039            1                    ***0***         GetAlertLogID(TransactionRec, Index, ModelID) ;
    1040                                             --    ReportNonZeroAlerts(AlertLogID => ModelID) ;
    1041            1                    ***0***         ErrorCount := GetAlertCount(AlertLogID => ModelID) ;
    1042                                               end procedure GetErrorCount ;
    1043                                             
    1044                                               -- ========================================================
    1045                                               --  Delay Coverage Transactions   
    1046                                               --  Get Delay Coverage ID to change delay coverage parameters.
    1047                                               -- ========================================================
    1048                                               ------------------------------------------------------------
    1049                                               procedure SetUseRandomDelays (
    1050                                               ------------------------------------------------------------
    1051                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1052                                                 constant Index          : In    integer  ;
    1053                                                 constant OptVal         : In    boolean := TRUE
    1054                                               ) is
    1055                                               begin
    1056            1                    ***0***         TransactionRec(Index).Operation     <= SET_USE_RANDOM_DELAYS ;
    1057            1                    ***0***         TransactionRec(Index).BoolToModel   <= OptVal ;
    1058            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1059                                               end procedure SetUseRandomDelays ;
    1060                                             
    1061                                               ------------------------------------------------------------
    1062                                               procedure GetUseRandomDelays (
    1063                                               ------------------------------------------------------------
    1064                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1065                                                 constant Index          : In    integer  ;
    1066                                                 variable OptVal         : Out   boolean
    1067                                               ) is
    1068                                               begin
    1069            1                    ***0***         TransactionRec(Index).Operation     <= GET_USE_RANDOM_DELAYS ;
    1070            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1071            1                    ***0***         OptVal := TransactionRec(Index).BoolFromModel    ;
    1072                                               end procedure GetUseRandomDelays ;
    1073                                               
    1074                                               ------------------------------------------------------------
    1075                                               procedure SetDelayCoverageID (
    1076                                               ------------------------------------------------------------
    1077                                                 signal   TransactionRec : inout AddressBusRecArrayType ;
    1078                                                 constant ArrayIndex     : In    integer  ;
    1079                                                 constant DelayCov       : in    DelayCoverageIdType ;
    1080                                                 constant Index          : in    integer := 1 
    1081                                               ) is
    1082                                               begin
    1083            1                    ***0***         TransactionRec(Index).Operation     <= SET_DELAYCOV_ID ;
    1084            1                    ***0***         TransactionRec(Index).IntToModel    <= DelayCov.ID ;
    1085            1                    ***0***         TransactionRec(Index).Options       <= Index ; 
    1086            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => ArrayIndex) ;
    1087                                               end procedure SetDelayCoverageID ;
    1088                                             
    1089                                               ------------------------------------------------------------
    1090                                               procedure GetDelayCoverageID (
    1091                                               ------------------------------------------------------------
    1092                                                 signal   TransactionRec : inout AddressBusRecArrayType ;
    1093                                                 constant ArrayIndex     : In    integer  ;
    1094                                                 variable DelayCov       : out   DelayCoverageIdType ;
    1095                                                 constant Index          : in    integer := 1 
    1096                                               ) is
    1097                                               begin
    1098            1                    ***0***         TransactionRec(Index).Operation     <= GET_DELAYCOV_ID ;
    1099            1                    ***0***         TransactionRec(Index).Options       <= Index ; 
    1100            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => ArrayIndex) ;
    1101            1                    ***0***         DelayCov := GetDelayCoverage(TransactionRec(Index).IntFromModel) ; 
    1102                                               end procedure GetDelayCoverageID ;
    1103                                             
    1104                                               ------------------------------------------------------------
    1105                                               procedure SetDelayCoverageID (
    1106                                               ------------------------------------------------------------
    1107                                                 signal   TransactionRec : inout AddressBusRecArrayType ;
    1108                                                 constant Index          : In    integer  ;
    1109                                                 constant DelayCov       : in    DelayCoverageIdArrayType 
    1110                                               ) is
    1111                                               begin
    1112            1                    ***0***         for i in DelayCov'range loop
    1112            2                    ***0***     
    1113            1                    ***0***           SetDelayCoverageID(TransactionRec, Index, DelayCov(i), i) ; 
    1114            1                    ***0***         end loop ; 
    1115                                               end procedure SetDelayCoverageID ;
    1116                                             
    1117                                               ------------------------------------------------------------
    1118                                               procedure GetDelayCoverageID (
    1119                                               ------------------------------------------------------------
    1120                                                 signal   TransactionRec : inout AddressBusRecArrayType ;
    1121                                                 constant Index          : In    integer  ;
    1122                                                 variable DelayCov       : out   DelayCoverageIdArrayType 
    1123                                               ) is
    1124                                               begin
    1125            1                    ***0***         for i in DelayCov'range loop
    1125            2                    ***0***     
    1126            1                    ***0***           GetDelayCoverageID(TransactionRec, Index, DelayCov(i), i) ; 
    1127            1                    ***0***         end loop ; 
    1128                                               end procedure GetDelayCoverageID ;
    1129                                             
    1130                                               -- ========================================================
    1131                                               --  Set and Get Burst Mode   
    1132                                               --  Set Burst Mode for models that do bursting.
    1133                                               -- ========================================================
    1134                                               ------------------------------------------------------------
    1135                                               procedure SetBurstMode (
    1136                                               ------------------------------------------------------------
    1137                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1138                                                 constant Index          : In    integer  ;
    1139                                                 constant OptVal         : In    AddressBusFifoBurstModeType
    1140                                               ) is
    1141                                               begin
    1142            1                    ***0***         TransactionRec(Index).Operation     <= SET_BURST_MODE ;
    1143            1                    ***0***         TransactionRec(Index).IntToModel    <= OptVal ;
    1144            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1145                                               end procedure SetBurstMode ;
    1146                                             
    1147                                               ------------------------------------------------------------
    1148                                               procedure GetBurstMode (
    1149                                               ------------------------------------------------------------
    1150                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1151                                                 constant Index          : In    integer  ;
    1152                                                 variable OptVal         : Out   AddressBusFifoBurstModeType
    1153                                               ) is
    1154                                               begin
    1155            1                    ***0***         TransactionRec(Index).Operation     <= GET_BURST_MODE ;
    1156            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1157            1                    ***0***         OptVal := TransactionRec(Index).IntFromModel ; 
    1158                                               end procedure GetBurstMode ;
    1159                                             
    1160                                               --
    1161                                               --  Extensions to support model customizations
    1162                                               -- 
    1163                                               ------------------------------------------------------------
    1164                                               procedure SetModelOptions (
    1165                                               ------------------------------------------------------------
    1166                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1167                                                 constant Index          : In    integer  ;
    1168                                                 constant Option         : In    integer ;
    1169                                                 constant OptVal         : In    boolean
    1170                                               ) is
    1171                                               begin
    1172            1                    ***0***         TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;
    1173            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1174            1                    ***0***         TransactionRec(Index).BoolToModel   <= OptVal ;
    1175            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1176                                               end procedure SetModelOptions ;
    1177                                             
    1178                                               ------------------------------------------------------------
    1179                                               procedure SetModelOptions (
    1180                                               ------------------------------------------------------------
    1181                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1182                                                 constant Index          : In    integer  ;
    1183                                                 constant Option         : In    integer ;
    1184                                                 constant OptVal         : In    integer
    1185                                               ) is
    1186                                               begin
    1187            1                    ***0***         TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;
    1188            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1189            1                    ***0***         TransactionRec(Index).IntToModel    <= OptVal ;
    1190            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1191                                               end procedure SetModelOptions ;
    1192                                             
    1193                                               ------------------------------------------------------------
    1194                                               procedure SetModelOptions (
    1195                                               ------------------------------------------------------------
    1196                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1197                                                 constant Index          : In    integer  ;
    1198                                                 constant Option         : In    integer ;
    1199                                                 constant OptVal         : In    std_logic_vector
    1200                                               ) is
    1201                                               begin
    1202            1                    ***0***         TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;
    1203            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1204            1                    ***0***         TransactionRec(Index).IntToModel    <= to_integer(OptVal) ;
    1205            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1206                                               end procedure SetModelOptions ;
    1207                                              
    1208                                               ------------------------------------------------------------
    1209                                               procedure SetModelOptions (
    1210                                               ------------------------------------------------------------
    1211                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1212                                                 constant Index          : In    integer  ;
    1213                                                 constant Option         : In    integer ;
    1214                                                 constant OptVal         : In    time
    1215                                               ) is
    1216                                               begin
    1217            1                    ***0***         TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;
    1218            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1219            1                    ***0***         TransactionRec(Index).TimeToModel   <= OptVal ;
    1220            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1221                                               end procedure SetModelOptions ;
    1222                                             
    1223                                               ------------------------------------------------------------
    1224                                               procedure GetModelOptions (
    1225                                               ------------------------------------------------------------
    1226                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1227                                                 constant Index          : In    integer  ;
    1228                                                 constant Option         : In    integer ;
    1229                                                 variable OptVal         : Out   boolean
    1230                                               ) is
    1231                                               begin
    1232            1                    ***0***         TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;
    1233            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1234            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1235            1                    ***0***         OptVal := TransactionRec(Index).BoolFromModel    ;
    1236                                               end procedure GetModelOptions ;
    1237                                             
    1238                                               ------------------------------------------------------------
    1239                                               procedure GetModelOptions (
    1240                                               ------------------------------------------------------------
    1241                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1242                                                 constant Index          : In    integer  ;
    1243                                                 constant Option         : In    integer ;
    1244                                                 variable OptVal         : Out   integer
    1245                                               ) is
    1246                                               begin
    1247            1                    ***0***         TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;
    1248            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1249            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1250            1                    ***0***         OptVal := TransactionRec(Index).IntFromModel ; 
    1251                                               end procedure GetModelOptions ;
    1252                                             
    1253                                               ------------------------------------------------------------
    1254                                               procedure GetModelOptions (
    1255                                               ------------------------------------------------------------
    1256                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1257                                                 constant Index          : In    integer  ;
    1258                                                 constant Option         : In    integer ;
    1259                                                 variable OptVal         : Out   std_logic_vector
    1260                                               ) is
    1261                                               begin
    1262            1                    ***0***         TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;
    1263            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1264            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1265            1                    ***0***         OptVal := to_slv(TransactionRec(Index).IntFromModel, OptVal'length) ; 
    1266                                               end procedure GetModelOptions ;
    1267                                             
    1268                                               ------------------------------------------------------------
    1269                                               procedure GetModelOptions (
    1270                                               ------------------------------------------------------------
    1271                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1272                                                 constant Index          : In    integer  ;
    1273                                                 constant Option         : In    integer ;
    1274                                                 variable OptVal         : Out   time
    1275                                               ) is
    1276                                               begin
    1277            1                    ***0***         TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;
    1278            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1279            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1280            1                    ***0***         OptVal := TransactionRec(Index).TimeFromModel ; 
    1281                                               end procedure GetModelOptions ;
    1282                                             
    1283                                               ------------------------------------------------------------
    1284                                               procedure InterruptReturn (
    1285                                               ------------------------------------------------------------
    1286                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1287                                                 constant Index          : In    integer  
    1288                                               ) is
    1289                                               begin
    1290            1                    ***0***         TransactionRec(Index).Operation     <= INTERRUPT_RETURN ;
    1291            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1292                                               end procedure InterruptReturn ;
    1293                                             
    1294                                               ------------------------------------------------------------
    1295                                               procedure Write (
    1296                                               -- do CPU Write Cycle
    1297                                               ------------------------------------------------------------
    1298                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1299                                                 constant Index          : In    integer  ;
    1300                                                          iAddr          : In    std_logic_vector ;
    1301                                                          iData          : In    std_logic_vector ;
    1302                                                          StatusMsgOn    : In    boolean := false
    1303                                               ) is
    1304                                               begin
    1305                                                 -- Put values in record
    1306            1                    ***0***         TransactionRec(Index).Operation     <= WRITE_OP ;
    1307            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1308            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1309            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(iData, TransactionRec(Index).DataToModel'length) ;
    1310            1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    1311            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1312                                                 -- Start Transaction
    1313            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1314                                               end procedure Write ;
    1315                                             
    1316                                               ------------------------------------------------------------
    1317                                               procedure WriteAsync (
    1318                                               -- dispatch CPU Write Cycle
    1319                                               ------------------------------------------------------------
    1320                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1321                                                 constant Index          : In    integer  ;
    1322                                                          iAddr          : In    std_logic_vector ;
    1323                                                          iData          : In    std_logic_vector ;
    1324                                                          StatusMsgOn    : In    boolean := false
    1325                                               ) is
    1326                                               begin
    1327                                                 -- Put values in record
    1328            1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_WRITE ;
    1329            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1330            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1331            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(iData, TransactionRec(Index).DataToModel'length) ;
    1332            1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    1333            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1334                                                 -- Start Transaction
    1335            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1336                                               end procedure WriteAsync ;
    1337                                             
    1338                                               ------------------------------------------------------------
    1339                                               procedure WriteAddressAsync (
    1340                                               -- dispatch CPU Write Address Cycle
    1341                                               ------------------------------------------------------------
    1342                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1343                                                 constant Index          : In    integer  ;
    1344                                                          iAddr          : In    std_logic_vector ;
    1345                                                          StatusMsgOn    : In    boolean := false
    1346                                               ) is
    1347                                               begin
    1348                                                 -- Put values in record
    1349            1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_WRITE_ADDRESS ;
    1350            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1351            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1352            1                    ***0***         TransactionRec(Index).DataWidth     <= 0 ;
    1353            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1354                                                 -- Start Transaction
    1355            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1356                                               end procedure WriteAddressAsync ;
    1357                                             
    1358                                               ------------------------------------------------------------
    1359                                               procedure WriteDataAsync (
    1360                                               -- dispatch CPU Write Data Cycle
    1361                                               ------------------------------------------------------------
    1362                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1363                                                 constant Index          : In    integer  ;
    1364                                                          iAddr          : In    std_logic_vector ;
    1365                                                          iData          : In    std_logic_vector ;
    1366                                                          StatusMsgOn    : In    boolean := false
    1367                                               ) is
    1368                                               begin
    1369                                                 -- Put values in record
    1370            1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_WRITE_DATA ;
    1371            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1372            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1373            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(iData, TransactionRec(Index).DataToModel'length) ;
    1374            1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    1375            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1376                                                 -- Start Transaction
    1377            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1378                                               end procedure WriteDataAsync ;
    1379                                               
    1380                                               ------------------------------------------------------------
    1381                                               procedure WriteDataAsync (
    1382                                               ------------------------------------------------------------
    1383                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1384                                                 constant Index          : In    integer  ;
    1385                                                          iData          : In    std_logic_vector ;
    1386                                                          StatusMsgOn    : In    boolean := false
    1387                                               ) is
    1388                                               begin
    1389            1                    ***0***         WriteDataAsync(TransactionRec, Index, X"00", iData, StatusMsgOn) ;
    1390                                               end procedure WriteDataAsync ;
    1391                                             
    1392                                               ------------------------------------------------------------
    1393                                               procedure Read (
    1394                                               -- do CPU Read Cycle and return data
    1395                                               ------------------------------------------------------------
    1396                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1397                                                 constant Index          : In    integer  ;
    1398                                                          iAddr          : In    std_logic_vector ;
    1399                                                 variable oData          : Out   std_logic_vector ;
    1400                                                          StatusMsgOn    : In    boolean := false
    1401                                               ) is
    1402                                               begin
    1403                                                 -- Put values in record
    1404            1                    ***0***         TransactionRec(Index).Operation     <= READ_OP ;
    1405            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1406            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1407            1                    ***0***         TransactionRec(Index).DataWidth     <= oData'length ;
    1408            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1409                                                 -- Start Transaction
    1410            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1411                                                 -- Return Results
    1412            1                    ***0***         oData  := SafeResize(TransactionRec(Index).DataFromModel, oData'length) ;
    1413                                               end procedure Read ;
    1414                                             
    1415                                               ------------------------------------------------------------
    1416                                               procedure ReadCheck (
    1417                                               -- do CPU Read Cycle and check supplied data
    1418                                               ------------------------------------------------------------
    1419                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1420                                                 constant Index          : In    integer  ;
    1421                                                          iAddr          : In    std_logic_vector ;
    1422                                                          iData          : In    std_logic_vector ;
    1423                                                          StatusMsgOn    : In    boolean := false
    1424                                               ) is
    1425                                               begin
    1426                                                 -- Put values in record
    1427            1                    ***0***         TransactionRec(Index).Operation     <= READ_CHECK ;
    1428            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1429            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1430            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(iData, TransactionRec(Index).DataToModel'length) ;
    1431            1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    1432            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1433                                                 -- Start Transaction
    1434            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1435                                               end procedure ReadCheck ;
    1436                                             
    1437                                               ------------------------------------------------------------
    1438                                               procedure ReadAddressAsync (
    1439                                               -- dispatch CPU Read Address Cycle
    1440                                               ------------------------------------------------------------
    1441                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1442                                                 constant Index          : In    integer  ;
    1443                                                          iAddr          : In    std_logic_vector ;
    1444                                                          StatusMsgOn    : In    boolean := false
    1445                                               ) is
    1446                                               begin
    1447                                                 -- Put values in record
    1448            1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_READ_ADDRESS ;
    1449            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1450            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1451            1                    ***0***         TransactionRec(Index).DataToModel   <= (TransactionRec(Index).DataToModel'range => 'X') ;
    1452            1                    ***0***         TransactionRec(Index).DataWidth     <= 0 ;
    1453            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1454                                                 -- Start Transaction
    1455            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1456                                               end procedure ReadAddressAsync ;
    1457                                             
    1458                                               ------------------------------------------------------------
    1459                                               procedure ReadData (
    1460                                               -- Do CPU Read Data Cycle
    1461                                               ------------------------------------------------------------
    1462                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1463                                                 constant Index          : In    integer  ;
    1464                                                 variable oData          : Out   std_logic_vector ;
    1465                                                          StatusMsgOn    : In    boolean := false
    1466                                               ) is
    1467                                               begin
    1468                                                 -- Put values in record
    1469            1                    ***0***         TransactionRec(Index).Operation     <= READ_DATA ;
    1470            1                    ***0***         TransactionRec(Index).Address       <= (TransactionRec(Index).Address'range => 'X') ;
    1471            1                    ***0***         TransactionRec(Index).DataWidth     <= oData'length ;
    1472            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1473                                                 -- Start Transaction
    1474            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1475                                                 -- Return Results
    1476            1                    ***0***         oData  := SafeResize(TransactionRec(Index).DataFromModel, oData'length) ;
    1477                                               end procedure ReadData ;
    1478                                             
    1479                                               ------------------------------------------------------------
    1480                                               procedure ReadCheckData (
    1481                                               -- Do CPU Read Data Cycle and check received Data
    1482                                               ------------------------------------------------------------
    1483                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1484                                                 constant Index          : In    integer  ;
    1485                                                          iData          : In    std_logic_vector ;
    1486                                                          StatusMsgOn    : In    boolean := false
    1487                                               ) is
    1488                                               begin
    1489                                                 -- Put values in record
    1490            1                    ***0***         TransactionRec(Index).Operation     <= READ_DATA_CHECK ;
    1491            1                    ***0***         TransactionRec(Index).Address       <= (TransactionRec(Index).Address'range => 'X') ;
    1492            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(iData, TransactionRec(Index).DataToModel'length) ;
    1493            1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    1494            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1495                                                 -- Start Transaction
    1496            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1497                                               end procedure ReadCheckData ;
    1498                                             
    1499                                               ------------------------------------------------------------
    1500                                               procedure TryReadData (
    1501                                               -- Try to Get CPU Read Data Cycle
    1502                                               -- If data is available, get it and return available TRUE.
    1503                                               -- Otherwise Return Available FALSE.
    1504                                               ------------------------------------------------------------
    1505                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1506                                                 constant Index          : In    integer  ;
    1507                                                 variable oData          : Out   std_logic_vector ;
    1508                                                 variable Available      : Out   boolean ;
    1509                                                          StatusMsgOn    : In    boolean := false
    1510                                               ) is
    1511                                               begin
    1512                                                 -- Put values in record
    1513            1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_READ_DATA ;
    1514            1                    ***0***         TransactionRec(Index).Address       <= (TransactionRec(Index).Address'range => 'X') ;
    1515            1                    ***0***         TransactionRec(Index).DataWidth     <= oData'length ;
    1516            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1517                                                 -- Start Transaction
    1518            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1519                                                 -- Return Results
    1520            1                    ***0***         oData  := SafeResize(TransactionRec(Index).DataFromModel, oData'length) ;
    1521            1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    1522                                               end procedure TryReadData ;
    1523                                             
    1524                                               ------------------------------------------------------------
    1525                                               procedure TryReadCheckData (
    1526                                               -- Try to Get CPU Read Data Cycle
    1527                                               -- If data is available, check it and return available TRUE.
    1528                                               -- Otherwise Return Available FALSE.
    1529                                               ------------------------------------------------------------
    1530                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1531                                                 constant Index          : In    integer  ;
    1532                                                          iData          : In    std_logic_vector ;
    1533                                                 variable Available      : Out   boolean ;
    1534                                                          StatusMsgOn    : In    boolean := false
    1535                                               ) is
    1536                                               begin
    1537                                                 -- Put values in record
    1538            1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_READ_DATA_CHECK ;
    1539            1                    ***0***         TransactionRec(Index).Address       <= (TransactionRec(Index).Address'range => 'X') ;
    1540            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(iData, TransactionRec(Index).DataToModel'length) ;
    1541            1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    1542            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1543                                                 -- Start Transaction
    1544            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1545            1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    1546                                               end procedure TryReadCheckData ;
    1547                                             
    1548                                               ------------------------------------------------------------
    1549                                               procedure ReadPoll (
    1550                                               -- Read location (iAddr) until Data(IndexI) = ValueI
    1551                                               ------------------------------------------------------------
    1552                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1553                                                 constant Index          : In    integer  ;
    1554                                                          iAddr          : In    std_logic_vector ;
    1555                                                 variable oData          : Out   std_logic_vector ;
    1556                                                          RegIndex       : In    Integer ;
    1557                                                          BitValue       : In    std_logic ;
    1558                                                          StatusMsgOn    : In    boolean := false ;
    1559                                                          WaitTime       : In    natural := 10
    1560                                               ) is
    1561                                                 variable vData    : std_logic_vector(oData'length-1 downto 0) ;
    1562                                                 variable ModelID  : AlertLogIDType ;
    1563                                               begin
    1564            1                    ***0***         loop
    1565            1                    ***0***           WaitForClock(TransactionRec, Index, WaitTime) ;
    1566            1                    ***0***           Read (TransactionRec, Index, iAddr, vData) ;
    1567            1                    ***0***           exit when vData(RegIndex) = BitValue ;
    1568            1                    ***0***         end loop ;
    1569                                             
    1570            1                    ***0***         GetAlertLogID(TransactionRec, Index, ModelID) ;
    1571                                                 Log(ModelID, "CpuPoll: address" & to_hstring(iAddr) &
    1572            1                    ***0***           "  Data: " & to_hstring(vData), INFO, StatusMsgOn) ;
    1573            1                    ***0***         oData := vData ;
    1574                                               end procedure ReadPoll ;
    1575                                             
    1576                                               ------------------------------------------------------------
    1577                                               procedure ReadPoll (
    1578                                               -- Read location (iAddr) until Data(IndexI) = ValueI
    1579                                               ------------------------------------------------------------
    1580                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1581                                                 constant Index          : In    integer  ;
    1582                                                          iAddr          : In    std_logic_vector ;
    1583                                                          RegIndex       : In    Integer ;
    1584                                                          BitValue       : In    std_logic ;
    1585                                                          StatusMsgOn    : In    boolean := false ;
    1586                                                          WaitTime       : In    natural := 10
    1587                                               ) is
    1588                                                 variable vData    : std_logic_vector(TransactionRec(Index).DataFromModel'range) ;
    1589                                               begin
    1590            1                    ***0***         ReadPoll(TransactionRec, Index, iAddr, vData, RegIndex, BitValue, StatusMsgOn, WaitTime) ;
    1591                                               end procedure ReadPoll ;
    1592                                             
    1593                                               ------------------------------------------------------------
    1594                                               procedure WriteAndRead (
    1595                                               -- Write and Read Cycle that use same address and are dispatched together
    1596                                               ------------------------------------------------------------
    1597                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1598                                                 constant Index          : In    integer  ;
    1599                                                          iAddr          : In    std_logic_vector ;
    1600                                                          iData          : In    std_logic_vector ;
    1601                                                 variable oData          : Out   std_logic_vector ;
    1602                                                          StatusMsgOn    : In    boolean := false
    1603                                               ) is
    1604                                               begin
    1605                                                 -- Put values in record
    1606            1                    ***0***         TransactionRec(Index).Operation     <= WRITE_AND_READ ;
    1607            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1608            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1609            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(iData, TransactionRec(Index).DataToModel'length) ;
    1610            1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    1611            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1612                                                 -- Start Transaction
    1613            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1614                                                 -- Return Results
    1615            1                    ***0***         oData  := SafeResize(TransactionRec(Index).DataFromModel, oData'length) ;  
    1616                                               end procedure WriteAndRead ;
    1617                                             
    1618                                               ------------------------------------------------------------
    1619                                               procedure WriteAndReadAsync (
    1620                                               -- Dispatch Write Address and Data.  Do not wait for completion
    1621                                               -- Dispatch Read Address.  Do not wait for Read Data.  
    1622                                               -- Retrieve read data with ReadData or TryReadData
    1623                                               ------------------------------------------------------------
    1624                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1625                                                 constant Index          : In    integer  ;
    1626                                                          iAddr          : In    std_logic_vector ;
    1627                                                          iData          : In    std_logic_vector ;
    1628                                                          StatusMsgOn    : In    boolean := false
    1629                                               ) is
    1630                                               begin
    1631                                                 -- Put values in record
    1632            1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_WRITE_AND_READ ;
    1633            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1634            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1635            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(iData, TransactionRec(Index).DataToModel'length) ;
    1636            1                    ***0***         TransactionRec(Index).DataWidth     <= iData'length ;
    1637            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1638                                                 -- Start Transaction
    1639            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1640                                               end procedure WriteAndReadAsync ;
    1641                                               
    1642                                               -- ========================================================
    1643                                               --  Burst Transactions
    1644                                               -- ========================================================
    1645                                             
    1646                                               ------------------------------------------------------------
    1647                                               procedure WriteBurst (
    1648                                               -- do CPU Write Cycle
    1649                                               ------------------------------------------------------------
    1650                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1651                                                 constant Index          : In    integer  ;
    1652                                                          iAddr          : In    std_logic_vector ;
    1653                                                          NumFifoWords   : In    integer ;
    1654                                                          StatusMsgOn    : In    boolean := false
    1655                                               ) is
    1656                                               begin
    1657                                                 -- Put values in record
    1658            1                    ***0***         TransactionRec(Index).Operation     <= WRITE_BURST ;
    1659            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1660            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1661                                             --    TransactionRec(Index).DataToModel   <= (TransactionRec(Index).DataToModel'range => 'X') ;
    1662            1                    ***0***         TransactionRec(Index).DataWidth     <= NumFifoWords ;
    1663            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1664                                                 -- Start Transaction
    1665            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1666                                               end procedure WriteBurst ;
    1667                                               
    1668                                               ------------------------------------------------------------
    1669                                               procedure WriteBurstVector (
    1670                                               ------------------------------------------------------------
    1671                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1672                                                 constant Index          : In    integer  ;
    1673                                                          iAddr          : In    std_logic_vector ;
    1674                                                          VectorOfWords  : In    slv_vector ;
    1675                                                          StatusMsgOn    : In    boolean := false
    1676                                               ) is
    1677                                               begin
    1678            1                    ***0***         PushBurstVector(TransactionRec(Index).WriteBurstFifo, VectorOfWords) ; 
    1679            1                    ***0***         WriteBurst(TransactionRec, Index, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1680                                               end procedure WriteBurstVector ;
    1681                                               
    1682                                               ------------------------------------------------------------
    1683                                               procedure WriteBurstVector (
    1684                                               ------------------------------------------------------------
    1685                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1686                                                 constant Index          : In    integer  ;
    1687                                                          iAddr          : In    std_logic_vector ;
    1688                                                          VectorOfWords  : In    integer_vector ;
    1689                                                          FifoWidth      : In    integer ; 
    1690                                                          StatusMsgOn    : In    boolean := false
    1691                                               ) is
    1692                                               begin
    1693            1                    ***0***         PushBurstVector(TransactionRec(Index).WriteBurstFifo, VectorOfWords, FifoWidth) ; 
    1694            1                    ***0***         WriteBurst(TransactionRec, Index, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1695                                               end procedure WriteBurstVector ;
    1696                                               
    1697                                               ------------------------------------------------------------
    1698                                               procedure WriteBurstIncrement (
    1699                                               ------------------------------------------------------------
    1700                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1701                                                 constant Index          : In    integer  ;
    1702                                                          iAddr          : In    std_logic_vector ;
    1703                                                          FirstWord      : In    std_logic_vector ;
    1704                                                          NumFifoWords   : In    integer ;
    1705                                                          StatusMsgOn    : In    boolean := false
    1706                                               ) is
    1707                                               begin
    1708            1                    ***0***         PushBurstIncrement(TransactionRec(Index).WriteBurstFifo, FirstWord, NumFifoWords) ; 
    1709            1                    ***0***         WriteBurst(TransactionRec, Index, iAddr, NumFifoWords, StatusMsgOn) ; 
    1710                                               end procedure WriteBurstIncrement ;
    1711                                             
    1712                                               ------------------------------------------------------------
    1713                                               procedure WriteBurstRandom (
    1714                                               ------------------------------------------------------------
    1715                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1716                                                 constant Index          : In    integer  ;
    1717                                                          iAddr          : In    std_logic_vector ;
    1718                                                          FirstWord      : In    std_logic_vector ;
    1719                                                          NumFifoWords   : In    integer ;
    1720                                                          StatusMsgOn    : In    boolean := false
    1721                                               ) is
    1722                                               begin
    1723            1                    ***0***         PushBurstRandom(TransactionRec(Index).WriteBurstFifo, FirstWord, NumFifoWords) ; 
    1724            1                    ***0***         WriteBurst(TransactionRec, Index, iAddr, NumFifoWords, StatusMsgOn) ; 
    1725                                               end procedure WriteBurstRandom ;
    1726                                             
    1727                                               ------------------------------------------------------------
    1728                                               procedure WriteBurstRandom (
    1729                                               ------------------------------------------------------------
    1730                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1731                                                 constant Index          : In    integer  ;
    1732                                                          iAddr          : In    std_logic_vector ;
    1733                                                          CoverID        : In    CoverageIDType ;
    1734                                                          NumFifoWords   : In    integer ;
    1735                                                          FifoWidth      : In    integer ;
    1736                                                          StatusMsgOn    : In    boolean := false
    1737                                               ) is
    1738                                               begin
    1739            1                    ***0***         PushBurstRandom(TransactionRec(Index).WriteBurstFifo, CoverID, NumFifoWords, FifoWidth) ; 
    1740            1                    ***0***         WriteBurst(TransactionRec, Index, iAddr, NumFifoWords, StatusMsgOn) ; 
    1741                                               end procedure WriteBurstRandom ;
    1742                                             
    1743                                               ------------------------------------------------------------
    1744                                               procedure WriteBurstAsync (
    1745                                               -- dispatch CPU Write Cycle
    1746                                               ------------------------------------------------------------
    1747                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1748                                                 constant Index          : In    integer  ;
    1749                                                          iAddr          : In    std_logic_vector ;
    1750                                                          NumFifoWords   : In    integer ;
    1751                                                          StatusMsgOn    : In    boolean := false
    1752                                               ) is
    1753                                               begin
    1754                                                 -- Put values in record
    1755            1                    ***0***         TransactionRec(Index).Operation     <= ASYNC_WRITE_BURST ;
    1756            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1757            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1758                                             --    TransactionRec(Index).DataToModel   <= (TransactionRec(Index).DataToModel'range => 'X') ;
    1759            1                    ***0***         TransactionRec(Index).DataWidth     <= NumFifoWords ;
    1760            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1761                                                 -- Start Transaction
    1762            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1763                                               end procedure WriteBurstAsync ;
    1764                                               
    1765                                               ------------------------------------------------------------
    1766                                               procedure WriteBurstVectorAsync (
    1767                                               ------------------------------------------------------------
    1768                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1769                                                 constant Index          : In    integer  ;
    1770                                                          iAddr          : In    std_logic_vector ;
    1771                                                          VectorOfWords  : In    slv_vector ;
    1772                                                          StatusMsgOn    : In    boolean := false
    1773                                               ) is
    1774                                               begin
    1775            1                    ***0***         PushBurstVector(TransactionRec(Index).WriteBurstFifo, VectorOfWords) ; 
    1776            1                    ***0***         WriteBurstAsync(TransactionRec, Index, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1777                                               end procedure WriteBurstVectorAsync ;
    1778                                               
    1779                                               ------------------------------------------------------------
    1780                                               procedure WriteBurstVectorAsync (
    1781                                               ------------------------------------------------------------
    1782                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1783                                                 constant Index          : In    integer  ;
    1784                                                          iAddr          : In    std_logic_vector ;
    1785                                                          VectorOfWords  : In    integer_vector ;
    1786                                                          FifoWidth      : In    integer ; 
    1787                                                          StatusMsgOn    : In    boolean := false
    1788                                               ) is
    1789                                               begin
    1790            1                    ***0***         PushBurstVector(TransactionRec(Index).WriteBurstFifo, VectorOfWords, FifoWidth) ; 
    1791            1                    ***0***         WriteBurstAsync(TransactionRec, Index, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1792                                               end procedure WriteBurstVectorAsync ;
    1793                                             
    1794                                               ------------------------------------------------------------
    1795                                               procedure WriteBurstIncrementAsync (
    1796                                               ------------------------------------------------------------
    1797                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1798                                                 constant Index          : In    integer  ;
    1799                                                          iAddr          : In    std_logic_vector ;
    1800                                                          FirstWord      : In    std_logic_vector ;
    1801                                                          NumFifoWords   : In    integer ;
    1802                                                          StatusMsgOn    : In    boolean := false
    1803                                               ) is
    1804                                               begin
    1805            1                    ***0***         PushBurstIncrement(TransactionRec(Index).WriteBurstFifo, FirstWord, NumFifoWords) ; 
    1806            1                    ***0***         WriteBurstAsync(TransactionRec, Index, iAddr, NumFifoWords, StatusMsgOn) ; 
    1807                                               end procedure WriteBurstIncrementAsync ;
    1808                                             
    1809                                               ------------------------------------------------------------
    1810                                               procedure WriteBurstRandomAsync (
    1811                                               ------------------------------------------------------------
    1812                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1813                                                 constant Index          : In    integer  ;
    1814                                                          iAddr          : In    std_logic_vector ;
    1815                                                          FirstWord      : In    std_logic_vector ;
    1816                                                          NumFifoWords   : In    integer ;
    1817                                                          StatusMsgOn    : In    boolean := false
    1818                                               ) is
    1819                                               begin
    1820            1                    ***0***         PushBurstRandom(TransactionRec(Index).WriteBurstFifo, FirstWord, NumFifoWords) ; 
    1821            1                    ***0***         WriteBurstAsync(TransactionRec, Index, iAddr, NumFifoWords, StatusMsgOn) ; 
    1822                                               end procedure WriteBurstRandomAsync ;  
    1823                                               
    1824                                               ------------------------------------------------------------
    1825                                               procedure WriteBurstRandomAsync (
    1826                                               ------------------------------------------------------------
    1827                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1828                                                 constant Index          : In    integer  ;
    1829                                                          iAddr          : In    std_logic_vector ;
    1830                                                          CoverID        : In    CoverageIDType ;
    1831                                                          NumFifoWords   : In    integer ;
    1832                                                          FifoWidth      : In    integer ;
    1833                                                          StatusMsgOn    : In    boolean := false
    1834                                               ) is
    1835                                               begin
    1836            1                    ***0***         PushBurstRandom(TransactionRec(Index).WriteBurstFifo, CoverID, NumFifoWords, FifoWidth) ; 
    1837            1                    ***0***         WriteBurstAsync(TransactionRec, Index, iAddr, NumFifoWords, StatusMsgOn) ; 
    1838                                               end procedure WriteBurstRandomAsync ;
    1839                                             
    1840                                               ------------------------------------------------------------
    1841                                               procedure ReadBurst (
    1842                                               -- do CPU Read Cycle and return data
    1843                                               ------------------------------------------------------------
    1844                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1845                                                 constant Index          : In    integer  ;
    1846                                                          iAddr          : In    std_logic_vector ;
    1847                                                          NumFifoWords   : In    integer ;
    1848                                                          StatusMsgOn    : In    boolean := false
    1849                                               ) is
    1850                                               begin
    1851                                                 -- Put values in record
    1852            1                    ***0***         TransactionRec(Index).Operation     <= READ_BURST ;
    1853            1                    ***0***         TransactionRec(Index).Address       <= SafeResize(iAddr, TransactionRec(Index).Address'length) ;
    1854            1                    ***0***         TransactionRec(Index).AddrWidth     <= iAddr'length ;
    1855            1                    ***0***         TransactionRec(Index).DataWidth     <= NumFifoWords ;
    1856                                             --??    TransactionRec(Index).DataWidth     <= 0 ;
    1857            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= StatusMsgOn ;
    1858                                                 -- Start Transaction
    1859            1                    ***0***         AddressBusArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1860                                             --??    -- Return Results
    1861                                             --??    NumFifoWords := TransactionRec(Index).IntFromModel ;
    1862                                               end procedure ReadBurst ;
    1863                                               
    1864                                               ------------------------------------------------------------
    1865                                               procedure ReadCheckBurstVector (
    1866                                               ------------------------------------------------------------
    1867                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1868                                                 constant Index          : In    integer  ;
    1869                                                          iAddr          : In    std_logic_vector ;
    1870                                                          VectorOfWords  : In    slv_vector ;
    1871                                                          StatusMsgOn    : In    boolean := false
    1872                                               ) is
    1873                                               begin
    1874            1                    ***0***         ReadBurst(TransactionRec, Index, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1875            1                    ***0***         CheckBurstVector(TransactionRec(Index).ReadBurstFifo, VectorOfWords) ;
    1876                                               end procedure ReadCheckBurstVector ;
    1877                                               
    1878                                               ------------------------------------------------------------
    1879                                               procedure ReadCheckBurstVector (
    1880                                               ------------------------------------------------------------
    1881                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1882                                                 constant Index          : In    integer  ;
    1883                                                          iAddr          : In    std_logic_vector ;
    1884                                                          VectorOfWords  : In    integer_vector ;
    1885                                                          FifoWidth      : In    integer ; 
    1886                                                          StatusMsgOn    : In    boolean := false
    1887                                               ) is
    1888                                               begin
    1889            1                    ***0***         ReadBurst(TransactionRec, Index, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1890            1                    ***0***         CheckBurstVector(TransactionRec(Index).ReadBurstFifo, VectorOfWords, FifoWidth) ;
    1891                                               end procedure ReadCheckBurstVector ;
    1892                                               
    1893                                               ------------------------------------------------------------
    1894                                               procedure ReadCheckBurstIncrement (
    1895                                               ------------------------------------------------------------
    1896                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1897                                                 constant Index          : In    integer  ;
    1898                                                          iAddr          : In    std_logic_vector ;
    1899                                                          FirstWord      : In    std_logic_vector ;
    1900                                                          NumFifoWords   : In    integer ;
    1901                                                          StatusMsgOn    : In    boolean := false
    1902                                               ) is
    1903                                               begin
    1904            1                    ***0***         ReadBurst(TransactionRec, Index, iAddr, NumFifoWords, StatusMsgOn) ; 
    1905            1                    ***0***         CheckBurstIncrement(TransactionRec(Index).ReadBurstFifo, FirstWord, NumFifoWords) ; 
    1906                                               end procedure ReadCheckBurstIncrement ;
    1907                                             
    1908                                               ------------------------------------------------------------
    1909                                               procedure ReadCheckBurstRandom (
    1910                                               ------------------------------------------------------------
    1911                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1912                                                 constant Index          : In    integer  ;
    1913                                                          iAddr          : In    std_logic_vector ;
    1914                                                          FirstWord      : In    std_logic_vector ;
    1915                                                          NumFifoWords   : In    integer ;
    1916                                                          StatusMsgOn    : In    boolean := false
    1917                                               ) is
    1918                                               begin
    1919            1                    ***0***         ReadBurst(TransactionRec, Index, iAddr, NumFifoWords, StatusMsgOn) ; 
    1920            1                    ***0***         CheckBurstRandom(TransactionRec(Index).ReadBurstFifo, FirstWord, NumFifoWords) ; 
    1921                                               end procedure ReadCheckBurstRandom ;
    1922                                             
    1923                                               ------------------------------------------------------------
    1924                                               procedure ReadCheckBurstRandom (
    1925                                               ------------------------------------------------------------
    1926                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1927                                                 constant Index          : In    integer  ;
    1928                                                          iAddr          : In    std_logic_vector ;
    1929                                                          CoverID        : In    CoverageIDType ;
    1930                                                          NumFifoWords   : In    integer ;
    1931                                                          FifoWidth      : In    integer ;
    1932                                                          StatusMsgOn    : In    boolean := false
    1933                                               ) is
    1934                                               begin
    1935            1                    ***0***         ReadBurst(TransactionRec, Index, iAddr, NumFifoWords, StatusMsgOn) ; 
    1936            1                    ***0***         CheckBurstRandom(TransactionRec(Index).ReadBurstFifo, CoverID, NumFifoWords, FifoWidth) ; 
    1937                                               end procedure ReadCheckBurstRandom ;
    1938                                             
    1939                                               -- ========================================================
    1940                                               --  Pseudo Transactions
    1941                                               --  Interact with the record only.
    1942                                               -- ========================================================
    1943                                               ------------------------------------------------------------
    1944                                               procedure ReleaseTransactionRecord (
    1945                                               --  Must run on same delta cycle as AcquireTransactionRecord
    1946                                               ------------------------------------------------------------
    1947                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1948                                                 constant Index          : In    integer  
    1949                                               ) is
    1950                                               begin
    1951                                                 -- Set everything driven by TestCtrl to type'left (except Rdy)
    1952            1                    ***0***         TransactionRec(Index).Rdy           <= RdyType'left ;   
    1953            1                    ***0***         TransactionRec(Index).Operation     <= NOT_DRIVEN ;
    1954            1                    ***0***         TransactionRec(Index).Address       <= (TransactionRec(Index).Address'range => 'U') ;
    1955            1                    ***0***         TransactionRec(Index).AddrWidth     <= integer'left ; 
    1956            1                    ***0***         TransactionRec(Index).DataToModel   <= (TransactionRec(Index).DataToModel'range => 'U') ;
    1957            1                    ***0***         TransactionRec(Index).DataWidth     <= integer'left ; 
    1958            1                    ***0***         TransactionRec(Index).StatusMsgOn   <= boolean'left ; 
    1959            1                    ***0***         TransactionRec(Index).IntToModel    <= integer'left ; 
    1960            1                    ***0***         TransactionRec(Index).BoolToModel   <= boolean'left ;  
    1961            1                    ***0***         TransactionRec(Index).Options       <= integer'left ;    
    1962                                               end procedure ReleaseTransactionRecord ; 
    1963                                               
    1964                                               ------------------------------------------------------------
    1965                                               procedure AcquireTransactionRecord (
    1966                                               --  Must run on same delta cycle as ReleaseTransactionRecord
    1967                                               ------------------------------------------------------------
    1968                                                 signal   TransactionRec : InOut AddressBusRecArrayType ;
    1969                                                 constant Index          : In    integer  
    1970                                               ) is
    1971                                               begin
    1972                                                 -- Start Driving Rdy on next delta cycle with the current value.  
    1973            1                    ***0***         TransactionRec(Index).Rdy <= TransactionRec(Index).Rdy ; 
    1974                                               end procedure AcquireTransactionRecord ; 
    1975                                                 
    1976                                             
    1977                                             end package body AddressBusTransactionArrayPkg ;


=================================================================================
=== File: ../osvvm/Common/src/AddressBusTransactionPkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                         6         3         3    50.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/Common/src/AddressBusTransactionPkg.vhd --

------------------------------------IF Branch------------------------------------
    1037                                       4     Count coming in to IF
    1037            1                          3           if s(i) /= NOT_DRIVEN then 
                                               1     All False Count
Branch totals: 2 hits of 2 branches = 100.00%

------------------------------------IF Branch------------------------------------
    1038                                       3     Count coming in to IF
    1038            1                          3             if result = NOT_DRIVEN then 
    1040            1                    ***0***             else
Branch totals: 1 hit of 2 branches = 50.00%

------------------------------------IF Branch------------------------------------
    2269                                 ***0***     Count coming in to IF
    2269            1                    ***0***         if Operation = MULTIPLE_DRIVER_DETECT then
    2272            1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                     266        19       247     7.14%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/AddressBusTransactionPkg.vhd --

    1                                                --
    2                                                --  File Name:         AddressBusTransactionPkg.vhd
    3                                                --  Design Unit Name:  AddressBusTransactionPkg
    4                                                --  Revision:          OSVVM MODELS STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com
    7                                                --  Contributor(s):
    8                                                --     Jim Lewis      jim@synthworks.com
    9                                                --     Rob Gaddi      Highland Technology.    Wrote a similar package which inspired this one.
    10                                               --
    11                                               --
    12                                               --  Description:
    13                                               --    Defines the OSVVM Address Bus Model Independent Transaction
    14                                               --    Interface (AddressBusRecType) and transaction initiation 
    15                                               --    procedures (Read, Write, ...), as well as supporting types,
    16                                               --    constants, and subprograms that are essential to both 
    17                                               --    to Verification Components and testbenches (test 
    18                                               --    harnesses and test sequencers) that use address bus type
    19                                               --    interfaces (such as Axi4 Full, Avalon, Wishbone, ...)
    20                                               --
    21                                               --
    22                                               --  Developed by:
    23                                               --        SynthWorks Design Inc.
    24                                               --        VHDL Training Classes
    25                                               --        http://www.SynthWorks.com
    26                                               --
    27                                               --  Revision History:
    28                                               --    Date      Version    Description
    29                                               --    09/2023   2023.09    Added ModelParametersIDType to Record, 
    30                                               --                         Added OperationType ENUMs:  EXTEND_DIRECTIVE_OP, EXTEND_OP, EXTEND_WRITE_OP, EXTEND_READ_OP
    31                                               --    05/2023   2023.05    Added SetDelayCoverageID and GetDelayCoverageID
    32                                               --    11/2022   2022.11    Added AddressBusRecArrayType
    33                                               --    01/2022   2022.01    Burst patterns - Burst, BurstInc, BurstRandom
    34                                               --    06/2021   2021.06    Updated bursting 
    35                                               --    12/2020   2020.12    Added SetBurstMode, updated parameter names for consistency
    36                                               --    09/2020   2020.09    Updating comments to serve as documentation
    37                                               --    07/2020   2020.07    Unified M/S packages - dropping M/S terminology
    38                                               --    02/2020   2020.02    Refactored from Axi4LiteMasterTransactionPkg
    39                                               --    01/2020   2020.01    Updated license notice
    40                                               --    09/2017   2017       Initial revision
    41                                               --
    42                                               --  This file is part of OSVVM.
    43                                               --  
    44                                               --  Copyright (c) 2017 - 2023 by SynthWorks Design Inc.  
    45                                               --  
    46                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    47                                               --  you may not use this file except in compliance with the License.
    48                                               --  You may obtain a copy of the License at
    49                                               --  
    50                                               --      https://www.apache.org/licenses/LICENSE-2.0
    51                                               --  
    52                                               --  Unless required by applicable law or agreed to in writing, software
    53                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    54                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    55                                               --  See the License for the specific language governing permissions and
    56                                               --  limitations under the License.
    57                                               --  
    58                                               library ieee ;
    59                                                 use ieee.std_logic_1164.all ;
    60                                                 use ieee.numeric_std.all ;
    61                                                 use ieee.numeric_std_unsigned.all ;
    62                                                 use ieee.math_real.all ;
    63                                               
    64                                               library osvvm ;
    65                                                 context osvvm.OsvvmContext ;
    66                                                 use osvvm.ScoreboardPkg_slv.all ; 
    67                                               
    68                                                 use work.ModelParametersSingletonPkg.all ; 
    69                                                 use work.FifoFillPkg_slv.all ; 
    70                                               
    71                                               package AddressBusTransactionPkg is
    72                                               
    73                                                 -- ========================================================
    74                                                 --  AddressBusOperationType 
    75                                                 --  Enumeration type used to communication transaction type
    76                                                 --  to the model via the transaction interface
    77                                                 -- ========================================================
    78                                                 type UnresolvedAddressBusOperationType is (
    79                                                   -- Default. Used by resolution function for Multiple Driver Detection
    80                                                   NOT_DRIVEN,  
    81                                                   --
    82                                                   -- Model Directives
    83                                                   --
    84                                                   WAIT_FOR_CLOCK,
    85                                                   WAIT_FOR_TRANSACTION,
    86                                                   WAIT_FOR_WRITE_TRANSACTION, WAIT_FOR_READ_TRANSACTION, 
    87                                                   GET_TRANSACTION_COUNT, 
    88                                                   GET_WRITE_TRANSACTION_COUNT, GET_READ_TRANSACTION_COUNT,
    89                                                   GET_ALERTLOG_ID, 
    90                                                   -- Delay Coverage ID
    91                                                   SET_USE_RANDOM_DELAYS,
    92                                                   GET_USE_RANDOM_DELAYS,
    93                                                   SET_DELAYCOV_ID,
    94                                                   GET_DELAYCOV_ID,
    95                                                   -- Burst FIFO Configuration
    96                                                   SET_BURST_MODE,
    97                                                   GET_BURST_MODE,
    98                                                   -- Model Options
    99                                                   SET_MODEL_OPTIONS, 
    100                                                  GET_MODEL_OPTIONS,
    101                                                  -- VC Customization of Directives and Functional Operations
    102                                                  EXTEND_DIRECTIVE_OP,
    103                                                  EXTEND_OP,
    104                                                  -- Interrupt Return - used by InterruptHandler VC
    105                                                  INTERRUPT_RETURN,
    106                                                  --
    107                                                  --  bus operations                        Master                Responder
    108                                                  --                       --------------------------------------------------------
    109                                                  WRITE_OP,                -- Blocking     (Tx Addr & Data)      (Rx Addr & Data)
    110                                                  WRITE_ADDRESS,           -- Blocking     (Tx Addr)             (Rx Addr)
    111                                                  WRITE_DATA,              -- Blocking     (Tx Data)             (Rx Data)
    112                                                  ASYNC_WRITE,             -- Non-blocking (Tx Addr & Data)      (Rx Addr & Data)
    113                                                  ASYNC_WRITE_ADDRESS,     -- Non-blocking (Tx Addr)             (Rx Addr)
    114                                                  ASYNC_WRITE_DATA,        -- Non-blocking (Tx Data)             (Rx Data)
    115                                                  -- VC Customization of Write Operations
    116                                                  EXTEND_WRITE_OP,
    117                                                  
    118                                                  READ_OP,                 -- Blocking     (Tx Addr & Rx Data)   (Rx Addr & Tx Data)
    119                                                  READ_ADDRESS,            -- Blocking     (Tx Addr)             (Rx Addr)
    120                                                  READ_DATA,               -- Blocking     (Rx Data)             (Tx Data)
    121                                                  READ_CHECK,              -- Blocking     (Tx Addr & Tx Data)   
    122                                                  READ_DATA_CHECK,         -- Blocking     (Tx Data)             (Tx Data)
    123                                                  ASYNC_READ,              -- Non-blocking  --------             (Rx Addr, Tx Data)
    124                                                  ASYNC_READ_ADDRESS,      -- Non-blocking (Tx Addr)             (Rx Addr)
    125                                                  ASYNC_READ_DATA,         -- Non-blocking (Rx Data)             (Tx Data)
    126                                                  ASYNC_READ_DATA_CHECK,   -- Non-blocking (Tx Data)       
    127                                                  -- VC Customization of Read Operations
    128                                                  EXTEND_READ_OP,
    129                                              
    130                                                  WRITE_AND_READ,          -- Blocking     (Tx Addr & Data, Rx Addr & Data)      
    131                                                  ASYNC_WRITE_AND_READ,    -- Non-blocking (Tx Addr & Data, Rx Addr)      
    132                                                  --
    133                                                  --  burst operations
    134                                                  --                       ----------------------------
    135                                                  WRITE_BURST,             -- Blocking BURST (Tx Addr & Data)
    136                                                  ASYNC_WRITE_BURST,       -- Non-blocking BURST (Tx Addr & Data)
    137                                              -- Potential future expansion, but not implemented yet
    138                                              --    WRITE_BURST_ADDRESS,
    139                                              --    WRITE_BURST_DATA,
    140                                              --    ASYNC_WRITE_BURST_ADDRESS,
    141                                              --    ASYNC_WRITE_BURST_DATA,
    142                                                  
    143                                                  READ_BURST,              -- Blocking BURST (Tx Addr, Rx Data)
    144                                              -- Potential future expansion, but not implemented yet
    145                                              --    READ_BURST_ADDRESS,
    146                                              --    READ_BURST_DATA,
    147                                              --    ASYNC_READ_BURST_ADDRESS,
    148                                              --    ASYNC_READ_BURST_DATA,
    149                                              --    ASYNC_READ_BURST,  -- Master cannot do this - Address, but data not ready.  Responder?  
    150                                              
    151                                                  -- Resolution function detected Multiple drivers
    152                                                  MULTIPLE_DRIVER_DETECT  -- value used when multiple drivers are present
    153                                                ) ;
    154                                                
    155                                                type UnresolvedAddressBusOperationVectorType is array (natural range <>) of UnresolvedAddressBusOperationType ;
    156                                              --  alias resolved_max is maximum[ UnresolvedAddressBusOperationVectorType return UnresolvedAddressBusOperationType] ;
    157                                                -- Maximum is implicitly defined for any array type in VHDL-2008.   Function resolved_max is a fall back.
    158                                                function resolved_max ( s : UnresolvedAddressBusOperationVectorType) return UnresolvedAddressBusOperationType ;
    159                                                subtype AddressBusOperationType is resolved_max UnresolvedAddressBusOperationType ;
    160                                              
    161                                              
    162                                                -- ========================================================
    163                                                --  AddressBusRecType 
    164                                                --  Transaction interface between the test sequencer and the 
    165                                                --  verification component.   As such it is the primary channel 
    166                                                --  for information exchange between the two.
    167                                                --  The types bit_max, std_logic_vector_max_c, integer_max, and 
    168                                                --  boolean_max are defined the OSVVM package, ResolutionPkg.  
    169                                                --  These types allow the record to support multiple drivers and 
    170                                                --  use resolution functions based on function maximum (return largest value)
    171                                                -- ========================================================
    172                                                type AddressBusRecType is record
    173                                                  -- Handshaking controls
    174                                                  --   Used by RequestTransaction in the Transaction Procedures
    175                                                  --   Used by WaitForTransaction in the Verification Component
    176                                                  --   RequestTransaction and WaitForTransaction are in osvvm.TbUtilPkg
    177                                                  Rdy                : RdyType ;
    178                                                  Ack                : AckType ;
    179                                                  -- Transaction Type
    180                                                  Operation          : AddressBusOperationType ;
    181                                                  -- Address to verification component and its width
    182                                                  -- Width may be smaller than Address
    183                                                  Address            : std_logic_vector_max_c ;
    184                                                  AddrWidth          : integer_max ;
    185                                                  -- Data to and from the verification component and its width.
    186                                                  -- Width will be smaller than Data for byte operations
    187                                                  -- Width size requirements are enforced in the verification component
    188                                                  DataToModel        : std_logic_vector_max_c ;
    189                                                  DataFromModel      : std_logic_vector_max_c ;
    190                                                  DataWidth          : integer_max ;
    191                                                  -- Burst FIFOs
    192                                                  WriteBurstFifo     : ScoreboardIdType ; 
    193                                                  ReadBurstFifo      : ScoreboardIdType ; 
    194                                              --    UseCheckFifo       : boolean_max ; 
    195                                              --    CheckFifo          : ScoreboardIdType ; 
    196                                                  -- Parameters - internal settings for the VC in a singleton data structure   
    197                                                  Params             : ModelParametersIDType ;  
    198                                                  -- StatusMsgOn provides transaction messaging override.
    199                                                  -- When true, print transaction messaging independent of 
    200                                                  -- other verification based based controls.
    201                                                  StatusMsgOn        : boolean_max ;
    202                                                  -- Verification Component Options Parameters - used by SetModelOptions
    203                                                  IntToModel         : integer_max ;
    204                                                  IntFromModel       : integer_max ; 
    205                                                  BoolToModel        : boolean_max ; 
    206                                                  BoolFromModel      : boolean_max ;
    207                                                  TimeToModel        : time_max ; 
    208                                                  TimeFromModel      : time_max ; 
    209                                                  -- Verification Component Options Type  
    210                                                  Options            : integer_max ;  
    211                                                end record AddressBusRecType ;
    212                                                
    213                                                type AddressBusRecArrayType  is array (integer range <>) of AddressBusRecType ;
    214                                              
    215                                                -- --------------------------------------------------------
    216                                                -- Usage of the Transaction Interface (AddressBusRecType)
    217                                                -- The Address and Data fields of AddressBusRecType are unconstrained.
    218                                                -- Unconstrained objects may be used on component/entity interfaces.    
    219                                                -- These fields will be sized when used as a record signal in the test harness 
    220                                                -- of the testbench.  Such a declaration is shown below:
    221                                                --
    222                                                --   signal AxiManagerRec : AddressBusRecType(
    223                                                --           Address      (27 downto 0),
    224                                                --           DataToModel  (31 downto 0),
    225                                                --           DataFromModel(31 downto 0)
    226                                                --         ) ;
    227                                                -- --------------------------------------------------------
    228                                                
    229                                              --!TODO add VHDL-2018 Interfaces
    230                                              
    231                                              
    232                                                -- ========================================================
    233                                                --  Types of Transactions
    234                                                --  A transaction may be either a directive or an interface transaction.
    235                                                --
    236                                                --  Directive transactions interact with the verification component 
    237                                                --  without generating any transactions or interface waveforms.
    238                                                --
    239                                                --  An interface transaction results in interface signaling to the DUT.
    240                                                --
    241                                                --  A blocking transaction is an interface transaction that does not 
    242                                                --  does not return (complete) until the interface operation   
    243                                                --  requested by the transaction has completed.
    244                                                --
    245                                                --  An asynchronous transaction is nonblocking interface transaction
    246                                                --  that returns before the transaction has completed - typically 
    247                                                --  immediately and before the transaction has started. 
    248                                                --
    249                                                --  A Try transaction is nonblocking interface transaction that 
    250                                                --  checks to see if transaction information is available, 
    251                                                --  such as read data, and if it is returns it.  
    252                                                --
    253                                                -- ========================================================
    254                                              
    255                                              
    256                                                -- ========================================================
    257                                                --  Directive Transactions  
    258                                                --  Directive transactions interact with the verification component 
    259                                                --  without generating any transactions or interface waveforms.
    260                                                --  Supported by all verification components
    261                                                -- ========================================================
    262                                                ------------------------------------------------------------
    263                                                procedure WaitForTransaction (
    264                                                --  Wait until pending transaction completes
    265                                                ------------------------------------------------------------
    266                                                  signal   TransactionRec : InOut AddressBusRecType 
    267                                                ) ; 
    268                                              
    269                                                ------------------------------------------------------------
    270                                                procedure WaitForWriteTransaction (
    271                                                --  Wait until pending transaction completes
    272                                                ------------------------------------------------------------
    273                                                  signal   TransactionRec : InOut AddressBusRecType 
    274                                                ) ; 
    275                                              
    276                                                ------------------------------------------------------------
    277                                                procedure WaitForReadTransaction (
    278                                                --  Wait until pending transaction completes
    279                                                ------------------------------------------------------------
    280                                                  signal   TransactionRec : InOut AddressBusRecType 
    281                                                ) ;
    282                                                
    283                                                ------------------------------------------------------------
    284                                                procedure WaitForClock (
    285                                                -- Wait for NumberOfClocks number of clocks 
    286                                                -- relative to the verification component clock
    287                                                ------------------------------------------------------------
    288                                                  signal   TransactionRec : InOut AddressBusRecType ;
    289                                                  constant NumberOfClocks : In    natural := 1
    290                                                ) ;
    291                                              
    292                                                alias NoOp is WaitForClock [AddressBusRecType, natural] ;
    293                                              
    294                                                ------------------------------------------------------------
    295                                                procedure GetTransactionCount (
    296                                                -- Get the number of transactions handled by the model.  
    297                                                ------------------------------------------------------------
    298                                                  signal   TransactionRec : InOut AddressBusRecType ;
    299                                                  variable Count          : Out   integer
    300                                                ) ;
    301                                              
    302                                                ------------------------------------------------------------
    303                                                procedure GetWriteTransactionCount (
    304                                                ------------------------------------------------------------
    305                                                  signal   TransactionRec : InOut AddressBusRecType ;
    306                                                  variable Count          : Out   integer
    307                                                ) ;
    308                                              
    309                                                ------------------------------------------------------------
    310                                                procedure GetReadTransactionCount (
    311                                                -- Get the number of read transactions handled by the model.  
    312                                                ------------------------------------------------------------
    313                                                  signal   TransactionRec : InOut AddressBusRecType ;
    314                                                  variable Count          : Out   integer
    315                                                ) ;
    316                                              
    317                                                ------------------------------------------------------------
    318                                                procedure GetAlertLogID (
    319                                                -- Get the AlertLogID from the verification component.
    320                                                ------------------------------------------------------------
    321                                                  signal   TransactionRec : InOut AddressBusRecType ;
    322                                                  variable AlertLogID     : Out   AlertLogIDType
    323                                                ) ;
    324                                              
    325                                                ------------------------------------------------------------
    326                                                procedure GetErrorCount (
    327                                                -- Error reporting for testbenches that do not use OSVVM AlertLogPkg
    328                                                -- Returns error count.  If an error count /= 0, also print errors
    329                                                ------------------------------------------------------------
    330                                                  signal   TransactionRec : InOut AddressBusRecType ;
    331                                                  variable ErrorCount     : Out   natural
    332                                                ) ;
    333                                              
    334                                                alias GetErrors is GetErrorCount [AddressBusRecType, natural] ;
    335                                              
    336                                                -- ========================================================
    337                                                --  Delay Coverage Transactions   
    338                                                --  Get Delay Coverage ID to change delay coverage parameters.
    339                                                -- ========================================================
    340                                                ------------------------------------------------------------
    341                                                procedure SetUseRandomDelays (
    342                                                ------------------------------------------------------------
    343                                                  signal   TransactionRec : InOut AddressBusRecType ;
    344                                                  constant OptVal         : In    boolean := TRUE
    345                                                ) ;
    346                                                
    347                                                ------------------------------------------------------------
    348                                                procedure GetUseRandomDelays (
    349                                                ------------------------------------------------------------
    350                                                  signal   TransactionRec : InOut AddressBusRecType ;
    351                                                  variable OptVal         : Out   boolean
    352                                                ) ;
    353                                              
    354                                                ------------------------------------------------------------
    355                                                procedure SetDelayCoverageID (
    356                                                ------------------------------------------------------------
    357                                                  signal    TransactionRec   : inout AddressBusRecType ;
    358                                                  constant  DelayCov         : in    DelayCoverageIdType ;
    359                                                  constant  Index            : in    integer := 1 
    360                                                ) ;
    361                                              
    362                                                ------------------------------------------------------------
    363                                                procedure GetDelayCoverageID (
    364                                                ------------------------------------------------------------
    365                                                  signal    TransactionRec   : inout AddressBusRecType ;
    366                                                  variable  DelayCov         : out   DelayCoverageIdType ;
    367                                                  constant  Index            : in    integer := 1 
    368                                                ) ;
    369                                              
    370                                                ------------------------------------------------------------
    371                                                procedure SetDelayCoverageID (
    372                                                ------------------------------------------------------------
    373                                                  signal    TransactionRec   : inout AddressBusRecType ;
    374                                                  constant  DelayCov         : in    DelayCoverageIdArrayType 
    375                                                ) ;
    376                                              
    377                                                ------------------------------------------------------------
    378                                                procedure GetDelayCoverageID (
    379                                                ------------------------------------------------------------
    380                                                  signal    TransactionRec   : inout AddressBusRecType ;
    381                                                  variable  DelayCov         : out   DelayCoverageIdArrayType 
    382                                                ) ;
    383                                              
    384                                                -- ========================================================
    385                                                -- BurstFIFOs and Burst Mode Controls
    386                                                -- The burst FIFOs hold bursts of data that is to be sent to 
    387                                                -- or was received from the interface.   The burst FIFO can be 
    388                                                -- configured in the modes defined for StreamFifoBurstModeType.
    389                                                -- Currently these modes defined as a subtype of integer, shown below.
    390                                                -- The intention of using integers is to facilitate model specific 
    391                                                -- extensions without the need to define separate transactions.
    392                                                -- ========================================================
    393                                                subtype AddressBusFifoBurstModeType is integer ;
    394                                                
    395                                                -- Word mode indicates the burst FIFO contains interface words.
    396                                                -- The size of the word may either be interface specific (such as 
    397                                                -- a UART which supports up to 8 bits) or be interface instance specific 
    398                                                -- (such as AxiStream which supports interfaces sizes of 1, 2, 4, 8, 
    399                                                -- 16, ... bytes)
    400                                                constant ADDRESS_BUS_BURST_WORD_MODE       : AddressBusFifoBurstModeType  := 0 ;
    401                                                
    402                                                -- Byte mode indicates that the burst FIFO contains bytes.  
    403                                                -- The verification component assembles interface words from the bytes.
    404                                                -- This allows transfers to be conceptualized in an interface independent 
    405                                                --manner.    
    406                                                constant ADDRESS_BUS_BURST_BYTE_MODE       : AddressBusFifoBurstModeType  := 1 ; 
    407                                                
    408                                                -- ========================================================
    409                                                --  Set and Get Burst Mode   
    410                                                --  Set Burst Mode for models that do bursting.
    411                                                -- ========================================================
    412                                                ------------------------------------------------------------
    413                                                procedure SetBurstMode (
    414                                                ------------------------------------------------------------
    415                                                  signal   TransactionRec : InOut AddressBusRecType ;
    416                                                  constant OptVal         : In    AddressBusFifoBurstModeType
    417                                                ) ;
    418                                              
    419                                                ------------------------------------------------------------
    420                                                procedure GetBurstMode (
    421                                                ------------------------------------------------------------
    422                                                  signal   TransactionRec : InOut AddressBusRecType ;
    423                                                  variable OptVal         : Out   AddressBusFifoBurstModeType
    424                                                ) ;
    425                                              
    426                                                ------------------------------------------------------------
    427                                                function IsAddressBusBurstMode (
    428                                                -----------------------------------------------------------
    429                                                  constant AddressBusFifoBurstMode : In AddressBusFifoBurstModeType
    430                                                ) return boolean ;
    431                                              
    432                                              
    433                                                -- ========================================================
    434                                                --  Set and Get Model Options  
    435                                                --  Model operations are directive transactions that are  
    436                                                --  used to configure the verification component.  
    437                                                --  They can either be used directly or with a model specific
    438                                                --  wrapper around them - see AXI models for examples.
    439                                                -- ========================================================
    440                                                ------------------------------------------------------------
    441                                                procedure SetModelOptions (
    442                                                ------------------------------------------------------------
    443                                                  signal   TransactionRec : InOut AddressBusRecType ;
    444                                                  constant Option         : In    integer ;
    445                                                  constant OptVal         : In    boolean
    446                                                ) ;
    447                                              
    448                                                ------------------------------------------------------------
    449                                                procedure SetModelOptions (
    450                                                ------------------------------------------------------------
    451                                                  signal   TransactionRec : InOut AddressBusRecType ;
    452                                                  constant Option         : In    integer ;
    453                                                  constant OptVal         : In    integer
    454                                                ) ;
    455                                              
    456                                                ------------------------------------------------------------
    457                                                procedure SetModelOptions (
    458                                                ------------------------------------------------------------
    459                                                  signal   TransactionRec : InOut AddressBusRecType ;
    460                                                  constant Option         : In    integer ;
    461                                                  constant OptVal         : In    std_logic_vector
    462                                                ) ;
    463                                                
    464                                                ------------------------------------------------------------
    465                                                procedure SetModelOptions (
    466                                                ------------------------------------------------------------
    467                                                  signal   TransactionRec : InOut AddressBusRecType ;
    468                                                  constant Option         : In    integer ;
    469                                                  constant OptVal         : In    time
    470                                                ) ;
    471                                              
    472                                                ------------------------------------------------------------
    473                                                procedure GetModelOptions (
    474                                                ------------------------------------------------------------
    475                                                  signal   TransactionRec : InOut AddressBusRecType ;
    476                                                  constant Option         : In    integer ;
    477                                                  variable OptVal         : Out   boolean
    478                                                ) ;
    479                                              
    480                                                ------------------------------------------------------------
    481                                                procedure GetModelOptions (
    482                                                ------------------------------------------------------------
    483                                                  signal   TransactionRec : InOut AddressBusRecType ;
    484                                                  constant Option         : In    integer ;
    485                                                  variable OptVal         : Out   integer
    486                                                ) ;
    487                                              
    488                                                ------------------------------------------------------------
    489                                                procedure GetModelOptions (
    490                                                ------------------------------------------------------------
    491                                                  signal   TransactionRec : InOut AddressBusRecType ;
    492                                                  constant Option         : In    integer ;
    493                                                  variable OptVal         : Out   std_logic_vector
    494                                                ) ;
    495                                              
    496                                                ------------------------------------------------------------
    497                                                procedure GetModelOptions (
    498                                                ------------------------------------------------------------
    499                                                  signal   TransactionRec : InOut AddressBusRecType ;
    500                                                  constant Option         : In    integer ;
    501                                                  variable OptVal         : Out   time
    502                                                ) ;
    503                                              
    504                                                ------------------------------------------------------------
    505                                                procedure InterruptReturn (
    506                                                ------------------------------------------------------------
    507                                                  signal   TransactionRec : InOut AddressBusRecType 
    508                                                ) ;
    509                                              
    510                                              
    511                                                -- ========================================================
    512                                                --  Master / Initiator Transactions  
    513                                                -- ========================================================
    514                                                -- ========================================================
    515                                                --  Interface Independent Transactions
    516                                                --  These transactions work independent of the interface.
    517                                                --  Recommended for all tests that verify internal design functionality.
    518                                                --  Many are blocking transactions which do not return (complete)
    519                                                --  until the interface operation requested by the transaction  
    520                                                --  has completed.
    521                                                --  Some are asynchronous, which means they return before the
    522                                                --  transaction is complete - typically even before it starts.
    523                                                --  Supported by all verification components
    524                                                -- ========================================================
    525                                                ------------------------------------------------------------
    526                                                procedure Write (
    527                                                -- Blocking Write Transaction. 
    528                                                ------------------------------------------------------------
    529                                                  signal   TransactionRec : InOut AddressBusRecType ;
    530                                                           iAddr          : In    std_logic_vector ;
    531                                                           iData          : In    std_logic_vector ;
    532                                                           StatusMsgOn    : In    boolean := false
    533                                                ) ;
    534                                              
    535                                                ------------------------------------------------------------
    536                                                procedure WriteAsync (
    537                                                -- Asynchronous / Non-Blocking Write Transaction
    538                                                ------------------------------------------------------------
    539                                                  signal   TransactionRec : InOut AddressBusRecType ;
    540                                                           iAddr          : In    std_logic_vector ;
    541                                                           iData          : In    std_logic_vector ;
    542                                                           StatusMsgOn    : In    boolean := false
    543                                                ) ;
    544                                              
    545                                                ------------------------------------------------------------
    546                                                procedure Read (
    547                                                -- Blocking Read Transaction.
    548                                                ------------------------------------------------------------
    549                                                  signal   TransactionRec : InOut AddressBusRecType ;
    550                                                           iAddr          : In    std_logic_vector ;
    551                                                  variable oData          : Out   std_logic_vector ;
    552                                                           StatusMsgOn    : In    boolean := false
    553                                                ) ;
    554                                              
    555                                                ------------------------------------------------------------
    556                                                procedure ReadCheck (
    557                                                -- Blocking Read Transaction and check iData, rather than returning a value.
    558                                                ------------------------------------------------------------
    559                                                  signal   TransactionRec : InOut AddressBusRecType ;
    560                                                           iAddr          : In    std_logic_vector ;
    561                                                           iData          : In    std_logic_vector ;
    562                                                           StatusMsgOn    : In    boolean := false
    563                                                ) ;
    564                                                
    565                                                ------------------------------------------------------------
    566                                                procedure ReadPoll (
    567                                                -- Read location (iAddr) until Data(IndexI) = ValueI
    568                                                -- WaitTime is the number of clocks to wait between reads.
    569                                                -- oData is the value read.
    570                                                ------------------------------------------------------------
    571                                                  signal   TransactionRec : InOut AddressBusRecType ;
    572                                                           iAddr          : In    std_logic_vector ;
    573                                                  variable oData          : Out   std_logic_vector ;
    574                                                           Index          : In    Integer ;
    575                                                           BitValue       : In    std_logic ;
    576                                                           StatusMsgOn    : In    boolean := false ;
    577                                                           WaitTime       : In    natural := 10
    578                                                ) ;
    579                                              
    580                                                ------------------------------------------------------------
    581                                                procedure ReadPoll (
    582                                                -- Read location (iAddr) until Data(IndexI) = ValueI
    583                                                -- WaitTime is the number of clocks to wait between reads.
    584                                                ------------------------------------------------------------
    585                                                  signal   TransactionRec : InOut AddressBusRecType ;
    586                                                           iAddr          : In    std_logic_vector ;
    587                                                           Index          : In    Integer ;
    588                                                           BitValue       : In    std_logic ;
    589                                                           StatusMsgOn    : In    boolean := false ;
    590                                                           WaitTime       : In    natural := 10
    591                                                ) ;
    592                                                
    593                                                ------------------------------------------------------------
    594                                                procedure WriteAndRead (
    595                                                -- Write and Read Cycle that use same address and are dispatched together
    596                                                ------------------------------------------------------------
    597                                                  signal   TransactionRec : InOut AddressBusRecType ;
    598                                                           iAddr          : In    std_logic_vector ;
    599                                                           iData          : In    std_logic_vector ;
    600                                                  variable oData          : Out   std_logic_vector ;
    601                                                           StatusMsgOn    : In    boolean := false
    602                                                ) ;
    603                                              
    604                                                ------------------------------------------------------------
    605                                                procedure WriteAndReadAsync (
    606                                                -- Dispatch Write Address and Data.  Do not wait for completion
    607                                                -- Dispatch Read Address.  Do not wait for Read Data.  
    608                                                -- Retrieve read data with ReadData or TryReadData
    609                                                ------------------------------------------------------------
    610                                                  signal   TransactionRec : InOut AddressBusRecType ;
    611                                                           iAddr          : In    std_logic_vector ;
    612                                                           iData          : In    std_logic_vector ;
    613                                                           StatusMsgOn    : In    boolean := false
    614                                                ) ;
    615                                                
    616                                                
    617                                                -- ========================================================
    618                                                --  Burst Transactions
    619                                                --  Some interfaces support bursting, and some do not.  
    620                                                --  Hence, support for burst transactions is optional.
    621                                                --  However, for an interface that does not support bursting,  
    622                                                --  it is appropriate to implement a burst as multiple single  
    623                                                --  cycle operations.    
    624                                                -- ========================================================
    625                                                
    626                                                ------------------------------------------------------------
    627                                                procedure WriteBurst (
    628                                                -- Blocking Write Burst.   
    629                                                -- Data is provided separately via a WriteBurstFifo.   
    630                                                -- NumFifoWords specifies the number of items from the FIFO to be transferred.
    631                                                ------------------------------------------------------------
    632                                                  signal   TransactionRec : InOut AddressBusRecType ;
    633                                                           iAddr          : In    std_logic_vector ;
    634                                                           NumFifoWords   : In    integer ;
    635                                                           StatusMsgOn    : In    boolean := false
    636                                                ) ;
    637                                              
    638                                                ------------------------------------------------------------
    639                                                procedure WriteBurstVector (
    640                                                ------------------------------------------------------------
    641                                                  signal   TransactionRec : InOut AddressBusRecType ;
    642                                                           iAddr          : In    std_logic_vector ;
    643                                                           VectorOfWords  : In    slv_vector ;
    644                                                           StatusMsgOn    : In    boolean := false
    645                                                ) ;
    646                                                
    647                                                ------------------------------------------------------------
    648                                                procedure WriteBurstVector (
    649                                                ------------------------------------------------------------
    650                                                  signal   TransactionRec : InOut AddressBusRecType ;
    651                                                           iAddr          : In    std_logic_vector ;
    652                                                           VectorOfWords  : In    integer_vector ;
    653                                                           FifoWidth      : In    integer ; 
    654                                                           StatusMsgOn    : In    boolean := false
    655                                                ) ;
    656                                              
    657                                                ------------------------------------------------------------
    658                                                procedure WriteBurstIncrement (
    659                                                ------------------------------------------------------------
    660                                                  signal   TransactionRec : InOut AddressBusRecType ;
    661                                                           iAddr          : In    std_logic_vector ;
    662                                                           FirstWord      : In    std_logic_vector ;
    663                                                           NumFifoWords   : In    integer ;
    664                                                           StatusMsgOn    : In    boolean := false
    665                                                ) ;
    666                                              
    667                                                ------------------------------------------------------------
    668                                                procedure WriteBurstRandom (
    669                                                ------------------------------------------------------------
    670                                                  signal   TransactionRec : InOut AddressBusRecType ;
    671                                                           iAddr          : In    std_logic_vector ;
    672                                                           FirstWord      : In    std_logic_vector ;
    673                                                           NumFifoWords   : In    integer ;
    674                                                           StatusMsgOn    : In    boolean := false
    675                                                ) ;
    676                                              
    677                                                ------------------------------------------------------------
    678                                                procedure WriteBurstRandom (
    679                                                ------------------------------------------------------------
    680                                                  signal   TransactionRec : InOut AddressBusRecType ;
    681                                                           iAddr          : In    std_logic_vector ;
    682                                                           CoverID        : In    CoverageIDType ;
    683                                                           NumFifoWords   : In    integer ;
    684                                                           FifoWidth      : In    integer ;
    685                                                           StatusMsgOn    : In    boolean := false
    686                                                ) ;
    687                                              
    688                                                ------------------------------------------------------------
    689                                                procedure WriteBurstAsync (
    690                                                -- Asynchronous / Non-Blocking Write Burst.   
    691                                                -- Data is provided separately via a WriteBurstFifo.   
    692                                                -- NumFifoWords specifies the number of bytes to be transferred.
    693                                                ------------------------------------------------------------
    694                                                  signal   TransactionRec : InOut AddressBusRecType ;
    695                                                           iAddr          : In    std_logic_vector ;
    696                                                           NumFifoWords   : In    integer ;
    697                                                           StatusMsgOn    : In    boolean := false
    698                                                ) ;
    699                                                
    700                                              ------------------------------------------------------------
    701                                                procedure WriteBurstVectorAsync (
    702                                                ------------------------------------------------------------
    703                                                  signal   TransactionRec : InOut AddressBusRecType ;
    704                                                           iAddr          : In    std_logic_vector ;
    705                                                           VectorOfWords  : In    slv_vector ;
    706                                                           StatusMsgOn    : In    boolean := false
    707                                                ) ;
    708                                                
    709                                                ------------------------------------------------------------
    710                                                procedure WriteBurstVectorAsync (
    711                                                ------------------------------------------------------------
    712                                                  signal   TransactionRec : InOut AddressBusRecType ;
    713                                                           iAddr          : In    std_logic_vector ;
    714                                                           VectorOfWords  : In    integer_vector ;
    715                                                           FifoWidth      : In    integer ; 
    716                                                           StatusMsgOn    : In    boolean := false
    717                                                ) ;
    718                                              
    719                                                ------------------------------------------------------------
    720                                                procedure WriteBurstIncrementAsync (
    721                                                ------------------------------------------------------------
    722                                                  signal   TransactionRec : InOut AddressBusRecType ;
    723                                                           iAddr          : In    std_logic_vector ;
    724                                                           FirstWord      : In    std_logic_vector ;
    725                                                           NumFifoWords   : In    integer ;
    726                                                           StatusMsgOn    : In    boolean := false
    727                                                ) ;
    728                                              
    729                                                ------------------------------------------------------------
    730                                                procedure WriteBurstRandomAsync (
    731                                                ------------------------------------------------------------
    732                                                  signal   TransactionRec : InOut AddressBusRecType ;
    733                                                           iAddr          : In    std_logic_vector ;
    734                                                           FirstWord      : In    std_logic_vector ;
    735                                                           NumFifoWords   : In    integer ;
    736                                                           StatusMsgOn    : In    boolean := false
    737                                                ) ;
    738                                              
    739                                                ------------------------------------------------------------
    740                                                procedure WriteBurstRandomAsync (
    741                                                ------------------------------------------------------------
    742                                                  signal   TransactionRec : InOut AddressBusRecType ;
    743                                                           iAddr          : In    std_logic_vector ;
    744                                                           CoverID        : In    CoverageIDType ;
    745                                                           NumFifoWords   : In    integer ;
    746                                                           FifoWidth      : In    integer ;
    747                                                           StatusMsgOn    : In    boolean := false
    748                                                ) ;
    749                                              
    750                                                ------------------------------------------------------------
    751                                                procedure ReadBurst (
    752                                                -- Blocking Read Burst.
    753                                                ------------------------------------------------------------
    754                                                  signal   TransactionRec : InOut AddressBusRecType ;
    755                                                           iAddr          : In    std_logic_vector ;
    756                                                           NumFifoWords   : In    integer ;
    757                                                           StatusMsgOn    : In    boolean := false
    758                                                ) ;
    759                                              
    760                                                ------------------------------------------------------------
    761                                                procedure ReadCheckBurstVector (
    762                                                ------------------------------------------------------------
    763                                                  signal   TransactionRec : InOut AddressBusRecType ;
    764                                                           iAddr          : In    std_logic_vector ;
    765                                                           VectorOfWords  : In    slv_vector ;
    766                                                           StatusMsgOn    : In    boolean := false
    767                                                ) ;
    768                                                
    769                                                ------------------------------------------------------------
    770                                                procedure ReadCheckBurstVector (
    771                                                ------------------------------------------------------------
    772                                                  signal   TransactionRec : InOut AddressBusRecType ;
    773                                                           iAddr          : In    std_logic_vector ;
    774                                                           VectorOfWords  : In    integer_vector ;
    775                                                           FifoWidth      : In    integer ; 
    776                                                           StatusMsgOn    : In    boolean := false
    777                                                ) ;
    778                                              
    779                                                ------------------------------------------------------------
    780                                                procedure ReadCheckBurstIncrement (
    781                                                ------------------------------------------------------------
    782                                                  signal   TransactionRec : InOut AddressBusRecType ;
    783                                                           iAddr          : In    std_logic_vector ;
    784                                                           FirstWord      : In    std_logic_vector ;
    785                                                           NumFifoWords   : In    integer ;
    786                                                           StatusMsgOn    : In    boolean := false
    787                                                ) ;
    788                                              
    789                                                ------------------------------------------------------------
    790                                                procedure ReadCheckBurstRandom (
    791                                                ------------------------------------------------------------
    792                                                  signal   TransactionRec : InOut AddressBusRecType ;
    793                                                           iAddr          : In    std_logic_vector ;
    794                                                           FirstWord      : In    std_logic_vector ;
    795                                                           NumFifoWords   : In    integer ;
    796                                                           StatusMsgOn    : In    boolean := false
    797                                                ) ;
    798                                              
    799                                                ------------------------------------------------------------
    800                                                procedure ReadCheckBurstRandom (
    801                                                ------------------------------------------------------------
    802                                                  signal   TransactionRec : InOut AddressBusRecType ;
    803                                                           iAddr          : In    std_logic_vector ;
    804                                                           CoverID        : In    CoverageIDType ;
    805                                                           NumFifoWords   : In    integer ;
    806                                                           FifoWidth      : In    integer ;
    807                                                           StatusMsgOn    : In    boolean := false
    808                                                ) ;
    809                                              
    810                                                -- ========================================================
    811                                                --  Interface Specific Transactions
    812                                                --  Support split transaction interfaces - such as AXI which
    813                                                --  independently operates the write address, write data, 
    814                                                --  write response, read address, and read data interfaces. 
    815                                                --  For split transaction interfaces, these transactions are 
    816                                                --  required to fully test the interface characteristics.  
    817                                                --  Most of these transactions are asynchronous.  
    818                                                -- ========================================================
    819                                              
    820                                                ------------------------------------------------------------
    821                                                procedure WriteAddressAsync (
    822                                                -- Non-blocking Write Address 
    823                                                ------------------------------------------------------------
    824                                                  signal   TransactionRec : InOut AddressBusRecType ;
    825                                                           iAddr          : In    std_logic_vector ;
    826                                                           StatusMsgOn    : In    boolean := false
    827                                                ) ;
    828                                              
    829                                                ------------------------------------------------------------
    830                                                procedure WriteDataAsync (
    831                                                -- Non-blocking Write Data 
    832                                                ------------------------------------------------------------
    833                                                  signal   TransactionRec : InOut AddressBusRecType ;
    834                                                           iAddr          : In    std_logic_vector ;
    835                                                           iData          : In    std_logic_vector ;
    836                                                           StatusMsgOn    : In    boolean := false
    837                                                ) ;
    838                                              
    839                                                ------------------------------------------------------------
    840                                                procedure WriteDataAsync (
    841                                                -- Non-blocking Write Data.  iAddr = 0.  
    842                                                ------------------------------------------------------------
    843                                                  signal   TransactionRec : InOut AddressBusRecType ;
    844                                                           iData          : In    std_logic_vector ;
    845                                                           StatusMsgOn    : In    boolean := false
    846                                                ) ;
    847                                                
    848                                                ------------------------------------------------------------
    849                                                procedure ReadAddressAsync (
    850                                                -- Non-blocking Read Address
    851                                                ------------------------------------------------------------
    852                                                  signal   TransactionRec : InOut AddressBusRecType ;
    853                                                           iAddr          : In    std_logic_vector ;
    854                                                           StatusMsgOn    : In    boolean := false
    855                                                ) ;
    856                                              
    857                                                ------------------------------------------------------------
    858                                                procedure ReadData (
    859                                                -- Blocking Read Data
    860                                                ------------------------------------------------------------
    861                                                  signal   TransactionRec : InOut AddressBusRecType ;
    862                                                  variable oData          : Out   std_logic_vector ;
    863                                                           StatusMsgOn    : In    boolean := false
    864                                                ) ;
    865                                              
    866                                                ------------------------------------------------------------
    867                                                procedure ReadCheckData (
    868                                                -- Blocking Read data and check iData, rather than returning a value.
    869                                                ------------------------------------------------------------
    870                                                  signal   TransactionRec : InOut AddressBusRecType ;
    871                                                           iData          : In    std_logic_vector ;
    872                                                           StatusMsgOn    : In    boolean := false
    873                                                ) ;
    874                                              
    875                                                ------------------------------------------------------------
    876                                                procedure TryReadData (
    877                                                -- Try (non-blocking) read data attempt.   
    878                                                -- If data is available, get it and return available TRUE.
    879                                                -- Otherwise Return Available FALSE.
    880                                                ------------------------------------------------------------
    881                                                  signal   TransactionRec : InOut AddressBusRecType ;
    882                                                  variable oData          : Out   std_logic_vector ;
    883                                                  variable Available      : Out   boolean ;
    884                                                           StatusMsgOn    : In    boolean := false
    885                                                ) ;
    886                                              
    887                                                ------------------------------------------------------------
    888                                                procedure TryReadCheckData (
    889                                                -- Try (non-blocking) read data and check attempt.   
    890                                                -- If data is available, check it and return available TRUE.
    891                                                -- Otherwise Return Available FALSE.
    892                                                ------------------------------------------------------------
    893                                                  signal   TransactionRec : InOut AddressBusRecType ;
    894                                                           iData          : In    std_logic_vector ;
    895                                                  variable Available      : Out   boolean ;
    896                                                           StatusMsgOn    : In    boolean := false
    897                                                ) ;
    898                                              
    899                                                -- ========================================================
    900                                                --  Pseudo Transactions
    901                                                --  Interact with the record only.
    902                                                -- ========================================================
    903                                                ------------------------------------------------------------
    904                                                procedure ReleaseTransactionRecord (
    905                                                --  Must run on same delta cycle as AcquireTransactionRecord
    906                                                ------------------------------------------------------------
    907                                                  signal   TransactionRec : InOut AddressBusRecType 
    908                                                ) ; 
    909                                                
    910                                                ------------------------------------------------------------
    911                                                procedure AcquireTransactionRecord (
    912                                                --  Must run on same delta cycle as ReleaseTransactionRecord
    913                                                ------------------------------------------------------------
    914                                                  signal   TransactionRec : InOut AddressBusRecType 
    915                                                ) ; 
    916                                              
    917                                                -- ========================================================
    918                                                --  Verification Component Support Functions
    919                                                --  These help decode the operation value (AddressBusOperationType)  
    920                                                --  to determine properties about the operation
    921                                                -- ========================================================
    922                                                ------------------------------------------------------------
    923                                                function IsWriteAddress (
    924                                                -- TRUE for a transaction includes write address
    925                                                -----------------------------------------------------------
    926                                                  constant Operation      : In AddressBusOperationType
    927                                                ) return boolean ;
    928                                              
    929                                                ------------------------------------------------------------
    930                                                function IsBlockOnWriteAddress (
    931                                                -- TRUE for blocking transactions that include write address
    932                                                -----------------------------------------------------------
    933                                                  constant Operation      : In AddressBusOperationType
    934                                                ) return boolean ;
    935                                              
    936                                                ------------------------------------------------------------
    937                                                function IsTryWriteAddress (
    938                                                -- TRUE for asynchronous or try transactions that include write address
    939                                                -----------------------------------------------------------
    940                                                  constant Operation      : In AddressBusOperationType
    941                                                ) return boolean ;
    942                                              
    943                                                ------------------------------------------------------------
    944                                                function IsWriteData (
    945                                                -- TRUE for a transaction includes write data
    946                                                -----------------------------------------------------------
    947                                                  constant Operation      : In AddressBusOperationType
    948                                                ) return boolean ;
    949                                              
    950                                                ------------------------------------------------------------
    951                                                function IsBlockOnWriteData (
    952                                                -- TRUE for a blocking transactions that include write data
    953                                                -----------------------------------------------------------
    954                                                  constant Operation      : In AddressBusOperationType
    955                                                ) return boolean ;
    956                                              
    957                                                ------------------------------------------------------------
    958                                                function IsTryWriteData (
    959                                                -- TRUE for asynchronous or try transactions that include write data
    960                                                -----------------------------------------------------------
    961                                                  constant Operation      : In AddressBusOperationType
    962                                                ) return boolean ;
    963                                              
    964                                                ------------------------------------------------------------
    965                                                function IsReadAddress (
    966                                                -- TRUE for a transaction includes read address
    967                                                -----------------------------------------------------------
    968                                                  constant Operation      : In AddressBusOperationType
    969                                                ) return boolean ;
    970                                              
    971                                                ------------------------------------------------------------
    972                                                function IsTryReadAddress (
    973                                                -- TRUE for an asynchronous or try transactions that include read address
    974                                                -----------------------------------------------------------
    975                                                  constant Operation      : In AddressBusOperationType
    976                                                ) return boolean ;
    977                                              
    978                                                ------------------------------------------------------------
    979                                                function IsReadData (
    980                                                -- TRUE for a transaction includes read data
    981                                                -----------------------------------------------------------
    982                                                  constant Operation      : In AddressBusOperationType
    983                                                ) return boolean ;
    984                                              
    985                                                ------------------------------------------------------------
    986                                                function IsBlockOnReadData (
    987                                                -- TRUE for a blocking transactions that include read data
    988                                                -----------------------------------------------------------
    989                                                  constant Operation      : In AddressBusOperationType
    990                                                ) return boolean ;
    991                                              
    992                                                ------------------------------------------------------------
    993                                                function IsTryReadData (
    994                                                -- TRUE for asynchronous or try transactions that include read data
    995                                                -----------------------------------------------------------
    996                                                  constant Operation      : In AddressBusOperationType
    997                                                ) return boolean ;
    998                                              
    999                                                ------------------------------------------------------------
    1000                                               function IsReadCheck (
    1001                                               -- TRUE for a transaction includes check information for read data 
    1002                                               -----------------------------------------------------------
    1003                                                 constant Operation      : In AddressBusOperationType
    1004                                               ) return boolean ;
    1005                                             
    1006                                               ------------------------------------------------------------
    1007                                               function IsBurst (
    1008                                               -- TRUE for a transaction includes read or write burst information
    1009                                               -----------------------------------------------------------
    1010                                                 constant Operation      : In AddressBusOperationType
    1011                                               ) return boolean ;
    1012                                             
    1013                                               ------------------------------------------------------------
    1014                                               function ClassifyUnimplementedOperation (
    1015                                               -----------------------------------------------------------
    1016                                                 constant Operation        : In AddressBusOperationType ;
    1017                                                 constant TransactionCount : in natural
    1018                                               ) return string ;
    1019                                               
    1020                                                ------------------------------------------------------------
    1021                                               function ClassifyUnimplementedOperation (
    1022                                               -----------------------------------------------------------
    1023                                                 constant   TransactionRec : in AddressBusRecType 
    1024                                               ) return string ;
    1025                                              
    1026                                             end package AddressBusTransactionPkg ;
    1027                                             
    1028                                             -- /////////////////////////////////////////////////////////////////////////////////////////
    1029                                             -- /////////////////////////////////////////////////////////////////////////////////////////
    1030                                             
    1031                                             package body AddressBusTransactionPkg is
    1032                                             
    1033                                               function resolved_max ( s : UnresolvedAddressBusOperationVectorType) return UnresolvedAddressBusOperationType is
    1034                                                 variable Result : UnresolvedAddressBusOperationType := NOT_DRIVEN ;
    1035                                               begin
    1036            1                          4         for i in s'range loop 
    1036            2                          4     
    1037                                                   if s(i) /= NOT_DRIVEN then 
    1038                                                     if result = NOT_DRIVEN then 
    1039            1                          3               result := s(i) ;
    1040                                                     else
    1041            1                    ***0***               result := MULTIPLE_DRIVER_DETECT ;
    1042                                                     end if ; 
    1043                                                   end if ; 
    1044            1                          4         end loop ;
    1045            1                          4         return result ; 
    1046                                             --    return maximum(s) ;
    1047                                               end function resolved_max ;
    1048                                             
    1049                                               -- ========================================================
    1050                                               --  Directive Transactions
    1051                                               --  Interact with verification component but not interface.
    1052                                               -- ========================================================
    1053                                               ------------------------------------------------------------
    1054                                               procedure WaitForTransaction (
    1055                                               --  Wait until pending transaction completes
    1056                                               ------------------------------------------------------------
    1057                                                 signal   TransactionRec : InOut AddressBusRecType 
    1058                                               ) is
    1059                                               begin
    1060            1                    ***0***         TransactionRec.Operation     <= WAIT_FOR_TRANSACTION ;
    1061            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    1062                                               end procedure WaitForTransaction ; 
    1063                                             
    1064                                               ------------------------------------------------------------
    1065                                               procedure WaitForWriteTransaction (
    1066                                               --  Wait until pending transaction completes
    1067                                               ------------------------------------------------------------
    1068                                                 signal   TransactionRec : InOut AddressBusRecType 
    1069                                               ) is
    1070                                               begin
    1071            1                    ***0***         TransactionRec.Operation     <= WAIT_FOR_WRITE_TRANSACTION ;
    1072            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    1073                                               end procedure WaitForWriteTransaction ; 
    1074                                             
    1075                                               ------------------------------------------------------------
    1076                                               procedure WaitForReadTransaction (
    1077                                               --  Wait until pending transaction completes
    1078                                               ------------------------------------------------------------
    1079                                                 signal   TransactionRec : InOut AddressBusRecType 
    1080                                               ) is
    1081                                               begin
    1082            1                    ***0***         TransactionRec.Operation     <= WAIT_FOR_READ_TRANSACTION ;
    1083            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    1084                                               end procedure WaitForReadTransaction ; 
    1085                                             
    1086                                               ------------------------------------------------------------
    1087                                               procedure WaitForClock (
    1088                                               -- Directive:  Wait for NumberOfClocks number of clocks in the model
    1089                                               ------------------------------------------------------------
    1090                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1091                                                 constant NumberOfClocks : In    natural := 1
    1092                                               ) is
    1093                                               begin
    1094            1                    ***0***         TransactionRec.Operation     <= WAIT_FOR_CLOCK ;
    1095            1                    ***0***         TransactionRec.IntToModel    <= NumberOfClocks ; 
    1096            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1097                                               end procedure WaitForClock ;
    1098                                             
    1099                                               ------------------------------------------------------------
    1100                                               procedure GetTransactionCount (
    1101                                               ------------------------------------------------------------
    1102                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1103                                                 variable Count          : Out   integer
    1104                                               ) is
    1105                                               begin
    1106            1                    ***0***         TransactionRec.Operation     <= GET_TRANSACTION_COUNT ;
    1107            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1108                                             
    1109                                                 -- Return AlertLogID
    1110            1                    ***0***         Count := TransactionRec.IntFromModel ;
    1111                                             --    Count := integer(TransactionRec.Rdy) ;
    1112                                               end procedure GetTransactionCount ;
    1113                                             
    1114                                               ------------------------------------------------------------
    1115                                               procedure GetWriteTransactionCount (
    1116                                               ------------------------------------------------------------
    1117                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1118                                                 variable Count          : Out   integer
    1119                                               ) is
    1120                                               begin
    1121            1                    ***0***         TransactionRec.Operation     <= GET_WRITE_TRANSACTION_COUNT ;
    1122            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1123                                             
    1124                                                 -- Return AlertLogID
    1125            1                    ***0***         Count := TransactionRec.IntFromModel ;
    1126                                               end procedure GetWriteTransactionCount ;
    1127                                             
    1128                                               ------------------------------------------------------------
    1129                                               procedure GetReadTransactionCount (
    1130                                               ------------------------------------------------------------
    1131                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1132                                                 variable Count          : Out   integer
    1133                                               ) is
    1134                                               begin
    1135            1                    ***0***         TransactionRec.Operation     <= GET_READ_TRANSACTION_COUNT ;
    1136            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1137                                             
    1138                                                 -- Return AlertLogID
    1139            1                    ***0***         Count := TransactionRec.IntFromModel ;
    1140                                               end procedure GetReadTransactionCount ;
    1141                                             
    1142                                               ------------------------------------------------------------
    1143                                               procedure GetAlertLogID (
    1144                                               ------------------------------------------------------------
    1145                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1146                                                 variable AlertLogID     : Out   AlertLogIDType
    1147                                               ) is
    1148                                               begin
    1149            1                    ***0***         TransactionRec.Operation     <= GET_ALERTLOG_ID ;
    1150            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1151                                             
    1152                                                 -- Return AlertLogID
    1153            1                    ***0***         AlertLogID := AlertLogIDType(TransactionRec.IntFromModel) ;
    1154                                               end procedure GetAlertLogID ;
    1155                                             
    1156                                               ------------------------------------------------------------
    1157                                               procedure GetErrorCount (
    1158                                               -- Error reporting for testbenches that do not use AlertLogPkg
    1159                                               -- Returns error count.  If an error count /= 0, also print it
    1160                                               ------------------------------------------------------------
    1161                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1162                                                 variable ErrorCount     : Out   natural
    1163                                               ) is
    1164                                                 variable ModelID : AlertLogIDType ;
    1165                                               begin
    1166            1                    ***0***         GetAlertLogID(TransactionRec, ModelID) ;
    1167                                             --    ReportNonZeroAlerts(AlertLogID => ModelID) ;
    1168            1                    ***0***         ErrorCount := GetAlertCount(AlertLogID => ModelID) ;
    1169                                               end procedure GetErrorCount ;
    1170                                             
    1171                                               -- ========================================================
    1172                                               --  Delay Coverage Transactions   
    1173                                               --  Get Delay Coverage ID to change delay coverage parameters.
    1174                                               -- ========================================================
    1175                                               ------------------------------------------------------------
    1176                                               procedure SetUseRandomDelays (
    1177                                               ------------------------------------------------------------
    1178                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1179                                                 constant OptVal         : In    boolean := TRUE
    1180                                               ) is
    1181                                               begin
    1182            1                    ***0***         TransactionRec.Operation     <= SET_USE_RANDOM_DELAYS ;
    1183            1                    ***0***         TransactionRec.BoolToModel   <= OptVal ;
    1184            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1185                                               end procedure SetUseRandomDelays ;
    1186                                             
    1187                                               ------------------------------------------------------------
    1188                                               procedure GetUseRandomDelays (
    1189                                               ------------------------------------------------------------
    1190                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1191                                                 variable OptVal         : Out   boolean
    1192                                               ) is
    1193                                               begin
    1194            1                    ***0***         TransactionRec.Operation     <= GET_USE_RANDOM_DELAYS ;
    1195            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1196            1                    ***0***         OptVal := TransactionRec.BoolFromModel    ;
    1197                                               end procedure GetUseRandomDelays ;
    1198                                               
    1199                                               ------------------------------------------------------------
    1200                                               procedure SetDelayCoverageID (
    1201                                               ------------------------------------------------------------
    1202                                                 signal    TransactionRec   : inout AddressBusRecType ;
    1203                                                 constant  DelayCov         : in    DelayCoverageIdType ;
    1204                                                 constant  Index            : in    integer := 1 
    1205                                               ) is
    1206                                               begin
    1207            1                    ***0***         TransactionRec.Operation     <= SET_DELAYCOV_ID ;
    1208            1                    ***0***         TransactionRec.IntToModel    <= DelayCov.ID ;
    1209            1                    ***0***         TransactionRec.Options       <= Index ; 
    1210            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1211                                               end procedure SetDelayCoverageID ;
    1212                                             
    1213                                               ------------------------------------------------------------
    1214                                               procedure GetDelayCoverageID (
    1215                                               ------------------------------------------------------------
    1216                                                 signal    TransactionRec   : inout AddressBusRecType ;
    1217                                                 variable  DelayCov         : out   DelayCoverageIdType ;
    1218                                                 constant  Index            : in    integer := 1 
    1219                                               ) is
    1220                                               begin
    1221            1                    ***0***         TransactionRec.Operation     <= GET_DELAYCOV_ID ;
    1222            1                    ***0***         TransactionRec.Options       <= Index ; 
    1223            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1224            1                    ***0***         DelayCov := GetDelayCoverage(TransactionRec.IntFromModel) ; 
    1225                                               end procedure GetDelayCoverageID ;
    1226                                             
    1227                                               ------------------------------------------------------------
    1228                                               procedure SetDelayCoverageID (
    1229                                               ------------------------------------------------------------
    1230                                                 signal    TransactionRec   : inout AddressBusRecType ;
    1231                                                 constant  DelayCov         : in    DelayCoverageIdArrayType 
    1232                                               ) is
    1233                                               begin
    1234            1                    ***0***         for i in DelayCov'range loop
    1234            2                    ***0***     
    1235            1                    ***0***           SetDelayCoverageID(TransactionRec, DelayCov(i), i) ; 
    1236            1                    ***0***         end loop ; 
    1237                                               end procedure SetDelayCoverageID ;
    1238                                             
    1239                                               ------------------------------------------------------------
    1240                                               procedure GetDelayCoverageID (
    1241                                               ------------------------------------------------------------
    1242                                                 signal    TransactionRec   : inout AddressBusRecType ;
    1243                                                 variable  DelayCov         : out   DelayCoverageIdArrayType 
    1244                                               ) is
    1245                                               begin
    1246            1                    ***0***         for i in DelayCov'range loop
    1246            2                    ***0***     
    1247            1                    ***0***           GetDelayCoverageID(TransactionRec, DelayCov(i), i) ; 
    1248            1                    ***0***         end loop ; 
    1249                                               end procedure GetDelayCoverageID ;
    1250                                             
    1251                                               -- ========================================================
    1252                                               --  Set and Get Burst Mode   
    1253                                               --  Set Burst Mode for models that do bursting.
    1254                                               -- ========================================================
    1255                                               ------------------------------------------------------------
    1256                                               procedure SetBurstMode (
    1257                                               ------------------------------------------------------------
    1258                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1259                                                 constant OptVal         : In    AddressBusFifoBurstModeType
    1260                                               ) is
    1261                                               begin
    1262            1                    ***0***         TransactionRec.Operation     <= SET_BURST_MODE ;
    1263            1                    ***0***         TransactionRec.IntToModel    <= OptVal ;
    1264            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1265                                               end procedure SetBurstMode ;
    1266                                             
    1267                                               ------------------------------------------------------------
    1268                                               procedure GetBurstMode (
    1269                                               ------------------------------------------------------------
    1270                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1271                                                 variable OptVal         : Out   AddressBusFifoBurstModeType
    1272                                               ) is
    1273                                               begin
    1274            1                    ***0***         TransactionRec.Operation     <= GET_BURST_MODE ;
    1275            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1276            1                    ***0***         OptVal := TransactionRec.IntFromModel ; 
    1277                                               end procedure GetBurstMode ;
    1278                                             
    1279                                               ------------------------------------------------------------
    1280                                               function IsAddressBusBurstMode (
    1281                                               -----------------------------------------------------------
    1282                                                 constant AddressBusFifoBurstMode : In AddressBusFifoBurstModeType
    1283                                               ) return boolean is
    1284                                               begin
    1285                                                 return
    1286                                                   (AddressBusFifoBurstMode = ADDRESS_BUS_BURST_WORD_MODE) or
    1287            1                    ***0***           (AddressBusFifoBurstMode = ADDRESS_BUS_BURST_BYTE_MODE) ;
    1288                                               end function IsAddressBusBurstMode ;
    1289                                             
    1290                                               --
    1291                                               --  Extensions to support model customizations
    1292                                               -- 
    1293                                               ------------------------------------------------------------
    1294                                               procedure SetModelOptions (
    1295                                               ------------------------------------------------------------
    1296                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1297                                                 constant Option         : In    integer ;
    1298                                                 constant OptVal         : In    boolean
    1299                                               ) is
    1300                                               begin
    1301            1                    ***0***         TransactionRec.Operation     <= SET_MODEL_OPTIONS ;
    1302            1                    ***0***         TransactionRec.Options       <= Option ;
    1303            1                    ***0***         TransactionRec.BoolToModel   <= OptVal ;
    1304            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1305                                               end procedure SetModelOptions ;
    1306                                             
    1307                                               ------------------------------------------------------------
    1308                                               procedure SetModelOptions (
    1309                                               ------------------------------------------------------------
    1310                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1311                                                 constant Option         : In    integer ;
    1312                                                 constant OptVal         : In    integer
    1313                                               ) is
    1314                                               begin
    1315            1                    ***0***         TransactionRec.Operation     <= SET_MODEL_OPTIONS ;
    1316            1                    ***0***         TransactionRec.Options       <= Option ;
    1317            1                    ***0***         TransactionRec.IntToModel    <= OptVal ;
    1318            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1319                                               end procedure SetModelOptions ;
    1320                                             
    1321                                               ------------------------------------------------------------
    1322                                               procedure SetModelOptions (
    1323                                               ------------------------------------------------------------
    1324                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1325                                                 constant Option         : In    integer ;
    1326                                                 constant OptVal         : In    std_logic_vector
    1327                                               ) is
    1328                                               begin
    1329            1                    ***0***         TransactionRec.Operation     <= SET_MODEL_OPTIONS ;
    1330            1                    ***0***         TransactionRec.Options       <= Option ;
    1331            1                    ***0***         TransactionRec.IntToModel    <= to_integer(OptVal) ;
    1332            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1333                                               end procedure SetModelOptions ;
    1334                                             
    1335                                               ------------------------------------------------------------
    1336                                               procedure SetModelOptions (
    1337                                               ------------------------------------------------------------
    1338                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1339                                                 constant Option         : In    integer ;
    1340                                                 constant OptVal         : In    time
    1341                                               ) is
    1342                                               begin
    1343            1                    ***0***         TransactionRec.Operation     <= SET_MODEL_OPTIONS ;
    1344            1                    ***0***         TransactionRec.Options       <= Option ;
    1345            1                    ***0***         TransactionRec.TimeToModel   <= OptVal ;
    1346            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1347                                               end procedure SetModelOptions ;
    1348                                               
    1349                                               ------------------------------------------------------------
    1350                                               procedure GetModelOptions (
    1351                                               ------------------------------------------------------------
    1352                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1353                                                 constant Option         : In    integer ;
    1354                                                 variable OptVal         : Out   boolean
    1355                                               ) is
    1356                                               begin
    1357            1                    ***0***         TransactionRec.Operation     <= GET_MODEL_OPTIONS ;
    1358            1                    ***0***         TransactionRec.Options       <= Option ;
    1359            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1360            1                    ***0***         OptVal := TransactionRec.BoolFromModel    ;
    1361                                               end procedure GetModelOptions ;
    1362                                             
    1363                                               ------------------------------------------------------------
    1364                                               procedure GetModelOptions (
    1365                                               ------------------------------------------------------------
    1366                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1367                                                 constant Option         : In    integer ;
    1368                                                 variable OptVal         : Out   integer
    1369                                               ) is
    1370                                               begin
    1371            1                    ***0***         TransactionRec.Operation     <= GET_MODEL_OPTIONS ;
    1372            1                    ***0***         TransactionRec.Options       <= Option ;
    1373            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1374            1                    ***0***         OptVal := TransactionRec.IntFromModel ; 
    1375                                               end procedure GetModelOptions ;
    1376                                             
    1377                                               ------------------------------------------------------------
    1378                                               procedure GetModelOptions (
    1379                                               ------------------------------------------------------------
    1380                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1381                                                 constant Option         : In    integer ;
    1382                                                 variable OptVal         : Out   std_logic_vector
    1383                                               ) is
    1384                                               begin
    1385            1                    ***0***         TransactionRec.Operation     <= GET_MODEL_OPTIONS ;
    1386            1                    ***0***         TransactionRec.Options       <= Option ;
    1387            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1388            1                    ***0***         OptVal := to_slv(TransactionRec.IntFromModel, OptVal'length) ; 
    1389                                               end procedure GetModelOptions ;
    1390                                             
    1391                                               ------------------------------------------------------------
    1392                                               procedure GetModelOptions (
    1393                                               ------------------------------------------------------------
    1394                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1395                                                 constant Option         : In    integer ;
    1396                                                 variable OptVal         : Out   time
    1397                                               ) is
    1398                                               begin
    1399            1                    ***0***         TransactionRec.Operation     <= GET_MODEL_OPTIONS ;
    1400            1                    ***0***         TransactionRec.Options       <= Option ;
    1401            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1402            1                    ***0***         OptVal := TransactionRec.TimeFromModel ; 
    1403                                               end procedure GetModelOptions ;
    1404                                             
    1405                                               ------------------------------------------------------------
    1406                                               procedure InterruptReturn (
    1407                                               ------------------------------------------------------------
    1408                                                 signal   TransactionRec : InOut AddressBusRecType 
    1409                                               ) is
    1410                                               begin
    1411            1                    ***0***         TransactionRec.Operation     <= INTERRUPT_RETURN ;
    1412            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1413                                               end procedure InterruptReturn ;
    1414                                             
    1415                                               ------------------------------------------------------------
    1416                                               procedure Write (
    1417                                               -- do CPU Write Cycle
    1418                                               ------------------------------------------------------------
    1419                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1420                                                          iAddr          : In    std_logic_vector ;
    1421                                                          iData          : In    std_logic_vector ;
    1422                                                          StatusMsgOn    : In    boolean := false
    1423                                               ) is
    1424                                               begin
    1425                                                 -- Put values in record
    1426            1                          3         TransactionRec.Operation     <= WRITE_OP ;
    1427            1                          3         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1428            1                          3         TransactionRec.AddrWidth     <= iAddr'length ;
    1429            1                          3         TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;
    1430            1                          3         TransactionRec.DataWidth     <= iData'length ;
    1431            1                          3         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1432                                                 -- Start Transaction
    1433            1                          3         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1434                                               end procedure Write ;
    1435                                             
    1436                                               ------------------------------------------------------------
    1437                                               procedure WriteAsync (
    1438                                               -- dispatch CPU Write Cycle
    1439                                               ------------------------------------------------------------
    1440                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1441                                                          iAddr          : In    std_logic_vector ;
    1442                                                          iData          : In    std_logic_vector ;
    1443                                                          StatusMsgOn    : In    boolean := false
    1444                                               ) is
    1445                                               begin
    1446                                                 -- Put values in record
    1447            1                    ***0***         TransactionRec.Operation     <= ASYNC_WRITE ;
    1448            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1449            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1450            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;
    1451            1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    1452            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1453                                                 -- Start Transaction
    1454            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1455                                               end procedure WriteAsync ;
    1456                                             
    1457                                               ------------------------------------------------------------
    1458                                               procedure WriteAddressAsync (
    1459                                               -- dispatch CPU Write Address Cycle
    1460                                               ------------------------------------------------------------
    1461                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1462                                                          iAddr          : In    std_logic_vector ;
    1463                                                          StatusMsgOn    : In    boolean := false
    1464                                               ) is
    1465                                               begin
    1466                                                 -- Put values in record
    1467            1                    ***0***         TransactionRec.Operation     <= ASYNC_WRITE_ADDRESS ;
    1468            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1469            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1470            1                    ***0***         TransactionRec.DataWidth     <= 0 ;
    1471            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1472                                                 -- Start Transaction
    1473            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1474                                               end procedure WriteAddressAsync ;
    1475                                             
    1476                                               ------------------------------------------------------------
    1477                                               procedure WriteDataAsync (
    1478                                               -- dispatch CPU Write Data Cycle
    1479                                               ------------------------------------------------------------
    1480                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1481                                                          iAddr          : In    std_logic_vector ;
    1482                                                          iData          : In    std_logic_vector ;
    1483                                                          StatusMsgOn    : In    boolean := false
    1484                                               ) is
    1485                                               begin
    1486                                                 -- Put values in record
    1487            1                    ***0***         TransactionRec.Operation     <= ASYNC_WRITE_DATA ;
    1488            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1489            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1490            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;
    1491            1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    1492            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1493                                                 -- Start Transaction
    1494            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1495                                               end procedure WriteDataAsync ;
    1496                                               
    1497                                               ------------------------------------------------------------
    1498                                               procedure WriteDataAsync (
    1499                                               ------------------------------------------------------------
    1500                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1501                                                          iData          : In    std_logic_vector ;
    1502                                                          StatusMsgOn    : In    boolean := false
    1503                                               ) is
    1504                                               begin
    1505            1                    ***0***         WriteDataAsync(TransactionRec, X"00", iData, StatusMsgOn) ;
    1506                                               end procedure WriteDataAsync ;
    1507                                             
    1508                                               ------------------------------------------------------------
    1509                                               procedure Read (
    1510                                               -- do CPU Read Cycle and return data
    1511                                               ------------------------------------------------------------
    1512                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1513                                                          iAddr          : In    std_logic_vector ;
    1514                                                 variable oData          : Out   std_logic_vector ;
    1515                                                          StatusMsgOn    : In    boolean := false
    1516                                               ) is
    1517                                               begin
    1518                                                 -- Put values in record
    1519            1                          2         TransactionRec.Operation     <= READ_OP ;
    1520            1                          2         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1521            1                          2         TransactionRec.AddrWidth     <= iAddr'length ;
    1522            1                          2         TransactionRec.DataWidth     <= oData'length ;
    1523            1                          2         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1524                                                 -- Start Transaction
    1525            1                          2         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1526                                                 -- Return Results
    1527            1                          2         oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ;
    1528                                               end procedure Read ;
    1529                                             
    1530                                               ------------------------------------------------------------
    1531                                               procedure ReadCheck (
    1532                                               -- do CPU Read Cycle and check supplied data
    1533                                               ------------------------------------------------------------
    1534                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1535                                                          iAddr          : In    std_logic_vector ;
    1536                                                          iData          : In    std_logic_vector ;
    1537                                                          StatusMsgOn    : In    boolean := false
    1538                                               ) is
    1539                                               begin
    1540                                                 -- Put values in record
    1541            1                    ***0***         TransactionRec.Operation     <= READ_CHECK ;
    1542            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1543            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1544            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;
    1545            1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    1546            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1547                                                 -- Start Transaction
    1548            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1549                                               end procedure ReadCheck ;
    1550                                             
    1551                                               ------------------------------------------------------------
    1552                                               procedure ReadAddressAsync (
    1553                                               -- dispatch CPU Read Address Cycle
    1554                                               ------------------------------------------------------------
    1555                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1556                                                          iAddr          : In    std_logic_vector ;
    1557                                                          StatusMsgOn    : In    boolean := false
    1558                                               ) is
    1559                                               begin
    1560                                                 -- Put values in record
    1561            1                    ***0***         TransactionRec.Operation     <= ASYNC_READ_ADDRESS ;
    1562            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1563            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1564            1                    ***0***         TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'X') ;
    1565            1                    ***0***         TransactionRec.DataWidth     <= 0 ;
    1566            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1567                                                 -- Start Transaction
    1568            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1569                                               end procedure ReadAddressAsync ;
    1570                                             
    1571                                               ------------------------------------------------------------
    1572                                               procedure ReadData (
    1573                                               -- Do CPU Read Data Cycle
    1574                                               ------------------------------------------------------------
    1575                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1576                                                 variable oData          : Out   std_logic_vector ;
    1577                                                          StatusMsgOn    : In    boolean := false
    1578                                               ) is
    1579                                               begin
    1580                                                 -- Put values in record
    1581            1                    ***0***         TransactionRec.Operation     <= READ_DATA ;
    1582            1                    ***0***         TransactionRec.Address       <= (TransactionRec.Address'range => 'X') ;
    1583            1                    ***0***         TransactionRec.DataWidth     <= oData'length ;
    1584            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1585                                                 -- Start Transaction
    1586            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1587                                                 -- Return Results
    1588            1                    ***0***         oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ;
    1589                                               end procedure ReadData ;
    1590                                             
    1591                                               ------------------------------------------------------------
    1592                                               procedure ReadCheckData (
    1593                                               -- Do CPU Read Data Cycle and check received Data
    1594                                               ------------------------------------------------------------
    1595                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1596                                                          iData          : In    std_logic_vector ;
    1597                                                          StatusMsgOn    : In    boolean := false
    1598                                               ) is
    1599                                               begin
    1600                                                 -- Put values in record
    1601            1                    ***0***         TransactionRec.Operation     <= READ_DATA_CHECK ;
    1602            1                    ***0***         TransactionRec.Address       <= (TransactionRec.Address'range => 'X') ;
    1603            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;
    1604            1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    1605            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1606                                                 -- Start Transaction
    1607            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1608                                               end procedure ReadCheckData ;
    1609                                             
    1610                                               ------------------------------------------------------------
    1611                                               procedure TryReadData (
    1612                                               -- Try to Get CPU Read Data Cycle
    1613                                               -- If data is available, get it and return available TRUE.
    1614                                               -- Otherwise Return Available FALSE.
    1615                                               ------------------------------------------------------------
    1616                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1617                                                 variable oData          : Out   std_logic_vector ;
    1618                                                 variable Available      : Out   boolean ;
    1619                                                          StatusMsgOn    : In    boolean := false
    1620                                               ) is
    1621                                               begin
    1622                                                 -- Put values in record
    1623            1                    ***0***         TransactionRec.Operation     <= ASYNC_READ_DATA ;
    1624            1                    ***0***         TransactionRec.Address       <= (TransactionRec.Address'range => 'X') ;
    1625            1                    ***0***         TransactionRec.DataWidth     <= oData'length ;
    1626            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1627                                                 -- Start Transaction
    1628            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1629                                                 -- Return Results
    1630            1                    ***0***         oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ;
    1631            1                    ***0***         Available := TransactionRec.BoolFromModel ;
    1632                                               end procedure TryReadData ;
    1633                                             
    1634                                               ------------------------------------------------------------
    1635                                               procedure TryReadCheckData (
    1636                                               -- Try to Get CPU Read Data Cycle
    1637                                               -- If data is available, check it and return available TRUE.
    1638                                               -- Otherwise Return Available FALSE.
    1639                                               ------------------------------------------------------------
    1640                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1641                                                          iData          : In    std_logic_vector ;
    1642                                                 variable Available      : Out   boolean ;
    1643                                                          StatusMsgOn    : In    boolean := false
    1644                                               ) is
    1645                                               begin
    1646                                                 -- Put values in record
    1647            1                    ***0***         TransactionRec.Operation     <= ASYNC_READ_DATA_CHECK ;
    1648            1                    ***0***         TransactionRec.Address       <= (TransactionRec.Address'range => 'X') ;
    1649            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;
    1650            1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    1651            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1652                                                 -- Start Transaction
    1653            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1654            1                    ***0***         Available := TransactionRec.BoolFromModel ;
    1655                                               end procedure TryReadCheckData ;
    1656                                             
    1657                                               ------------------------------------------------------------
    1658                                               procedure ReadPoll (
    1659                                               -- Read location (iAddr) until Data(IndexI) = ValueI
    1660                                               ------------------------------------------------------------
    1661                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1662                                                          iAddr          : In    std_logic_vector ;
    1663                                                 variable oData          : Out   std_logic_vector ;
    1664                                                          Index          : In    Integer ;
    1665                                                          BitValue       : In    std_logic ;
    1666                                                          StatusMsgOn    : In    boolean := false ;
    1667                                                          WaitTime       : In    natural := 10
    1668                                               ) is
    1669                                                 variable vData    : std_logic_vector(oData'length-1 downto 0) ;
    1670                                                 variable ModelID  : AlertLogIDType ;
    1671                                               begin
    1672            1                    ***0***         loop
    1673            1                    ***0***           WaitForClock(TransactionRec, WaitTime) ;
    1674            1                    ***0***           Read (TransactionRec, iAddr, vData) ;
    1675            1                    ***0***           exit when vData(Index) = BitValue ;
    1676            1                    ***0***         end loop ;
    1677                                             
    1678            1                    ***0***         GetAlertLogID(TransactionRec, ModelID) ;
    1679                                                 Log(ModelID, "CpuPoll: address" & to_hstring(iAddr) &
    1680            1                    ***0***           "  Data: " & to_hstring(vData), INFO, StatusMsgOn) ;
    1681            1                    ***0***         oData := vData ;
    1682                                               end procedure ReadPoll ;
    1683                                             
    1684                                               ------------------------------------------------------------
    1685                                               procedure ReadPoll (
    1686                                               -- Read location (iAddr) until Data(IndexI) = ValueI
    1687                                               ------------------------------------------------------------
    1688                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1689                                                          iAddr          : In    std_logic_vector ;
    1690                                                          Index          : In    Integer ;
    1691                                                          BitValue       : In    std_logic ;
    1692                                                          StatusMsgOn    : In    boolean := false ;
    1693                                                          WaitTime       : In    natural := 10
    1694                                               ) is
    1695                                                 variable vData    : std_logic_vector(TransactionRec.DataFromModel'range) ;
    1696                                               begin
    1697            1                    ***0***         ReadPoll(TransactionRec, iAddr, vData, Index, BitValue, StatusMsgOn, WaitTime) ;
    1698                                               end procedure ReadPoll ;
    1699                                             
    1700                                               ------------------------------------------------------------
    1701                                               procedure WriteAndRead (
    1702                                               -- Write and Read Cycle that use same address and are dispatched together
    1703                                               ------------------------------------------------------------
    1704                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1705                                                          iAddr          : In    std_logic_vector ;
    1706                                                          iData          : In    std_logic_vector ;
    1707                                                 variable oData          : Out   std_logic_vector ;
    1708                                                          StatusMsgOn    : In    boolean := false
    1709                                               ) is
    1710                                               begin
    1711                                                 -- Put values in record
    1712            1                    ***0***         TransactionRec.Operation     <= WRITE_AND_READ ;
    1713            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1714            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1715            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;
    1716            1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    1717            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1718                                                 -- Start Transaction
    1719            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1720                                                 -- Return Results
    1721            1                    ***0***         oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ;  
    1722                                               end procedure WriteAndRead ;
    1723                                             
    1724                                               ------------------------------------------------------------
    1725                                               procedure WriteAndReadAsync (
    1726                                               -- Dispatch Write Address and Data.  Do not wait for completion
    1727                                               -- Dispatch Read Address.  Do not wait for Read Data.  
    1728                                               -- Retrieve read data with ReadData or TryReadData
    1729                                               ------------------------------------------------------------
    1730                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1731                                                          iAddr          : In    std_logic_vector ;
    1732                                                          iData          : In    std_logic_vector ;
    1733                                                          StatusMsgOn    : In    boolean := false
    1734                                               ) is
    1735                                               begin
    1736                                                 -- Put values in record
    1737            1                    ***0***         TransactionRec.Operation     <= ASYNC_WRITE_AND_READ ;
    1738            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1739            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1740            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;
    1741            1                    ***0***         TransactionRec.DataWidth     <= iData'length ;
    1742            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1743                                                 -- Start Transaction
    1744            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1745                                               end procedure WriteAndReadAsync ;
    1746                                               
    1747                                               -- ========================================================
    1748                                               --  Burst Transactions
    1749                                               -- ========================================================
    1750                                             
    1751                                               ------------------------------------------------------------
    1752                                               procedure WriteBurst (
    1753                                               -- do CPU Write Cycle
    1754                                               ------------------------------------------------------------
    1755                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1756                                                          iAddr          : In    std_logic_vector ;
    1757                                                          NumFifoWords   : In    integer ;
    1758                                                          StatusMsgOn    : In    boolean := false
    1759                                               ) is
    1760                                               begin
    1761                                                 -- Put values in record
    1762            1                    ***0***         TransactionRec.Operation     <= WRITE_BURST ;
    1763            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1764            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1765                                             --    TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'X') ;
    1766            1                    ***0***         TransactionRec.DataWidth     <= NumFifoWords ;
    1767            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1768                                                 -- Start Transaction
    1769            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1770                                               end procedure WriteBurst ;
    1771                                               
    1772                                               ------------------------------------------------------------
    1773                                               procedure WriteBurstVector (
    1774                                               ------------------------------------------------------------
    1775                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1776                                                          iAddr          : In    std_logic_vector ;
    1777                                                          VectorOfWords  : In    slv_vector ;
    1778                                                          StatusMsgOn    : In    boolean := false
    1779                                               ) is
    1780                                               begin
    1781            1                    ***0***         PushBurstVector(TransactionRec.WriteBurstFifo, VectorOfWords) ; 
    1782            1                    ***0***         WriteBurst(TransactionRec, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1783                                               end procedure WriteBurstVector ;
    1784                                               
    1785                                               ------------------------------------------------------------
    1786                                               procedure WriteBurstVector (
    1787                                               ------------------------------------------------------------
    1788                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1789                                                          iAddr          : In    std_logic_vector ;
    1790                                                          VectorOfWords  : In    integer_vector ;
    1791                                                          FifoWidth      : In    integer ; 
    1792                                                          StatusMsgOn    : In    boolean := false
    1793                                               ) is
    1794                                               begin
    1795            1                    ***0***         PushBurstVector(TransactionRec.WriteBurstFifo, VectorOfWords, FifoWidth) ;
    1796            1                    ***0***         WriteBurst(TransactionRec, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1797                                               end procedure WriteBurstVector ;
    1798                                               
    1799                                               ------------------------------------------------------------
    1800                                               procedure WriteBurstIncrement (
    1801                                               ------------------------------------------------------------
    1802                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1803                                                          iAddr          : In    std_logic_vector ;
    1804                                                          FirstWord      : In    std_logic_vector ;
    1805                                                          NumFifoWords   : In    integer ;
    1806                                                          StatusMsgOn    : In    boolean := false
    1807                                               ) is
    1808                                               begin
    1809            1                    ***0***         PushBurstIncrement(TransactionRec.WriteBurstFifo, FirstWord, NumFifoWords) ; 
    1810            1                    ***0***         WriteBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; 
    1811                                               end procedure WriteBurstIncrement ;
    1812                                             
    1813                                               ------------------------------------------------------------
    1814                                               procedure WriteBurstRandom (
    1815                                               ------------------------------------------------------------
    1816                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1817                                                          iAddr          : In    std_logic_vector ;
    1818                                                          FirstWord      : In    std_logic_vector ;
    1819                                                          NumFifoWords   : In    integer ;
    1820                                                          StatusMsgOn    : In    boolean := false
    1821                                               ) is
    1822                                               begin
    1823            1                    ***0***         PushBurstRandom(TransactionRec.WriteBurstFifo, FirstWord, NumFifoWords) ; 
    1824            1                    ***0***         WriteBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; 
    1825                                               end procedure WriteBurstRandom ;
    1826                                             
    1827                                               ------------------------------------------------------------
    1828                                               procedure WriteBurstRandom (
    1829                                               ------------------------------------------------------------
    1830                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1831                                                          iAddr          : In    std_logic_vector ;
    1832                                                          CoverID        : In    CoverageIDType ;
    1833                                                          NumFifoWords   : In    integer ;
    1834                                                          FifoWidth      : In    integer ;
    1835                                                          StatusMsgOn    : In    boolean := false
    1836                                               ) is
    1837                                               begin
    1838            1                    ***0***         PushBurstRandom(TransactionRec.WriteBurstFifo, CoverID, NumFifoWords, FifoWidth) ; 
    1839            1                    ***0***         WriteBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; 
    1840                                               end procedure WriteBurstRandom ;
    1841                                             
    1842                                               ------------------------------------------------------------
    1843                                               procedure WriteBurstAsync (
    1844                                               -- dispatch CPU Write Cycle
    1845                                               ------------------------------------------------------------
    1846                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1847                                                          iAddr          : In    std_logic_vector ;
    1848                                                          NumFifoWords   : In    integer ;
    1849                                                          StatusMsgOn    : In    boolean := false
    1850                                               ) is
    1851                                               begin
    1852                                                 -- Put values in record
    1853            1                    ***0***         TransactionRec.Operation     <= ASYNC_WRITE_BURST ;
    1854            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1855            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1856                                             --    TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'X') ;
    1857            1                    ***0***         TransactionRec.DataWidth     <= NumFifoWords ;
    1858            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1859                                                 -- Start Transaction
    1860            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1861                                               end procedure WriteBurstAsync ;
    1862                                               
    1863                                               ------------------------------------------------------------
    1864                                               procedure WriteBurstVectorAsync (
    1865                                               ------------------------------------------------------------
    1866                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1867                                                          iAddr          : In    std_logic_vector ;
    1868                                                          VectorOfWords  : In    slv_vector ;
    1869                                                          StatusMsgOn    : In    boolean := false
    1870                                               ) is
    1871                                               begin
    1872            1                    ***0***         PushBurstVector(TransactionRec.WriteBurstFifo, VectorOfWords) ; 
    1873            1                    ***0***         WriteBurstAsync(TransactionRec, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1874                                               end procedure WriteBurstVectorAsync ;
    1875                                               
    1876                                               ------------------------------------------------------------
    1877                                               procedure WriteBurstVectorAsync (
    1878                                               ------------------------------------------------------------
    1879                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1880                                                          iAddr          : In    std_logic_vector ;
    1881                                                          VectorOfWords  : In    integer_vector ;
    1882                                                          FifoWidth      : In    integer ; 
    1883                                                          StatusMsgOn    : In    boolean := false
    1884                                               ) is
    1885                                               begin
    1886            1                    ***0***         PushBurstVector(TransactionRec.WriteBurstFifo, VectorOfWords, FifoWidth) ; 
    1887            1                    ***0***         WriteBurstAsync(TransactionRec, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1888                                               end procedure WriteBurstVectorAsync ;
    1889                                               
    1890                                               ------------------------------------------------------------
    1891                                               procedure WriteBurstIncrementAsync (
    1892                                               ------------------------------------------------------------
    1893                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1894                                                          iAddr          : In    std_logic_vector ;
    1895                                                          FirstWord      : In    std_logic_vector ;
    1896                                                          NumFifoWords   : In    integer ;
    1897                                                          StatusMsgOn    : In    boolean := false
    1898                                               ) is
    1899                                               begin
    1900            1                    ***0***         PushBurstIncrement(TransactionRec.WriteBurstFifo, FirstWord, NumFifoWords) ; 
    1901            1                    ***0***         WriteBurstAsync(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; 
    1902                                               end procedure WriteBurstIncrementAsync ;
    1903                                             
    1904                                               ------------------------------------------------------------
    1905                                               procedure WriteBurstRandomAsync (
    1906                                               ------------------------------------------------------------
    1907                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1908                                                          iAddr          : In    std_logic_vector ;
    1909                                                          FirstWord      : In    std_logic_vector ;
    1910                                                          NumFifoWords   : In    integer ;
    1911                                                          StatusMsgOn    : In    boolean := false
    1912                                               ) is
    1913                                               begin
    1914            1                    ***0***         PushBurstRandom(TransactionRec.WriteBurstFifo, FirstWord, NumFifoWords) ; 
    1915            1                    ***0***         WriteBurstAsync(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; 
    1916                                               end procedure WriteBurstRandomAsync ;  
    1917                                               
    1918                                               ------------------------------------------------------------
    1919                                               procedure WriteBurstRandomAsync (
    1920                                               ------------------------------------------------------------
    1921                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1922                                                          iAddr          : In    std_logic_vector ;
    1923                                                          CoverID        : In    CoverageIDType ;
    1924                                                          NumFifoWords   : In    integer ;
    1925                                                          FifoWidth      : In    integer ;
    1926                                                          StatusMsgOn    : In    boolean := false
    1927                                               ) is
    1928                                               begin
    1929            1                    ***0***         PushBurstRandom(TransactionRec.WriteBurstFifo, CoverID, NumFifoWords, FifoWidth) ; 
    1930            1                    ***0***         WriteBurstAsync(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; 
    1931                                               end procedure WriteBurstRandomAsync ;
    1932                                             
    1933                                               ------------------------------------------------------------
    1934                                               procedure ReadBurst (
    1935                                               -- do CPU Read Cycle and return data
    1936                                               ------------------------------------------------------------
    1937                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1938                                                          iAddr          : In    std_logic_vector ;
    1939                                                          NumFifoWords   : In    integer ;
    1940                                                          StatusMsgOn    : In    boolean := false
    1941                                               ) is
    1942                                               begin
    1943                                                 -- Put values in record
    1944            1                    ***0***         TransactionRec.Operation     <= READ_BURST ;
    1945            1                    ***0***         TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;
    1946            1                    ***0***         TransactionRec.AddrWidth     <= iAddr'length ;
    1947            1                    ***0***         TransactionRec.DataWidth     <= NumFifoWords ;
    1948                                             --??    TransactionRec.DataWidth     <= 0 ;
    1949            1                    ***0***         TransactionRec.StatusMsgOn   <= StatusMsgOn ;
    1950                                                 -- Start Transaction
    1951            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1952                                             --??    -- Return Results
    1953                                             --??    NumFifoWords := TransactionRec.IntFromModel ;
    1954                                               end procedure ReadBurst ;
    1955                                               
    1956                                               ------------------------------------------------------------
    1957                                               procedure ReadCheckBurstVector (
    1958                                               ------------------------------------------------------------
    1959                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1960                                                          iAddr          : In    std_logic_vector ;
    1961                                                          VectorOfWords  : In    slv_vector ;
    1962                                                          StatusMsgOn    : In    boolean := false
    1963                                               ) is
    1964                                               begin
    1965            1                    ***0***         ReadBurst(TransactionRec, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1966            1                    ***0***         CheckBurstVector(TransactionRec.ReadBurstFifo, VectorOfWords) ;
    1967                                               end procedure ReadCheckBurstVector ;
    1968                                               
    1969                                               ------------------------------------------------------------
    1970                                               procedure ReadCheckBurstVector (
    1971                                               ------------------------------------------------------------
    1972                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1973                                                          iAddr          : In    std_logic_vector ;
    1974                                                          VectorOfWords  : In    integer_vector ;
    1975                                                          FifoWidth      : In    integer ; 
    1976                                                          StatusMsgOn    : In    boolean := false
    1977                                               ) is
    1978                                               begin
    1979            1                    ***0***         ReadBurst(TransactionRec, iAddr, VectorOfWords'length, StatusMsgOn) ; 
    1980            1                    ***0***         CheckBurstVector(TransactionRec.ReadBurstFifo, VectorOfWords, FifoWidth) ;
    1981                                               end procedure ReadCheckBurstVector ;
    1982                                               
    1983                                               ------------------------------------------------------------
    1984                                               procedure ReadCheckBurstIncrement (
    1985                                               ------------------------------------------------------------
    1986                                                 signal   TransactionRec : InOut AddressBusRecType ;
    1987                                                          iAddr          : In    std_logic_vector ;
    1988                                                          FirstWord      : In    std_logic_vector ;
    1989                                                          NumFifoWords   : In    integer ;
    1990                                                          StatusMsgOn    : In    boolean := false
    1991                                               ) is
    1992                                               begin
    1993            1                    ***0***         ReadBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; 
    1994            1                    ***0***         CheckBurstIncrement(TransactionRec.ReadBurstFifo, FirstWord, NumFifoWords) ; 
    1995                                               end procedure ReadCheckBurstIncrement ;
    1996                                             
    1997                                               ------------------------------------------------------------
    1998                                               procedure ReadCheckBurstRandom (
    1999                                               ------------------------------------------------------------
    2000                                                 signal   TransactionRec : InOut AddressBusRecType ;
    2001                                                          iAddr          : In    std_logic_vector ;
    2002                                                          FirstWord      : In    std_logic_vector ;
    2003                                                          NumFifoWords   : In    integer ;
    2004                                                          StatusMsgOn    : In    boolean := false
    2005                                               ) is
    2006                                               begin
    2007            1                    ***0***         ReadBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; 
    2008            1                    ***0***         CheckBurstRandom(TransactionRec.ReadBurstFifo, FirstWord, NumFifoWords) ; 
    2009                                               end procedure ReadCheckBurstRandom ;
    2010                                             
    2011                                               ------------------------------------------------------------
    2012                                               procedure ReadCheckBurstRandom (
    2013                                               ------------------------------------------------------------
    2014                                                 signal   TransactionRec : InOut AddressBusRecType ;
    2015                                                          iAddr          : In    std_logic_vector ;
    2016                                                          CoverID        : In    CoverageIDType ;
    2017                                                          NumFifoWords   : In    integer ;
    2018                                                          FifoWidth      : In    integer ;
    2019                                                          StatusMsgOn    : In    boolean := false
    2020                                               ) is
    2021                                               begin
    2022            1                    ***0***         ReadBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; 
    2023            1                    ***0***         CheckBurstRandom(TransactionRec.ReadBurstFifo, CoverID, NumFifoWords, FifoWidth) ; 
    2024                                               end procedure ReadCheckBurstRandom ;
    2025                                             
    2026                                               -- ========================================================
    2027                                               --  Pseudo Transactions
    2028                                               --  Interact with the record only.
    2029                                               -- ========================================================
    2030                                               ------------------------------------------------------------
    2031                                               procedure ReleaseTransactionRecord (
    2032                                               --  Must run on same delta cycle as AcquireTransactionRecord
    2033                                               ------------------------------------------------------------
    2034                                                 signal   TransactionRec : InOut AddressBusRecType 
    2035                                               ) is
    2036                                               begin
    2037                                                 -- Set everything driven by TestCtrl to type'left (except Rdy)
    2038            1                    ***0***         TransactionRec.Rdy           <= RdyType'left ;   
    2039            1                    ***0***         TransactionRec.Operation     <= NOT_DRIVEN ;
    2040            1                    ***0***         TransactionRec.Address       <= (TransactionRec.Address'range => 'U') ;
    2041            1                    ***0***         TransactionRec.AddrWidth     <= integer'left ; 
    2042            1                    ***0***         TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'U') ;
    2043            1                    ***0***         TransactionRec.DataWidth     <= integer'left ; 
    2044            1                    ***0***         TransactionRec.StatusMsgOn   <= boolean'left ; 
    2045            1                    ***0***         TransactionRec.IntToModel    <= integer'left ; 
    2046            1                    ***0***         TransactionRec.BoolToModel   <= boolean'left ;  
    2047            1                    ***0***         TransactionRec.Options       <= integer'left ;    
    2048                                               end procedure ReleaseTransactionRecord ; 
    2049                                               
    2050                                               ------------------------------------------------------------
    2051                                               procedure AcquireTransactionRecord (
    2052                                               --  Must run on same delta cycle as ReleaseTransactionRecord
    2053                                               ------------------------------------------------------------
    2054                                                 signal   TransactionRec : InOut AddressBusRecType 
    2055                                               ) is
    2056                                               begin
    2057                                                 -- Start Driving Rdy on next delta cycle with the current value.  
    2058            1                    ***0***         TransactionRec.Rdy           <= TransactionRec.Rdy ; 
    2059                                               end procedure AcquireTransactionRecord ; 
    2060                                                 
    2061                                             
    2062                                               -- ========================================================
    2063                                               --  Verification Component Support
    2064                                               -- ========================================================
    2065                                               ------------------------------------------------------------
    2066                                               function IsWriteAddress (
    2067                                               -----------------------------------------------------------
    2068                                                 constant Operation      : In AddressBusOperationType
    2069                                               ) return boolean is
    2070                                               begin
    2071                                                 return
    2072                                                   (Operation = WRITE_OP) 
    2073                                                   or (Operation = WRITE_ADDRESS) 
    2074                                                   or (Operation = ASYNC_WRITE) 
    2075                                                   or (Operation = ASYNC_WRITE_ADDRESS)  
    2076                                                   or (Operation = WRITE_BURST) 
    2077            1                    ***0***           or (Operation = ASYNC_WRITE_BURST) ; 
    2078                                             --    or (Operation = WRITE_BURST_ADDRESS)  
    2079                                             --    or  (Operation = ASYNC_WRITE_BURST_ADDRESS) ;
    2080                                               end function IsWriteAddress ;
    2081                                             
    2082                                               ------------------------------------------------------------
    2083                                               function IsBlockOnWriteAddress (
    2084                                               -----------------------------------------------------------
    2085                                                 constant Operation      : In AddressBusOperationType
    2086                                               ) return boolean is
    2087                                               begin
    2088                                                 return
    2089                                                   (Operation = WRITE_OP) 
    2090                                                   or (Operation = WRITE_ADDRESS) 
    2091            1                    ***0***           or (Operation = WRITE_BURST) ; 
    2092                                             --      (Operation = WRITE_BURST_ADDRESS) ;
    2093                                               end function IsBlockOnWriteAddress ;
    2094                                             
    2095                                               ------------------------------------------------------------
    2096                                               function IsTryWriteAddress (
    2097                                               -----------------------------------------------------------
    2098                                                 constant Operation      : In AddressBusOperationType
    2099                                               ) return boolean is
    2100                                               begin
    2101                                                 return
    2102                                                   (Operation = ASYNC_WRITE) 
    2103                                                   or (Operation = ASYNC_WRITE_ADDRESS)  
    2104            1                    ***0***           or (Operation = ASYNC_WRITE_BURST) ; 
    2105                                             --      (Operation = ASYNC_WRITE_BURST_ADDRESS) ;
    2106                                               end function IsTryWriteAddress ;
    2107                                             
    2108                                               ------------------------------------------------------------
    2109                                               function IsWriteData (
    2110                                               -----------------------------------------------------------
    2111                                                 constant Operation      : In AddressBusOperationType
    2112                                               ) return boolean is
    2113                                               begin
    2114                                                 return
    2115                                                   (Operation = WRITE_OP) 
    2116                                                   or (Operation = WRITE_DATA)
    2117                                                   or (Operation = ASYNC_WRITE)
    2118                                                   or (Operation = ASYNC_WRITE_DATA) 
    2119                                                   or (Operation = WRITE_BURST) 
    2120            1                    ***0***           or (Operation = ASYNC_WRITE_BURST) ; 
    2121                                             --      or (Operation = WRITE_BURST_DATA) 
    2122                                             --      or (Operation = ASYNC_WRITE_BURST_DATA) ;
    2123                                               end function IsWriteData ;
    2124                                             
    2125                                               ------------------------------------------------------------
    2126                                               function IsBlockOnWriteData (
    2127                                               -----------------------------------------------------------
    2128                                                 constant Operation      : In AddressBusOperationType
    2129                                               ) return boolean is
    2130                                               begin
    2131                                                 return 
    2132                                                   (Operation = WRITE_OP)
    2133                                                   or (Operation = WRITE_DATA)
    2134            1                    ***0***           or (Operation = WRITE_BURST) ;
    2135                                             --      or (Operation = WRITE_BURST_DATA) ;
    2136                                               end function IsBlockOnWriteData ;
    2137                                             
    2138                                               ------------------------------------------------------------
    2139                                               function IsTryWriteData (
    2140                                               -----------------------------------------------------------
    2141                                                 constant Operation      : In AddressBusOperationType
    2142                                               ) return boolean is
    2143                                               begin
    2144                                                 return
    2145                                                   (Operation = ASYNC_WRITE)
    2146                                                   or (Operation = ASYNC_WRITE_DATA)
    2147            1                    ***0***           or (Operation = ASYNC_WRITE_BURST) ;
    2148                                             --      or (Operation = ASYNC_WRITE_BURST_DATA) ;
    2149                                               end function IsTryWriteData ;
    2150                                             
    2151                                               ------------------------------------------------------------
    2152                                               function IsReadAddress (
    2153                                               -----------------------------------------------------------
    2154                                                 constant Operation      : In AddressBusOperationType
    2155                                               ) return boolean is
    2156                                               begin
    2157                                                 return
    2158                                                   (Operation = READ_OP)
    2159                                                   or (Operation = READ_ADDRESS)
    2160                                                   or (Operation = READ_CHECK)
    2161                                                   or (Operation = ASYNC_READ)
    2162                                                   or (Operation = ASYNC_READ_ADDRESS)
    2163            1                    ***0***           or (Operation = READ_BURST) ;
    2164                                             --      or (Operation = READ_BURST_ADDRESS)
    2165                                             --      or (Operation = ASYNC_READ_BURST_ADDRESS) ;
    2166                                               end function IsReadAddress ;
    2167                                             
    2168                                               ------------------------------------------------------------
    2169                                               function IsTryReadAddress (
    2170                                               -----------------------------------------------------------
    2171                                                 constant Operation      : In AddressBusOperationType
    2172                                               ) return boolean is
    2173                                               begin
    2174                                                 return
    2175                                                   (Operation = ASYNC_READ)
    2176            1                    ***0***           or (Operation = ASYNC_READ_ADDRESS) ;
    2177                                             --      or (Operation = ASYNC_READ_BURST)
    2178                                             --      or (Operation = ASYNC_READ_BURST_ADDRESS) ;
    2179                                               end function IsTryReadAddress ;
    2180                                               
    2181                                               ------------------------------------------------------------
    2182                                               function IsReadData (
    2183                                               -----------------------------------------------------------
    2184                                                 constant Operation      : In AddressBusOperationType
    2185                                               ) return boolean is
    2186                                               begin
    2187                                                 return
    2188                                                   (Operation = READ_OP)
    2189                                                   or (Operation = READ_DATA)
    2190                                                   or (Operation = READ_CHECK)
    2191                                                   or (Operation = READ_DATA_CHECK)
    2192                                                   or (Operation = ASYNC_READ)
    2193                                                   or (Operation = ASYNC_READ_DATA)
    2194                                                   or (Operation = ASYNC_READ_DATA_CHECK)
    2195            1                    ***0***           or (Operation = READ_BURST) ;
    2196                                             --      or (Operation = READ_BURST_DATA)
    2197                                             --      or (Operation = ASYNC_READ_BURST)
    2198                                             --       or(Operation = ASYNC_READ_BURST_DATA) ;
    2199                                               end function IsReadData ;
    2200                                             
    2201                                               ------------------------------------------------------------
    2202                                               function IsBlockOnReadData (
    2203                                               -----------------------------------------------------------
    2204                                                 constant Operation      : In AddressBusOperationType
    2205                                               ) return boolean is
    2206                                               begin
    2207                                                 return
    2208                                                   (Operation = READ_OP)
    2209                                                   or (Operation = READ_DATA)
    2210                                                   or (Operation = READ_CHECK)
    2211                                                   or (Operation = READ_DATA_CHECK)
    2212            1                    ***0***           or (Operation = READ_BURST) ;
    2213                                             --      or (Operation = READ_BURST_DATA) ;
    2214                                               end function IsBlockOnReadData ;
    2215                                             
    2216                                               ------------------------------------------------------------
    2217                                               function IsTryReadData (
    2218                                               -----------------------------------------------------------
    2219                                                 constant Operation      : In AddressBusOperationType
    2220                                               ) return boolean is
    2221                                               begin
    2222                                                 return 
    2223                                                   (Operation = ASYNC_READ)
    2224                                                   or (Operation = ASYNC_READ_DATA)
    2225            1                    ***0***           or (Operation = ASYNC_READ_DATA_CHECK) ;
    2226                                             --      or (Operation = ASYNC_READ_BURST)
    2227                                             --      or (Operation = ASYNC_READ_BURST_DATA) ;
    2228                                               end function IsTryReadData ;
    2229                                             
    2230                                               ------------------------------------------------------------
    2231                                               function IsReadCheck (
    2232                                               -----------------------------------------------------------
    2233                                                 constant Operation      : In AddressBusOperationType
    2234                                               ) return boolean is
    2235                                               begin
    2236                                                 return
    2237                                                   (Operation = READ_CHECK) or
    2238                                                   (Operation = READ_DATA_CHECK) or
    2239            1                    ***0***           (Operation = ASYNC_READ_DATA_CHECK) ;
    2240                                               end function IsReadCheck ;
    2241                                             
    2242                                               ------------------------------------------------------------
    2243                                               function IsBurst (
    2244                                               -----------------------------------------------------------
    2245                                                 constant Operation      : In AddressBusOperationType
    2246                                               ) return boolean is
    2247                                               begin
    2248                                                 return
    2249                                                   (Operation = WRITE_BURST)
    2250                                                   or (Operation = ASYNC_WRITE_BURST)
    2251                                             --      or (Operation = WRITE_BURST_ADDRESS)
    2252                                             --      or (Operation = WRITE_BURST_DATA)
    2253                                             --      or (Operation = ASYNC_WRITE_BURST_ADDRESS)
    2254                                             --      or (Operation = ASYNC_WRITE_BURST_DATA)
    2255            1                    ***0***           or (Operation = READ_BURST) ;
    2256                                             --      or (Operation = READ_BURST_ADDRESS)
    2257                                             --      or (Operation = READ_BURST_DATA)
    2258                                             --      or (Operation = ASYNC_READ_BURST_ADDRESS)
    2259                                             --      or (Operation = ASYNC_READ_BURST_DATA) ;
    2260                                               end function IsBurst ;
    2261                                               
    2262                                               ------------------------------------------------------------
    2263                                               function ClassifyUnimplementedOperation (
    2264                                               -----------------------------------------------------------
    2265                                                 constant Operation        : In AddressBusOperationType ;
    2266                                                 constant TransactionCount : in natural
    2267                                               ) return string is
    2268                                               begin
    2269                                                 if Operation = MULTIPLE_DRIVER_DETECT then
    2270                                                   return "Multiple Drivers on Transaction Record." & 
    2271            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2272                                                 else
    2273                                                   return "Unimplemented Transaction: " & to_string(Operation) & 
    2274            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2275                                                 end if ; 
    2276                                               end function ClassifyUnimplementedOperation ;
    2277                                             
    2278                                               ------------------------------------------------------------
    2279                                               function ClassifyUnimplementedOperation (
    2280                                               -----------------------------------------------------------
    2281                                                 constant   TransactionRec : in AddressBusRecType 
    2282                                               ) return string is
    2283                                               begin
    2284            1                    ***0***         return ClassifyUnimplementedOperation(TransactionRec.Operation, TransactionRec.Rdy) ; 
    2285                                               end function ClassifyUnimplementedOperation ; 
    2286                                             
    2287                                             
    2288                                             end package body AddressBusTransactionPkg ;


=================================================================================
=== File: ../osvvm/Common/src/AddressBusVersionCompatibilityPkg.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                       2         0         2     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/AddressBusVersionCompatibilityPkg.vhd --

    1                                                --
    2                                                --  File Name:         AddressBusVersionCompatibilityPkg.vhd
    3                                                --  Design Unit Name:  AddressBusVersionCompatibilityPkg
    4                                                --  Revision:          OSVVM MODELS STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com
    7                                                --  Contributoriss):
    8                                                --     Jim Lewis      jim@synthworks.com
    9                                                --     Rob Gaddi      Highland Technology.    Wrote a similar package which inspired this one.
    10                                               --
    11                                               --
    12                                               --  Description:
    13                                               --      Defines types, constants, and subprograms used by
    14                                               --      OSVVM Address Bus Master Transaction Based Models isaka: TBM, TLM, VVC)
    15                                               --
    16                                               --
    17                                               --  Developed by:
    18                                               --        SynthWorks Design Inc.
    19                                               --        VHDL Training Classes
    20                                               --        http://www.SynthWorks.com
    21                                               --
    22                                               --  Revision History:
    23                                               --    Date      Version    Description
    24                                               --    09/2017   2017       Initial revision
    25                                               --    01/2020   2020.01    Updated license notice
    26                                               --    02/2020   2020.02    Refactored from Axi4LiteMasterTransactionPkg
    27                                               --    07/2020   2020.07    Unified M/S packages - dropping M/S terminology
    28                                               --
    29                                               --
    30                                               --  This file is part of OSVVM.
    31                                               --  
    32                                               --  Copyright isc) 2017 - 2020 by SynthWorks Design Inc.  
    33                                               --  
    34                                               --  Licensed under the Apache License, Version 2.0 isthe "License");
    35                                               --  you may not use this file except in compliance with the License.
    36                                               --  You may obtain a copy of the License at
    37                                               --  
    38                                               --      https://www.apache.org/licenses/LICENSE-2.0
    39                                               --  
    40                                               --  Unless required by applicable law or agreed to in writing, software
    41                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    42                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    43                                               --  See the License for the specific language governing permissions and
    44                                               --  limitations under the License.
    45                                               --  
    46                                               library ieee ;
    47                                                 use ieee.std_logic_1164.all ;
    48                                                 use ieee.numeric_std.all ;
    49                                                 use ieee.numeric_std_unsigned.all ;
    50                                                 use ieee.math_real.all ;
    51                                               
    52                                               library osvvm ;
    53                                                   context osvvm.OsvvmContext ;
    54                                                   
    55                                               use work.AddressBusTransactionPkg.all ; 
    56                                               use work.AddressBusResponderTransactionPkg.all ; 
    57                                                   
    58                                               package AddressBusVersionCompatibilityPkg is
    59                                               
    60                                               --  constant WAIT_CLOCK : UnresolvedAddressBusOperationType := WAIT_FOR_CLOCK ; 
    61                                               
    62                                                 alias AddressBusTransactionRecType is AddressBusRecType ; 
    63                                                 alias AddressBusMasterTransactionRecType is AddressBusRecType ; 
    64                                                 alias AddressBusMasterOperationType is AddressBusOperationType ; 
    65                                                 alias AddressBusSlaveTransactionRecType is AddressBusRecType ; 
    66                                                 alias AddressBusSlaveOperationType is AddressBusOperationType ; 
    67                                                 
    68                                               
    69                                               
    70                                               --  alias MasterWrite is Write [AddressBusRecType, std_logic_vector, std_logic_vector, boolean];
    71                                                 ------------------------------------------------------------
    72                                                 procedure MasterWrite (
    73                                                 -- do CPU Write Cycle
    74                                                 ------------------------------------------------------------
    75                                                   signal   TransactionRec : InOut AddressBusRecType ;
    76                                                            iAddr          : In    std_logic_vector ;
    77                                                            iData          : In    std_logic_vector ;
    78                                                            StatusMsgOn    : In    boolean := false
    79                                                 ) ;
    80                                               
    81                                                 ------------------------------------------------------------
    82                                                 alias MasterWriteAsync is WriteAsync
    83                                                   [AddressBusRecType, std_logic_vector, std_logic_vector, boolean];
    84                                               
    85                                                 ------------------------------------------------------------
    86                                                 alias MasterWriteAddressAsync is WriteAddressAsync
    87                                                   [AddressBusRecType, std_logic_vector, boolean];
    88                                               
    89                                                 ------------------------------------------------------------
    90                                                 alias MasterWriteDataAsync is WriteDataAsync
    91                                                   [AddressBusRecType, std_logic_vector, std_logic_vector, boolean];
    92                                               
    93                                                 ------------------------------------------------------------
    94                                                 alias MasterWriteDataAsync is WriteDataAsync
    95                                                   [AddressBusRecType, std_logic_vector, boolean];
    96                                                 
    97                                                 ------------------------------------------------------------
    98                                                 alias MasterWriteBurst is WriteBurst
    99                                                   [AddressBusRecType, std_logic_vector, integer, boolean];
    100                                              
    101                                                ------------------------------------------------------------
    102                                                alias MasterWriteBurstAsync is WriteBurstAsync
    103                                                  [AddressBusRecType, std_logic_vector, integer, boolean];
    104                                              
    105                                                ------------------------------------------------------------
    106                                              --  alias MasterRead is Read [AddressBusRecType, std_logic_vector, std_logic_vector, boolean];
    107                                                ------------------------------------------------------------
    108                                                procedure MasterRead (
    109                                                -- do CPU Read Cycle and return data
    110                                                ------------------------------------------------------------
    111                                                  signal   TransactionRec : InOut AddressBusRecType ;
    112                                                           iAddr          : In    std_logic_vector ;
    113                                                  variable oData          : Out   std_logic_vector ;
    114                                                           StatusMsgOn    : In    boolean := false
    115                                                ) ;
    116                                              
    117                                                ------------------------------------------------------------
    118                                                alias MasterReadCheck is ReadCheck
    119                                                  [AddressBusRecType, std_logic_vector, std_logic_vector, boolean];
    120                                              
    121                                                ------------------------------------------------------------
    122                                                alias MasterReadAddressAsync is ReadAddressAsync
    123                                                  [AddressBusRecType, std_logic_vector, boolean];
    124                                              
    125                                                ------------------------------------------------------------
    126                                                alias MasterReadData is ReadData
    127                                                  [AddressBusRecType, std_logic_vector, boolean];
    128                                              
    129                                                ------------------------------------------------------------
    130                                                alias MasterReadCheckData is ReadCheckData
    131                                                  [AddressBusRecType, std_logic_vector, boolean];
    132                                              
    133                                                ------------------------------------------------------------
    134                                                alias MasterTryReadData is TryReadData
    135                                                  [AddressBusRecType, std_logic_vector, boolean, boolean];
    136                                              
    137                                                ------------------------------------------------------------
    138                                                alias MasterTryReadCheckData is TryReadCheckData
    139                                                  [AddressBusRecType, std_logic_vector, boolean, boolean];
    140                                              
    141                                                ------------------------------------------------------------
    142                                                alias MasterReadPoll is ReadPoll
    143                                                  [AddressBusRecType, std_logic_vector, std_logic_vector, 
    144                                                   Integer, std_logic, boolean, natural];
    145                                              
    146                                                ------------------------------------------------------------
    147                                                alias MasterReadPoll is ReadPoll
    148                                                  [AddressBusRecType, std_logic_vector,  
    149                                                   Integer, std_logic, boolean, natural];
    150                                                
    151                                                ------------------------------------------------------------
    152                                                alias MasterReadBurst is ReadBurst
    153                                                  [AddressBusRecType, std_logic_vector, integer, boolean];
    154                                              
    155                                                ------------------------------------------------------------
    156                                                alias SlaveGetWrite is GetWrite
    157                                                  [AddressBusRecType, std_logic_vector, std_logic_vector, boolean];
    158                                                
    159                                                ------------------------------------------------------------
    160                                                alias SlaveTryGetWrite is TryGetWrite
    161                                                  [AddressBusRecType, std_logic_vector, std_logic_vector, boolean, boolean];
    162                                              
    163                                                ------------------------------------------------------------
    164                                                alias SlaveGetWriteAddress is GetWriteAddress
    165                                                  [AddressBusRecType, std_logic_vector, boolean];
    166                                                
    167                                                ------------------------------------------------------------
    168                                                alias SlaveTryGetWriteAddress is TryGetWriteAddress
    169                                                  [AddressBusRecType, std_logic_vector, boolean, boolean];
    170                                              
    171                                                ------------------------------------------------------------
    172                                                alias SlaveGetWriteData is GetWriteData
    173                                                  [AddressBusRecType, std_logic_vector, std_logic_vector, boolean];
    174                                                
    175                                                ------------------------------------------------------------
    176                                                alias SlaveTryGetWriteData is TryGetWriteData
    177                                                  [AddressBusRecType, std_logic_vector, std_logic_vector, boolean, boolean];
    178                                                
    179                                                ------------------------------------------------------------
    180                                                alias SlaveGetWriteData is GetWriteData
    181                                                  [AddressBusRecType, std_logic_vector, boolean];
    182                                              
    183                                                ------------------------------------------------------------
    184                                                alias SlaveTryGetWriteData is TryGetWriteData
    185                                                  [AddressBusRecType, std_logic_vector, boolean, boolean];
    186                                              
    187                                                ------------------------------------------------------------
    188                                                alias SlaveRead is SendRead
    189                                                  [AddressBusRecType, std_logic_vector, std_logic_vector, boolean];
    190                                                
    191                                                ------------------------------------------------------------
    192                                                alias SlaveTryRead is TrySendRead
    193                                                  [AddressBusRecType, std_logic_vector, std_logic_vector, boolean, boolean];
    194                                                
    195                                                ------------------------------------------------------------
    196                                                alias SlaveReadAddress is GetReadAddress
    197                                                  [AddressBusRecType, std_logic_vector, boolean];
    198                                                
    199                                                ------------------------------------------------------------
    200                                                alias SlaveTryReadAddress is TryGetReadAddress
    201                                                  [AddressBusRecType, std_logic_vector, boolean, boolean];
    202                                                
    203                                                ------------------------------------------------------------
    204                                                alias SlaveReadData is SendReadData
    205                                                  [AddressBusRecType, std_logic_vector, boolean];
    206                                                
    207                                                ------------------------------------------------------------
    208                                                alias SlaveAsyncReadData is SendReadDataAsync 
    209                                                  [AddressBusRecType, std_logic_vector, boolean];
    210                                                  
    211                                                alias AsyncSendReadData  is SendReadDataAsync 
    212                                                  [AddressBusRecType, std_logic_vector, boolean];
    213                                                
    214                                              end package AddressBusVersionCompatibilityPkg ;
    215                                              package body AddressBusVersionCompatibilityPkg is 
    216                                              
    217                                              
    218                                                ------------------------------------------------------------
    219                                                procedure MasterWrite (
    220                                                -- do CPU Write Cycle
    221                                                ------------------------------------------------------------
    222                                                  signal   TransactionRec : InOut AddressBusRecType ;
    223                                                           iAddr          : In    std_logic_vector ;
    224                                                           iData          : In    std_logic_vector ;
    225                                                           StatusMsgOn    : In    boolean := false
    226                                                ) is
    227                                                begin
    228             1                    ***0***         Write(TransactionRec, iAddr, iData, StatusMsgOn) ; 
    229                                                end procedure MasterWrite ;
    230                                              
    231                                                ------------------------------------------------------------
    232                                                procedure MasterRead (
    233                                                -- do CPU Read Cycle and return data
    234                                                ------------------------------------------------------------
    235                                                  signal   TransactionRec : InOut AddressBusRecType ;
    236                                                           iAddr          : In    std_logic_vector ;
    237                                                  variable oData          : Out   std_logic_vector ;
    238                                                           StatusMsgOn    : In    boolean := false
    239                                                ) is
    240                                                begin
    241             1                    ***0***         Read(TransactionRec, iAddr, oData, StatusMsgOn) ; 
    242                                                end procedure MasterRead ;
    243                                              
    244                                              
    245                                              end package body AddressBusVersionCompatibilityPkg ; 
    246                                              


=================================================================================
=== File: ../osvvm/Common/src/FifoFillPkg_slv.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        26         0        26     0.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/Common/src/FifoFillPkg_slv.vhd --

------------------------------------IF Branch------------------------------------
    380                                  ***0***     Count coming in to IF
    380             1                    ***0***           if VectorOfWords(i) < 0 then 
    382             1                    ***0***           elsif FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    384             1                    ***0***           else 
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------IF Branch------------------------------------
    414                                  ***0***     Count coming in to IF
    414             1                    ***0***         if FirstWord < 0 then 
    416             1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    419                                  ***0***     Count coming in to IF
    419             1                    ***0***         if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    421             1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    459                                  ***0***     Count coming in to IF
    459             1                    ***0***         if FirstWord < 0 then 
    461             1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    592                                  ***0***     Count coming in to IF
    592             1                    ***0***           if VectorOfWords(i) < 0 then 
    594             1                    ***0***           elsif FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    596             1                    ***0***           else 
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------IF Branch------------------------------------
    626                                  ***0***     Count coming in to IF
    626             1                    ***0***         if FirstWord < 0 then 
    628             1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    631                                  ***0***     Count coming in to IF
    631             1                    ***0***         if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    633             1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    671                                  ***0***     Count coming in to IF
    671             1                    ***0***         if FirstWord < 0 then 
    673             1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    736                                  ***0***     Count coming in to IF
    736             1                    ***0***           if not Empty(Fifo) then 
    740             1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    764                                  ***0***     Count coming in to IF
    764             1                    ***0***           if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    787                                  ***0***     Count coming in to IF
    787             1                    ***0***           if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    809                                  ***0***     Count coming in to IF
    809             1                    ***0***           if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%


Condition Coverage:
    Enabled Coverage              Bins   Covered    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Conditions                       9         0         9     0.00%

================================Condition Details================================

Condition Coverage for file ../osvvm/Common/src/FifoFillPkg_slv.vhd --

----------------Focused Condition View-------------------
Line       764 Item    1  not(((DropUndriven and (aData(Index) = 'U')) or (aData(Index) = '-')))
Condition totals: 0 of 3 input terms covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
          DropUndriven         N  No hits                  Hit '_0' and '_1'
  (aData(Index) = 'U')         N  No hits                  Hit '_0' and '_1'
  (aData(Index) = '-')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  DropUndriven_0          not (aData(Index) = '-')      
  Row   2:    ***0***  DropUndriven_1          (aData(Index) = 'U')          
  Row   3:    ***0***  (aData(Index) = 'U')_0  not (aData(Index) = '-') && DropUndriven
  Row   4:    ***0***  (aData(Index) = 'U')_1  DropUndriven                  
  Row   5:    ***0***  (aData(Index) = '-')_0  not (DropUndriven and (aData(Index) = 'U'))
  Row   6:    ***0***  (aData(Index) = '-')_1  not (DropUndriven and (aData(Index) = 'U'))

----------------Focused Condition View-------------------
Line       787 Item    1  not(((DropUndriven and (aData(Index) = 'U')) or (aData(Index) = '-')))
Condition totals: 0 of 3 input terms covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
          DropUndriven         N  No hits                  Hit '_0' and '_1'
  (aData(Index) = 'U')         N  No hits                  Hit '_0' and '_1'
  (aData(Index) = '-')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  DropUndriven_0          not (aData(Index) = '-')      
  Row   2:    ***0***  DropUndriven_1          (aData(Index) = 'U')          
  Row   3:    ***0***  (aData(Index) = 'U')_0  not (aData(Index) = '-') && DropUndriven
  Row   4:    ***0***  (aData(Index) = 'U')_1  DropUndriven                  
  Row   5:    ***0***  (aData(Index) = '-')_0  not (DropUndriven and (aData(Index) = 'U'))
  Row   6:    ***0***  (aData(Index) = '-')_1  not (DropUndriven and (aData(Index) = 'U'))

----------------Focused Condition View-------------------
Line       809 Item    1  not(((DropUndriven and (aData(Index) = 'U')) or (aData(Index) = '-')))
Condition totals: 0 of 3 input terms covered = 0.00%

            Input Term   Covered  Reason for no coverage   Hint
           -----------  --------  -----------------------  --------------
          DropUndriven         N  No hits                  Hit '_0' and '_1'
  (aData(Index) = 'U')         N  No hits                  Hit '_0' and '_1'
  (aData(Index) = '-')         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target              Non-masking condition(s)      
 ---------  ---------  --------------------    -------------------------     
  Row   1:    ***0***  DropUndriven_0          not (aData(Index) = '-')      
  Row   2:    ***0***  DropUndriven_1          (aData(Index) = 'U')          
  Row   3:    ***0***  (aData(Index) = 'U')_0  not (aData(Index) = '-') && DropUndriven
  Row   4:    ***0***  (aData(Index) = 'U')_1  DropUndriven                  
  Row   5:    ***0***  (aData(Index) = '-')_0  not (DropUndriven and (aData(Index) = 'U'))
  Row   6:    ***0***  (aData(Index) = '-')_1  not (DropUndriven and (aData(Index) = 'U'))


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                     125         0       125     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/FifoFillPkg_slv.vhd --

    1                                                --
    2                                                --  File Name:         FifoFillPkg_slv.vhd
    3                                                --  Design Unit Name:  FifoFillPkg_slv
    4                                                --  Revision:          STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com
    7                                                --  Contributor(s):
    8                                                --     Jim Lewis          email:  jim@synthworks.com
    9                                                --
    10                                               --
    11                                               --  Description:
    12                                               --    Fill and check data in burst fifos 
    13                                               --    Defines type ScoreBoardPType
    14                                               --    Defines methods for putting values the scoreboard
    15                                               --
    16                                               --  Developed for:
    17                                               --        SynthWorks Design Inc.
    18                                               --        VHDL Training Classes
    19                                               --        11898 SW 128th Ave.  Tigard, Or  97223
    20                                               --        http://www.SynthWorks.com
    21                                               --
    22                                               --  Revision History:
    23                                               --    Date      Version     Description
    24                                               --    10/2022   2022.10     Updated PushBurstRandom and CheckBurstRandom for bugs in Questa Intel edition 2021.2 
    25                                               --    01/2022   2022.01     Added new burst patterns
    26                                               --    06/2021   2021.06     Updated to work with new FIFO/Scoreboard data structures
    27                                               --    10/2020   2020.10     Updating comments to serve as documentation
    28                                               --    09/2020   2020.09     Updating comments to serve as documentation
    29                                               --    05/2020   2020.05     Initial revision
    30                                               --
    31                                               --  This file is part of OSVVM.
    32                                               --  
    33                                               --  Copyright (c) 2020 by SynthWorks Design Inc.  
    34                                               --  
    35                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    36                                               --  you may not use this file except in compliance with the License.
    37                                               --  You may obtain a copy of the License at
    38                                               --  
    39                                               --      https://www.apache.org/licenses/LICENSE-2.0
    40                                               --  
    41                                               --  Unless required by applicable law or agreed to in writing, software
    42                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    43                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    44                                               --  See the License for the specific language governing permissions and
    45                                               --  limitations under the License.
    46                                               --  
    47                                               
    48                                               
    49                                               use std.textio.all ;
    50                                               
    51                                               library ieee ;
    52                                                 use ieee.std_logic_1164.all ;
    53                                                 use ieee.numeric_std.all ;
    54                                                 use ieee.numeric_std_unsigned.all ;
    55                                                 
    56                                               library osvvm ; 
    57                                                 context osvvm.OsvvmContext ;   
    58                                                 use osvvm.ScoreboardPkg_slv.all ;
    59                                               
    60                                               package FifoFillPkg_slv is
    61                                                 ------------------------------------------------------------
    62                                                 procedure PushBurstVector (
    63                                                 -- Push each value in the VectorOfWords parameter into the FIFO.   
    64                                                 -- FifoWidth must match the std_logic_vector parameter.    
    65                                                 ------------------------------------------------------------
    66                                                   constant Fifo          : In    ScoreboardIdType ;
    67                                                   constant VectorOfWords : In    slv_vector 
    68                                                 ) ;
    69                                               
    70                                                 ------------------------------------------------------------
    71                                                 procedure PushBurstVector (
    72                                                 -- Push each value in the VectorOfWords parameter into the FIFO.   
    73                                                 -- Only FifoWidth bits of each value will be pushed.    
    74                                                 ------------------------------------------------------------
    75                                                   constant Fifo           : in    ScoreboardIdType ;
    76                                                   constant VectorOfWords  : in    integer_vector ;
    77                                                   constant FifoWidth      : in    integer
    78                                                 ) ;
    79                                               
    80                                                 ------------------------------------------------------------
    81                                                 procedure PushBurstIncrement (
    82                                                 -- Push Count number of values into FIFO.  The first value 
    83                                                 -- pushed will be FirstWord and following values are one greater 
    84                                                 -- than the previous one.  
    85                                                 -- FifoWidth must match the std_logic_vector parameter.    
    86                                                 ------------------------------------------------------------
    87                                                   constant Fifo           : In    ScoreboardIdType ;
    88                                                   constant FirstWord      : In    std_logic_vector ;
    89                                                   constant Count          : In    integer 
    90                                                 ) ;
    91                                               
    92                                                 ------------------------------------------------------------
    93                                                 procedure PushBurstIncrement (
    94                                                 -- Push Count number of values into FIFO.  The first value 
    95                                                 -- pushed will be FirstWord and following values are one greater 
    96                                                 -- than the previous one.  
    97                                                 -- Only FifoWidth bits of each value will be pushed.    
    98                                                 ------------------------------------------------------------
    99                                                   constant Fifo         : in    ScoreboardIdType ;
    100                                                  constant FirstWord    : in    integer ;
    101                                                  constant Count        : in    integer ;
    102                                                  constant FifoWidth    : in    integer := 8
    103                                                ) ;
    104                                                
    105                                                ------------------------------------------------------------
    106                                                procedure PushBurstRandom (
    107                                                -- Push Count number of values into FIFO.  The first value 
    108                                                -- pushed will be FirstWord and following values are randomly generated 
    109                                                -- using the first value as the randomization seed.
    110                                                -- FifoWidth must match the std_logic_vector parameter.    
    111                                                ------------------------------------------------------------
    112                                                  constant Fifo           : In    ScoreboardIdType ;
    113                                                  constant FirstWord      : In    std_logic_vector ;
    114                                                  constant Count          : In    integer 
    115                                                ) ;
    116                                              
    117                                                ------------------------------------------------------------
    118                                                procedure PushBurstRandom (
    119                                                -- Push Count number of values into FIFO.  The first value 
    120                                                -- pushed will be FirstWord and following values are randomly generated 
    121                                                -- using the first value as the randomization seed.
    122                                                -- Only FifoWidth bits of each value will be pushed.    
    123                                                ------------------------------------------------------------
    124                                                  constant Fifo         : in    ScoreboardIdType ;
    125                                                  constant FirstWord    : in    integer ;
    126                                                  constant Count        : in    integer ;
    127                                                  constant FifoWidth    : in    integer := 8
    128                                                ) ;
    129                                                
    130                                                ------------------------------------------------------------
    131                                                -- Experimental and Provisional
    132                                                procedure PushBurstRandom (
    133                                                -- Push Count number of values into FIFO.  Values are 
    134                                                -- randomly generated using the coverage model.
    135                                                -- Only FifoWidth bits of each value will be pushed.    
    136                                                ------------------------------------------------------------
    137                                                  constant Fifo         : in    ScoreboardIdType ;
    138                                                  constant CoverID      : in    CoverageIdType ;
    139                                                  constant Count        : in    integer ;
    140                                                  constant FifoWidth    : in    integer := 8
    141                                                ) ;
    142                                              
    143                                                ------------------------------------------------------------
    144                                                procedure PopBurstVector (
    145                                                -- Pop values from the FIFO into the VectorOfWords parameter.
    146                                                -- Width of VectorOfWords(i) shall match the width of the Fifo 
    147                                                ------------------------------------------------------------
    148                                                  constant Fifo           : in    ScoreboardIdType ;
    149                                                  variable VectorOfWords  : out   slv_vector 
    150                                                ) ;
    151                                              
    152                                                ------------------------------------------------------------
    153                                                procedure PopBurstVector (
    154                                                -- Pop values from the FIFO into the VectorOfWords parameter until FIFO Empty.
    155                                                -- Width of VectorOfWords(i) shall match the width of the Fifo 
    156                                                -- Count = number of words in the FIFO up to length of VectorOfWords
    157                                                -- If no words in FIFO, Count = 0 
    158                                                ------------------------------------------------------------
    159                                                  constant Fifo           : in    ScoreboardIdType ;
    160                                                  variable VectorOfWords  : out   slv_vector ;
    161                                                  variable Count          : out   natural 
    162                                                ) ;
    163                                              
    164                                                ------------------------------------------------------------
    165                                                procedure PopBurstVector (
    166                                                -- Pop values from the FIFO into the VectorOfWords parameter.
    167                                                -- Each value popped will be FifoWidth bits wide.   
    168                                                ------------------------------------------------------------
    169                                                  constant Fifo           : in    ScoreboardIdType ;
    170                                                  variable VectorOfWords  : out   integer_vector 
    171                                                ) ;
    172                                              
    173                                                ------------------------------------------------------------
    174                                                procedure PopBurstVector (
    175                                                -- Pop values from the FIFO into the VectorOfWords parameter until FIFO Empty.
    176                                                -- Count = number of words in the FIFO up to length of VectorOfWords
    177                                                -- If no words in FIFO, Count = 0 
    178                                                ------------------------------------------------------------
    179                                                  constant Fifo           : in    ScoreboardIdType ;
    180                                                  variable VectorOfWords  : out   integer_vector ;
    181                                                  variable Count          : out   natural 
    182                                                ) ;
    183                                              
    184                                                ------------------------------------------------------------
    185                                                procedure CheckBurstFifo (
    186                                                -- Check received values from the FIFO against 
    187                                                -- expected values in the scoreboard
    188                                                ------------------------------------------------------------
    189                                                  constant Scoreboard     : in    ScoreboardIdType ;
    190                                                  constant Fifo           : in    ScoreboardIdType ;
    191                                                  constant Count          : in    integer 
    192                                                ) ;
    193                                              
    194                                                ------------------------------------------------------------
    195                                                procedure CheckBurstVector (
    196                                                -- Check values from the FIFO against the values 
    197                                                -- in the VectorOfWords parameter.   
    198                                                -- Width of VectorOfWords(i) shall match the width of the Fifo 
    199                                                ------------------------------------------------------------
    200                                                  constant Fifo           : in    ScoreboardIdType ;
    201                                                  constant VectorOfWords  : in    slv_vector 
    202                                                ) ;
    203                                              
    204                                                ------------------------------------------------------------
    205                                                procedure CheckBurstVector (
    206                                                -- Check values from the FIFO against the values 
    207                                                -- in the VectorOfWords parameter.   
    208                                                -- Each value of VectorOfWords shall be converted to FifoWidth bits wide.   
    209                                                ------------------------------------------------------------
    210                                                  constant Fifo           : in    ScoreboardIdType ;
    211                                                  constant VectorOfWords  : in    integer_vector ;
    212                                                  constant FifoWidth      : in    integer
    213                                                ) ;
    214                                              
    215                                                ------------------------------------------------------------
    216                                                procedure CheckBurstIncrement (
    217                                                -- Check values from the FIFO against the incrementing values 
    218                                                -- that start with the value of the FirstWord.
    219                                                -- Width of FirstWord shall match the width of the Fifo 
    220                                                ------------------------------------------------------------
    221                                                  constant Fifo         : in    ScoreboardIdType ;
    222                                                  constant FirstWord    : in    std_logic_vector ;
    223                                                  constant Count        : in    integer 
    224                                                ) ;
    225                                                
    226                                                ------------------------------------------------------------
    227                                                procedure CheckBurstIncrement (
    228                                                -- Check values from the FIFO against the incrementing values 
    229                                                -- that start with the value of the FirstWord.
    230                                                -- Each value of VectorOfWords shall be converted to FifoWidth bits wide.   
    231                                                ------------------------------------------------------------
    232                                                  constant Fifo         : in    ScoreboardIdType ;
    233                                                  constant FirstWord    : in    integer ;
    234                                                  constant Count        : in    integer ;
    235                                                  constant FifoWidth    : in    integer := 8
    236                                                ) ;
    237                                              
    238                                                ------------------------------------------------------------
    239                                                procedure CheckBurstRandom (
    240                                                -- Check values from the FIFO against the random values 
    241                                                -- that are generated using the value of the FirstWord and 
    242                                                -- NumFifoWords as the randomization seeds.
    243                                                -- Width of FirstWord shall match the width of the Fifo 
    244                                                ------------------------------------------------------------
    245                                                  constant Fifo         : in    ScoreboardIdType ;
    246                                                  constant FirstWord    : in    std_logic_vector ;
    247                                                  constant Count        : in    integer 
    248                                                ) ;
    249                                                
    250                                                ------------------------------------------------------------
    251                                                procedure CheckBurstRandom (
    252                                                -- Check values from the FIFO against the random values 
    253                                                -- that are generated using the value of the FirstWord and 
    254                                                -- Count as the randomization seeds.
    255                                                -- Each value of VectorOfWords shall be converted to FifoWidth bits wide.   
    256                                                ------------------------------------------------------------
    257                                                  constant Fifo         : in    ScoreboardIdType ;
    258                                                  constant FirstWord    : in    integer ;
    259                                                  constant Count        : in    integer ;
    260                                                  constant FifoWidth    : in    integer := 8
    261                                                ) ;
    262                                              
    263                                                ------------------------------------------------------------
    264                                                -- Experimental and Provisional
    265                                                procedure CheckBurstRandom (
    266                                                ------------------------------------------------------------
    267                                                  constant Fifo         : in    ScoreboardIdType ;
    268                                                  constant CoverID      : in    CoverageIdType ;
    269                                                  constant Count        : in    integer ;
    270                                                  constant FifoWidth    : in    integer := 8
    271                                                ) ;
    272                                              
    273                                                -- ========================================================
    274                                                --  Verification Component Support
    275                                                -- ========================================================
    276                                              
    277                                                ------------------------------------------------------------
    278                                                procedure PopWord (
    279                                                -- Pop bytes from BurstFifo and form a word 
    280                                                -- Current implementation for now assumes it is assembling bytes.   
    281                                                --
    282                                                ------------------------------------------------------------
    283                                                  constant Fifo              : in    ScoreboardIdType ;
    284                                                  variable Valid             : out   boolean ;
    285                                                  variable Data              : out   std_logic_vector ; 
    286                                                  variable BytesToSend       : inout integer ;
    287                                                  constant ByteAddress       : in    natural := 0 
    288                                                ) ; 
    289                                              
    290                                                ------------------------------------------------------------
    291                                                procedure PushWord (
    292                                                -- Push a word into the byte oriented BurstFifo
    293                                                -- Current implementation for now assumes it is assembling bytes.   
    294                                                --
    295                                                ------------------------------------------------------------
    296                                                  constant Fifo              : in    ScoreboardIdType ;
    297                                                  variable Data              : in    std_logic_vector ; 
    298                                                  constant DropUndriven      : in    boolean := FALSE ;
    299                                                  constant ByteAddress       : in    natural := 0 
    300                                                ) ; 
    301                                                
    302                                                ------------------------------------------------------------
    303                                                procedure CheckWord (
    304                                                -- Check a word using the byte oriented BurstFifo
    305                                                -- Current implementation for now assumes it is assembling bytes.   
    306                                                --
    307                                                ------------------------------------------------------------
    308                                                  constant Fifo              : in    ScoreboardIdType ;
    309                                                  variable Data              : in    std_logic_vector ; 
    310                                                  constant DropUndriven      : in    boolean := FALSE ;
    311                                                  constant ByteAddress       : in    natural := 0 
    312                                                ) ;
    313                                              
    314                                                ------------------------------------------------------------
    315                                                function CountBytes(
    316                                                -- Count number of bytes in a word
    317                                                --
    318                                                ------------------------------------------------------------
    319                                                  constant Data              : in    std_logic_vector ;
    320                                                  constant DropUndriven      : in    boolean := FALSE ;
    321                                                  constant ByteAddress       : in    natural := 0 
    322                                                ) return integer ;
    323                                                
    324                                                -- ========================================================
    325                                                --  Deprecated
    326                                                -- ========================================================
    327                                              
    328                                                ------------------------------------------------------------
    329                                                -- Deprecated and replaced by PushBurstVector
    330                                                procedure PushBurst (
    331                                                -- Push each value in the VectorOfWords parameter into the FIFO.   
    332                                                -- Only FifoWidth bits of each value will be pushed.    
    333                                                ------------------------------------------------------------
    334                                                  constant Fifo           : in    ScoreboardIdType ;
    335                                                  constant VectorOfWords  : in    integer_vector ;
    336                                                  constant FifoWidth      : in    integer := 8
    337                                                ) ;
    338                                              
    339                                                ------------------------------------------------------------
    340                                                -- Deprecated and replaced by CheckBurstVector
    341                                                procedure CheckBurst (
    342                                                -- Pop values from the FIFO and check them against each value 
    343                                                -- in the VectorOfWords parameter.   
    344                                                -- Each value popped will be FifoWidth bits wide.   
    345                                                ------------------------------------------------------------
    346                                                  constant Fifo           : in    ScoreboardIdType ;
    347                                                  constant VectorOfWords  : in    integer_vector ;
    348                                                  constant FifoWidth      : in    integer := 8
    349                                                ) ;
    350                                              
    351                                              end package FifoFillPkg_slv ;
    352                                              -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    353                                              -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    354                                              -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    355                                              -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    356                                              package body FifoFillPkg_slv is
    357                                                constant NUMBER_POSITIVE_INTEGER_BITS : integer := 31 ; 
    358                                              
    359                                                ------------------------------------------------------------
    360                                                procedure PushBurstVector (
    361                                                ------------------------------------------------------------
    362                                                  constant Fifo          : In    ScoreboardIdType ;
    363                                                  constant VectorOfWords : In    slv_vector 
    364                                                ) is
    365                                                begin
    366             1                    ***0***         for i in VectorOfWords'range loop
    366             2                    ***0***     
    367             1                    ***0***           Push( Fifo, VectorOfWords(i) ) ;
    368             1                    ***0***         end loop ; 
    369                                                end procedure PushBurstVector ;
    370                                              
    371                                                ------------------------------------------------------------
    372                                                procedure PushBurstVector (
    373                                                ------------------------------------------------------------
    374                                                  constant Fifo           : in    ScoreboardIdType ;
    375                                                  constant VectorOfWords  : in    integer_vector ;
    376                                                  constant FifoWidth      : in    integer
    377                                                ) is
    378                                                begin
    379             1                    ***0***         for i in VectorOfWords'range loop 
    379             2                    ***0***     
    380                                                    if VectorOfWords(i) < 0 then 
    381             1                    ***0***             Push(Fifo, (FifoWidth downto 1 => 'U')) ;
    382                                                    elsif FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    383             1                    ***0***             Push(Fifo, to_slv(VectorOfWords(i) mod (2**FifoWidth), FifoWidth)) ;
    384                                                    else 
    385             1                    ***0***             Push(Fifo, to_slv(VectorOfWords(i), FifoWidth)) ;
    386                                                    end if ; 
    387             1                    ***0***         end loop ;
    388                                                end procedure PushBurstVector ;
    389                                              
    390                                                ------------------------------------------------------------
    391                                                procedure PushBurstIncrement (
    392                                                ------------------------------------------------------------
    393                                                  constant Fifo           : In    ScoreboardIdType ;
    394                                                  constant FirstWord      : In    std_logic_vector ;
    395                                                  constant Count          : In    integer 
    396                                                ) is
    397                                                begin
    398             1                    ***0***         for i in 0 to Count-1 loop
    398             2                    ***0***     
    399             1                    ***0***           Push( Fifo, FirstWord+i ) ;
    400             1                    ***0***         end loop ; 
    401                                                end procedure PushBurstIncrement ;
    402                                                
    403                                                ------------------------------------------------------------
    404                                                procedure PushBurstIncrement (
    405                                                ------------------------------------------------------------
    406                                                  constant Fifo         : in    ScoreboardIdType ;
    407                                                  constant FirstWord    : in    integer ;
    408                                                  constant Count        : in    integer ;
    409                                                  constant FifoWidth    : in    integer := 8
    410                                                ) is
    411                                                  variable intFirstWord : integer ; 
    412                                                  variable AdjFirstWord : std_logic_vector(FifoWidth-1 downto 0) ;
    413                                                begin
    414                                                  if FirstWord < 0 then 
    415             1                    ***0***           intFirstWord := -FirstWord ; 
    416                                                  else
    417             1                    ***0***           intFirstWord := FirstWord ; 
    418                                                  end if ; 
    419                                                  if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    420             1                    ***0***           AdjFirstWord := to_slv(intFirstWord mod (2**FifoWidth), FifoWidth) ;
    421                                                  else
    422             1                    ***0***           AdjFirstWord := to_slv(intFirstWord, FifoWidth) ;
    423                                                  end if ; 
    424             1                    ***0***         for i in 0 to Count-1 loop 
    424             2                    ***0***     
    425             1                    ***0***           Push( Fifo, AdjFirstWord+i ) ;
    426             1                    ***0***         end loop ;
    427                                                end procedure PushBurstIncrement ;
    428                                                
    429                                                ------------------------------------------------------------
    430                                                procedure PushBurstRandom (
    431                                                ------------------------------------------------------------
    432                                                  constant Fifo           : In    ScoreboardIdType ;
    433                                                  constant FirstWord      : In    std_logic_vector ;
    434                                                  constant Count          : In    integer 
    435                                                ) is
    436                                                  variable RV         : RandomPType ; 
    437                                                  alias    aFirstWord : std_logic_vector(FirstWord'length-1 downto 0) is FirstWord ; 
    438                                              --x    constant FW_LEFT    : integer := minimum(30, FirstWord'length) - 1 ;
    439                                                begin
    440             1                    ***0***         RV.InitSeed(to_integer(MetaTo01(aFirstWord(minimum(30, FirstWord'length) - 1 downto 0))) + Count, UseNewSeedMethods => TRUE) ;
    441             1                    ***0***         Push( Fifo, FirstWord ) ;
    442             1                    ***0***         for i in 2 to Count loop
    442             2                    ***0***     
    443             1                    ***0***           Push( Fifo, RV.RandSlv(FirstWord'length) ) ;
    444             1                    ***0***         end loop ; 
    445                                                end procedure PushBurstRandom ;
    446                                              
    447                                                ------------------------------------------------------------
    448                                                procedure PushBurstRandom (
    449                                                ------------------------------------------------------------
    450                                                  constant Fifo         : in    ScoreboardIdType ;
    451                                                  constant FirstWord    : in    integer ;
    452                                                  constant Count        : in    integer ;
    453                                                  constant FifoWidth    : in    integer := 8
    454                                                ) is
    455                                                  variable intFirstWord : integer ; 
    456                                              --    variable RV : RandomPType ; 
    457                                              --    variable SlvWord : std_logic_vector(FifoWidth-1 downto 0) ; 
    458                                                begin
    459                                                  if FirstWord < 0 then 
    460             1                    ***0***           intFirstWord := -FirstWord ; 
    461                                                  else
    462             1                    ***0***           intFirstWord := FirstWord ; 
    463                                                  end if ; 
    464                                              
    465             1                    ***0***         PushBurstRandom(Fifo, to_slv(intFirstWord, FifoWidth), Count) ; 
    466                                                  
    467                                              --    -- Initialize seed and toss first random value  
    468                                              --    RV.InitSeed(intFirstWord mod 2**30 + Count, UseNewSeedMethods => TRUE) ;
    469                                              --    
    470                                              --    if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    471                                              --      SlvWord := to_slv(intFirstWord mod (2**FifoWidth), FifoWidth) ;
    472                                              --    else 
    473                                              --      SlvWord := to_slv(intFirstWord, FifoWidth) ;
    474                                              --    end if ; 
    475                                              --    Push(Fifo, SlvWord) ;
    476                                              --    
    477                                              --    for i in 2 to Count loop 
    478                                              --      -- Extra Var added for QuestaSim
    479                                              --      SlvWord := RV.RandSlv(FifoWidth) ;
    480                                              --      Push(Fifo, SlvWord) ;
    481                                              --    end loop ;
    482                                                end procedure PushBurstRandom ;
    483                                              
    484                                                ------------------------------------------------------------
    485                                                -- Experimental and Provisional
    486                                                procedure PushBurstRandom (
    487                                                ------------------------------------------------------------
    488                                                  constant Fifo         : in    ScoreboardIdType ;
    489                                                  constant CoverID      : in    CoverageIdType ;
    490                                                  constant Count        : in    integer ;
    491                                                  constant FifoWidth    : in    integer := 8
    492                                                ) is
    493                                                  variable RandValue : std_logic_vector(FifoWidth-1 downto 0) ; 
    494                                                begin    
    495             1                    ***0***         for i in 1 to Count loop 
    495             2                    ***0***     
    496             1                    ***0***           RandValue := to_slv(GetRandPoint(CoverID), FifoWidth) ;
    497             1                    ***0***           Push(Fifo, RandValue) ;
    498             1                    ***0***           ICoverLast(CoverID) ; 
    499             1                    ***0***         end loop ;
    500                                                end procedure PushBurstRandom ;
    501                                              
    502                                                ------------------------------------------------------------
    503                                                procedure PopBurstVector (
    504                                                ------------------------------------------------------------
    505                                                  constant Fifo           : in    ScoreboardIdType ;
    506                                                  variable VectorOfWords  : out   slv_vector 
    507                                                ) is
    508                                                begin
    509             1                    ***0***         for i in VectorOfWords'range loop 
    509             2                    ***0***     
    510             1                    ***0***           VectorOfWords(i) := Pop(Fifo) ; 
    511             1                    ***0***         end loop ;
    512                                                end procedure PopBurstVector ;
    513                                              
    514                                                ------------------------------------------------------------
    515                                                procedure PopBurstVector (
    516                                                ------------------------------------------------------------
    517                                                  constant Fifo           : in    ScoreboardIdType ;
    518                                                  variable VectorOfWords  : out   slv_vector ;
    519                                                  variable Count          : out   natural 
    520                                                ) is
    521                                                begin
    522             1                    ***0***         Count := 0 ; 
    523             1                    ***0***         for i in VectorOfWords'range loop 
    523             2                    ***0***     
    524             1                    ***0***           exit when empty(Fifo) ; 
    525             1                    ***0***           VectorOfWords(i) := Pop(Fifo) ; 
    526             1                    ***0***           Count := i ;
    527             1                    ***0***         end loop ;
    528                                                end procedure PopBurstVector ;
    529                                              
    530                                                ------------------------------------------------------------
    531                                                procedure PopBurstVector (
    532                                                ------------------------------------------------------------
    533                                                  constant Fifo           : in    ScoreboardIdType ;
    534                                                  variable VectorOfWords  : out   integer_vector 
    535                                                ) is
    536                                                begin
    537             1                    ***0***         for i in VectorOfWords'range loop 
    537             2                    ***0***     
    538             1                    ***0***           VectorOfWords(i) := to_integer(Pop(Fifo)) ; 
    539             1                    ***0***         end loop ;
    540                                                end procedure PopBurstVector ;
    541                                              
    542                                                ------------------------------------------------------------
    543                                                procedure PopBurstVector (
    544                                                ------------------------------------------------------------
    545                                                  constant Fifo           : in    ScoreboardIdType ;
    546                                                  variable VectorOfWords  : out   integer_vector ;
    547                                                  variable Count          : out   natural 
    548                                                ) is
    549                                                begin
    550             1                    ***0***         Count := 0 ; 
    551             1                    ***0***         for i in VectorOfWords'range loop 
    551             2                    ***0***     
    552             1                    ***0***           exit when empty(Fifo) ; 
    553             1                    ***0***           VectorOfWords(i) := to_integer(Pop(Fifo)) ; 
    554             1                    ***0***           Count := i ;
    555             1                    ***0***         end loop ;
    556                                                end procedure PopBurstVector ;
    557                                              
    558                                                ------------------------------------------------------------
    559                                                procedure CheckBurstFifo (
    560                                                ------------------------------------------------------------
    561                                                  constant Scoreboard     : in    ScoreboardIdType ;
    562                                                  constant Fifo           : in    ScoreboardIdType ;
    563                                                  constant Count          : in    integer 
    564                                                ) is
    565                                                begin
    566             1                    ***0***         for i in 1 to Count loop
    566             2                    ***0***     
    567             1                    ***0***           Check(Scoreboard, Pop(Fifo)) ; 
    568             1                    ***0***         end loop ; 
    569                                                end procedure CheckBurstFifo ;
    570                                              
    571                                                ------------------------------------------------------------
    572                                                procedure CheckBurstVector (
    573                                                ------------------------------------------------------------
    574                                                  constant Fifo           : in    ScoreboardIdType ;
    575                                                  constant VectorOfWords  : in    slv_vector 
    576                                                ) is
    577                                                begin
    578             1                    ***0***         for i in VectorOfWords'range loop
    578             2                    ***0***     
    579             1                    ***0***           CheckExpected( Fifo, VectorOfWords(i) ) ;
    580             1                    ***0***         end loop ; 
    581                                                end procedure CheckBurstVector ;
    582                                              
    583                                                ------------------------------------------------------------
    584                                                procedure CheckBurstVector (
    585                                                ------------------------------------------------------------
    586                                                  constant Fifo           : in    ScoreboardIdType ;
    587                                                  constant VectorOfWords  : in    integer_vector ;
    588                                                  constant FifoWidth      : in    integer 
    589                                                ) is
    590                                                begin
    591             1                    ***0***         for i in VectorOfWords'range loop 
    591             2                    ***0***     
    592                                                    if VectorOfWords(i) < 0 then 
    593             1                    ***0***             CheckExpected( Fifo, (FifoWidth downto 1 => 'U') ) ;
    594                                                    elsif FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    595             1                    ***0***             CheckExpected( Fifo, to_slv(VectorOfWords(i) mod (2**FifoWidth), FifoWidth) ) ;
    596                                                    else 
    597             1                    ***0***             CheckExpected( Fifo, to_slv(VectorOfWords(i), FifoWidth) ) ;
    598                                                    end if ; 
    599             1                    ***0***         end loop ;
    600                                                end procedure CheckBurstVector ;
    601                                              
    602                                                ------------------------------------------------------------
    603                                                procedure CheckBurstIncrement (
    604                                                ------------------------------------------------------------
    605                                                  constant Fifo         : in    ScoreboardIdType ;
    606                                                  constant FirstWord    : in    std_logic_vector ;
    607                                                  constant Count        : in    integer 
    608                                                ) is
    609                                                begin
    610             1                    ***0***         for i in 0 to Count-1 loop
    610             2                    ***0***     
    611             1                    ***0***           CheckExpected( Fifo, FirstWord+i ) ;
    612             1                    ***0***         end loop ; 
    613                                                end procedure CheckBurstIncrement ;
    614                                              
    615                                                ------------------------------------------------------------
    616                                                procedure CheckBurstIncrement (
    617                                                ------------------------------------------------------------
    618                                                  constant Fifo         : in    ScoreboardIdType ;
    619                                                  constant FirstWord    : in    integer ;
    620                                                  constant Count        : in    integer ;
    621                                                  constant FifoWidth    : in    integer := 8
    622                                                ) is
    623                                                  variable intFirstWord : integer ; 
    624                                                  variable AdjFirstWord : std_logic_vector(FifoWidth-1 downto 0) ;
    625                                                begin
    626                                                  if FirstWord < 0 then 
    627             1                    ***0***           intFirstWord := -FirstWord ; 
    628                                                  else
    629             1                    ***0***           intFirstWord := FirstWord ; 
    630                                                  end if ; 
    631                                                  if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    632             1                    ***0***           AdjFirstWord := to_slv(intFirstWord mod (2**FifoWidth), FifoWidth) ;
    633                                                  else
    634             1                    ***0***           AdjFirstWord := to_slv(intFirstWord, FifoWidth) ;
    635                                                  end if ; 
    636             1                    ***0***         for i in 0 to Count-1 loop 
    636             2                    ***0***     
    637             1                    ***0***           CheckExpected( Fifo, AdjFirstWord+i ) ;
    638             1                    ***0***         end loop ;
    639                                                end procedure CheckBurstIncrement ;
    640                                                
    641                                                ------------------------------------------------------------
    642                                                procedure CheckBurstRandom (
    643                                                ------------------------------------------------------------
    644                                                  constant Fifo         : in    ScoreboardIdType ;
    645                                                  constant FirstWord    : in    std_logic_vector ;
    646                                                  constant Count        : in    integer 
    647                                                ) is
    648                                                  variable RV         : RandomPType ; 
    649                                                  alias    aFirstWord : std_logic_vector(FirstWord'length-1 downto 0) is FirstWord ; 
    650                                                  constant FW_LEFT    : integer := minimum(30, FirstWord'length) - 1 ;
    651                                                begin
    652             1                    ***0***         RV.InitSeed(to_integer(MetaTo01(aFirstWord(FW_LEFT downto 0))) + Count, UseNewSeedMethods => TRUE) ;
    653             1                    ***0***         CheckExpected( Fifo, FirstWord ) ;
    654             1                    ***0***         for i in 2 to Count loop
    654             2                    ***0***     
    655             1                    ***0***           CheckExpected( Fifo, RV.RandSlv(FirstWord'length) ) ;
    656             1                    ***0***         end loop ; 
    657                                                end procedure CheckBurstRandom ;
    658                                              
    659                                                ------------------------------------------------------------
    660                                                procedure CheckBurstRandom (
    661                                                ------------------------------------------------------------
    662                                                  constant Fifo         : in    ScoreboardIdType ;
    663                                                  constant FirstWord    : in    integer ;
    664                                                  constant Count        : in    integer ;
    665                                                  constant FifoWidth    : in    integer := 8
    666                                                ) is
    667                                                  variable intFirstWord : integer ; 
    668                                              --    variable RV           : RandomPType ; 
    669                                              --    variable SlvWord : std_logic_vector(FifoWidth-1 downto 0) ; 
    670                                                begin
    671                                                  if FirstWord < 0 then 
    672             1                    ***0***           intFirstWord := -FirstWord ; 
    673                                                  else
    674             1                    ***0***           intFirstWord := FirstWord ; 
    675                                                  end if ; 
    676             1                    ***0***         CheckBurstRandom(Fifo, to_slv(intFirstWord, FifoWidth), Count) ; 
    677                                                  
    678                                              --    -- Initialize seed and toss first random value  
    679                                              --    RV.InitSeed(intFirstWord mod 2**30 + Count, UseNewSeedMethods => TRUE) ;
    680                                              --    
    681                                              --    if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then 
    682                                              --      SlvWord := to_slv(intFirstWord mod (2**FifoWidth), FifoWidth) ;
    683                                              --    else 
    684                                              --      SlvWord := to_slv(intFirstWord, FifoWidth) ;
    685                                              --    end if ; 
    686                                              --    CheckExpected(Fifo, SlvWord) ;
    687                                              --    
    688                                              --    for i in 2 to Count loop 
    689                                              --      -- Extra Var added for QuestaSim
    690                                              --      SlvWord := RV.RandSlv(FifoWidth) ; 
    691                                              --      CheckExpected(Fifo, SlvWord) ;
    692                                              --    end loop ;
    693                                                end procedure CheckBurstRandom ;
    694                                                
    695                                                ------------------------------------------------------------
    696                                                -- Experimental and Provisional
    697                                                procedure CheckBurstRandom (
    698                                                ------------------------------------------------------------
    699                                                  constant Fifo         : in    ScoreboardIdType ;
    700                                                  constant CoverID      : in    CoverageIdType ;
    701                                                  constant Count        : in    integer ;
    702                                                  constant FifoWidth    : in    integer := 8
    703                                                ) is
    704                                                  variable RandValue : std_logic_vector(FifoWidth-1 downto 0) ; 
    705                                                begin    
    706             1                    ***0***         for i in 1 to Count loop 
    706             2                    ***0***     
    707             1                    ***0***           RandValue := to_slv(GetRandPoint(CoverID), FifoWidth) ;
    708             1                    ***0***           CheckExpected(Fifo, RandValue) ;
    709             1                    ***0***           ICoverLast(CoverID) ; 
    710             1                    ***0***         end loop ;
    711                                                end procedure CheckBurstRandom ;
    712                                              
    713                                                -- ========================================================
    714                                                --  Verification Component Support
    715                                                -- ========================================================
    716                                              
    717                                                ------------------------------------------------------------
    718                                                procedure PopWord (
    719                                                -- Pop bytes from BurstFifo and form a word 
    720                                                -- Current implementation for now assumes it is assembling bytes.   
    721                                                --
    722                                                ------------------------------------------------------------
    723                                                  constant Fifo              : in    ScoreboardIdType ;
    724                                                  variable Valid             : out   boolean ;
    725                                                  variable Data              : out   std_logic_vector ; 
    726                                                  variable BytesToSend       : inout integer ;
    727                                                  constant ByteAddress       : in    natural := 0 
    728                                                ) is
    729                                                  variable Index    : integer := ByteAddress * 8 ; 
    730                                                  constant DataLeft : integer := Data'length-1; 
    731                                                  alias aData       : std_logic_vector(DataLeft downto 0) is Data;
    732                                                begin
    733             1                    ***0***         aData := (aData'range => 'U') ;  -- Default Undriven
    734             1                    ***0***         Valid := TRUE ; 
    735             1                    ***0***         GetWord : while Index <= DataLeft loop  
    736                                                    if not Empty(Fifo) then 
    737             1                    ***0***             aData(Index+7 downto Index) := Pop(Fifo) ; 
    738             1                    ***0***             BytesToSend := BytesToSend - 1 ; 
    739             1                    ***0***             exit when BytesToSend = 0 ; 
    740                                                    else
    741             1                    ***0***             Valid := FALSE ; 
    742             1                    ***0***             exit ; 
    743                                                    end if ; 
    744             1                    ***0***           Index := Index + 8 ; 
    745             1                    ***0***         end loop GetWord ;
    746                                                end PopWord ; 
    747                                              
    748                                                ------------------------------------------------------------
    749                                                procedure PushWord (
    750                                                -- Push a word into the byte oriented BurstFifo
    751                                                -- Current implementation for now assumes it is assembling bytes.   
    752                                                --
    753                                                ------------------------------------------------------------
    754                                                  constant Fifo              : in    ScoreboardIdType ;
    755                                                  variable Data              : in    std_logic_vector ; 
    756                                                  constant DropUndriven      : in    boolean := FALSE ;
    757                                                  constant ByteAddress       : in    natural := 0 
    758                                                ) is
    759                                                  variable Index    : integer := ByteAddress * 8 ; 
    760                                                  constant DataLeft : integer := Data'length-1; 
    761                                                  alias    aData    : std_logic_vector(DataLeft downto 0) is Data;
    762                                                begin
    763             1                    ***0***         PushBytes : while Index <= DataLeft loop  
    764                                                    if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then 
    765             1                    ***0***             Push(Fifo, aData(Index+7 downto Index)) ; 
    766                                                    end if ;
    767             1                    ***0***           Index := Index + 8 ; 
    768             1                    ***0***         end loop PushBytes ; 
    769                                                end PushWord ; 
    770                                              
    771                                                ------------------------------------------------------------
    772                                                procedure CheckWord (
    773                                                -- Push a word into the byte oriented BurstFifo
    774                                                -- Current implementation for now assumes it is assembling bytes.   
    775                                                --
    776                                                ------------------------------------------------------------
    777                                                  constant Fifo              : in    ScoreboardIdType ;
    778                                                  variable Data              : in    std_logic_vector ; 
    779                                                  constant DropUndriven      : in    boolean := FALSE ;
    780                                                  constant ByteAddress       : in    natural := 0 
    781                                                ) is
    782                                                  variable Index    : integer := ByteAddress * 8 ; 
    783                                                  constant DataLeft : integer := Data'length-1; 
    784                                                  alias aData       : std_logic_vector(DataLeft downto 0) is Data;
    785                                                begin
    786             1                    ***0***         PushBytes : while Index <= DataLeft loop  
    787                                                    if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then 
    788             1                    ***0***             Check(Fifo, aData(Index+7 downto Index)) ; 
    789                                                    end if ;
    790             1                    ***0***           Index := Index + 8 ; 
    791             1                    ***0***         end loop PushBytes ; 
    792                                                end CheckWord ; 
    793                                              
    794                                                ------------------------------------------------------------
    795                                                function CountBytes(
    796                                                -- Count number of bytes in a word
    797                                                --
    798                                                ------------------------------------------------------------
    799                                                  constant Data              : in    std_logic_vector ;
    800                                                  constant DropUndriven      : in    boolean := FALSE ;
    801                                                  constant ByteAddress       : in    natural := 0 
    802                                                ) return integer is
    803                                                  variable Index    : integer := ByteAddress * 8 ; 
    804                                                  variable Count    : integer := 0 ; 
    805                                                  constant DataLeft : integer := Data'length-1 ;
    806                                                  alias aData       : std_logic_vector(DataLeft downto 0) is Data ; 
    807                                                begin
    808             1                    ***0***         while Index <= DataLeft loop
    809                                                    if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then 
    810             1                    ***0***             Count := Count + 1 ; 
    811                                                    end if ;
    812             1                    ***0***           Index := Index + 8 ; 
    813             1                    ***0***         end loop ; 
    814             1                    ***0***         return Count ;
    815                                                end function CountBytes ; 
    816                                              
    817                                                -- ========================================================
    818                                                --  Deprecated
    819                                                -- ========================================================
    820                                              
    821                                                ------------------------------------------------------------
    822                                                -- Deprecated.  Replaced by PushBurstVector
    823                                                procedure PushBurst (
    824                                                ------------------------------------------------------------
    825                                                  constant Fifo           : in    ScoreboardIdType ;
    826                                                  constant VectorOfWords  : in    integer_vector ;
    827                                                  constant FifoWidth      : in    integer := 8
    828                                                ) is
    829                                                begin
    830             1                    ***0***         PushBurstVector(Fifo, VectorOfWords, FifoWidth) ; 
    831                                                end procedure PushBurst ;
    832                                              
    833                                                ------------------------------------------------------------
    834                                                -- Deprecated and replaced by CheckBurstVector
    835                                                procedure CheckBurst (
    836                                                -- Pop values from the FIFO and check them against each value 
    837                                                -- in the VectorOfWords parameter.   
    838                                                -- Each value popped will be FifoWidth bits wide.   
    839                                                ------------------------------------------------------------
    840                                                  constant Fifo           : in    ScoreboardIdType ;
    841                                                  constant VectorOfWords  : in    integer_vector ;
    842                                                  constant FifoWidth      : in    integer := 8
    843                                                ) is
    844                                                begin
    845             1                    ***0***         CheckBurstVector(Fifo, VectorOfWords, FifoWidth) ; 
    846                                                end procedure CheckBurst ;
    847                                                
    848                                              end FifoFillPkg_slv ;


=================================================================================
=== File: ../osvvm/Common/src/ModelParametersPtPkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        32         0        32     0.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/Common/src/ModelParametersPtPkg.vhd --

------------------------------------IF Branch------------------------------------
    102                                  ***0***     Count coming in to IF
    102             1                    ***0***             if ParmPtrVar(i).SParm /= NULL then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    114                                  ***0***     Count coming in to IF
    114             1                    ***0***     			if ParmPtrVar /= NULL then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    143                                  ***0***     Count coming in to CASE
    144             1                    ***0***             when NONE | eINT =>
    144             2                    ***0***     
    148             1                    ***0***             when eSLV =>
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    167                                  ***0***     Count coming in to CASE
    168             1                    ***0***             when NONE | eINT =>
    168             2                    ***0***     
    172             1                    ***0***             when eSLV =>
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------IF Branch------------------------------------
    169                                  ***0***     Count coming in to IF
    169             1                    ***0***               ParmPtrVar(Index).IParm     := 1 when Data else 0 ;
    169             2                    ***0***               ParmPtrVar(Index).IParm     := 1 when Data else 0 ;
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    174                                  ***0***     Count coming in to IF
    174             1                    ***0***               ParmPtrVar(Index).SParm(0) := '1' when Data else '0';
    174             2                    ***0***               ParmPtrVar(Index).SParm(0) := '1' when Data else '0';
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    185                                  ***0***     Count coming in to CASE
    186             1                    ***0***             when NONE =>
    190             1                    ***0***             when eSLV  =>
    194             1                    ***0***             when eINT =>
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    205                                  ***0***     Count coming in to CASE
    206             1                    ***0***             when NONE =>
    210             1                    ***0***             when eSLV  =>
    214             1                    ***0***             when eINT =>
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    224                                  ***0***     Count coming in to CASE
    225             1                    ***0***             when NONE =>
    229             1                    ***0***             when eINT =>
    232             1                    ***0***             when eSLV =>
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    242                                  ***0***     Count coming in to CASE
    243             1                    ***0***             when NONE =>
    247             1                    ***0***             when eINT =>
    250             1                    ***0***             when eSLV =>
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    259                                  ***0***     Count coming in to CASE
    260             1                    ***0***             when NONE =>
    264             1                    ***0***             when eINT =>
    267             1                    ***0***             when eSLV =>
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    278                                  ***0***     Count coming in to CASE
    279             1                    ***0***             when NONE =>
    283             1                    ***0***             when eINT =>
    287             1                    ***0***             when eSLV =>
Branch totals: 0 hits of 3 branches = 0.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      56         0        56     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/ModelParametersPtPkg.vhd --

    1                                                --
    2                                                --  File Name:         ModelParametersPkg.vhd
    3                                                --  Design Unit Name:  ModelParametersPkg
    4                                                --  Revision:          OSVVM MODELS STANDARD VERSION
    5                                                --
    6                                                --  Author:      Rob Gaddi  <rgaddi@highlandtechnology.com>
    7                                                --  Company      Highland Technology, Inc.
    8                                                --
    9                                                --  Contributor(s):
    10                                               --     Jim Lewis      jim@synthworks.com
    11                                               --
    12                                               --
    13                                               --  Description:
    14                                               --      Defines ModelParametersPType
    15                                               --
    16                                               --  Revision History:
    17                                               --    Date      Version    Description
    18                                               --    05/2020   NONE       Refactored from AbstractMmPkg.vhd
    19                                               --    05/2020   2020.05    Added handling to also store std_logic_vector values
    20                                               --                         Added AlertLogID for error handling
    21                                               --                      
    22                                               --
    23                                               --
    24                                               --  This file is part of OSVVM.
    25                                               --
    26                                               --  Copyright (c) 2020 by Highland Technology
    27                                               --  Copyright (c) 2020 by SynthWorks Design Inc.
    28                                               --
    29                                               --
    30                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    31                                               --  you may not use this file except in compliance with the License.
    32                                               --  You may obtain a copy of the License at
    33                                               --
    34                                               --      https://www.apache.org/licenses/LICENSE-2.0
    35                                               --
    36                                               --  Unless required by applicable law or agreed to in writing, software
    37                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    38                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    39                                               --  See the License for the specific language governing permissions and
    40                                               --  limitations under the License.
    41                                               --
    42                                               
    43                                               library ieee;
    44                                               use ieee.std_logic_1164.all;
    45                                               use ieee.numeric_std.all;
    46                                               use ieee.numeric_std_unsigned.all;
    47                                               
    48                                               library osvvm;
    49                                               context osvvm.OsvvmContext ; 
    50                                               
    51                                               
    52                                               package ModelParametersPkg is
    53                                               	
    54                                               	type ModelParametersPType is protected
    55                                               -- Add SetAlertLogID(string, ID), SetAlertLogID(ID), GetAlertLogID
    56                                               
    57                                               		procedure Init(nparams : in positive);
    58                                               --		procedure Init(initvals : in integer_vector);
    59                                               		
    60                                               		procedure Set(Index: in natural; Data: in integer);
    61                                               		procedure Set(Data:  in integer_vector);
    62                                               		procedure Set(Index: in natural; Data: in integer; len: positive);
    63                                               		procedure Set(Index: in natural; Data: in boolean);
    64                                               		procedure Set(Index: in natural; Data: in std_logic_vector);
    65                                               		
    66                                               		impure function Get(Index: natural) return integer;
    67                                               		impure function Get(Index: natural) return boolean;
    68                                               		impure function Get(Index: natural) return std_logic_vector;
    69                                               		impure function Get(Index: natural; len: positive) return std_logic_vector;
    70                                                   
    71                                                   ------------------------------------------------------------
    72                                                   procedure SetAlertLogID (A : AlertLogIDType) ;
    73                                                   procedure SetAlertLogID (Name : string ; ParentID : AlertLogIDType := ALERTLOG_BASE_ID ; CreateHierarchy : Boolean := TRUE) ;    
    74                                                   impure function GetAlertLogID return AlertLogIDType ;
    75                                               	end protected ModelParametersPType;
    76                                               
    77                                               end package ModelParametersPkg;
    78                                               
    79                                               package body ModelParametersPkg is
    80                                               	
    81                                               	type ModelParametersPType is protected body
    82                                               		type SlvPtrType is access std_logic_vector;
    83                                                   
    84                                                   type ParmTypeType is (NONE, eSLV, eINT) ; 
    85                                               
    86                                                   type ParameterRecType is record 
    87                                                     ParmType : ParmTypeType ; 
    88                                                     IParm    : integer ; 
    89                                                     SParm    : SlvPtrType ; 
    90                                                   end record ParameterRecType ; 
    91                                                   type ParameterRecArrayType is array (natural range <>) of ParameterRecType ; 
    92                                               		type ParamPtrType is access ParameterRecArrayType ;
    93              1                    ***0***     		variable ParmPtrVar : ParamPtrType := NULL;
    94                                                   
    95              1                    ***0***         variable AlertLogIDVar : AlertLogIDType := OSVVM_ALERTLOG_ID ;
    96                                               	
    97                                                   ------------------------------------------------------------
    98                                                   procedure Deallocate is
    99                                                   ------------------------------------------------------------
    100                                                  begin
    101             1                    ***0***           for i in ParmPtrVar'range loop  
    101             2                    ***0***     
    102                                                      if ParmPtrVar(i).SParm /= NULL then 
    103             1                    ***0***               deallocate(ParmPtrVar(i).SParm) ;
    104                                                      end if ; 
    105             1                    ***0***           end loop ;
    106             1                    ***0***           deallocate(ParmPtrVar);
    107                                                  end procedure Deallocate ; 
    108                                                  
    109                                                  ------------------------------------------------------------
    110                                              		--	Create storage for nParams parameters
    111                                              		procedure Init(nparams : in positive) is
    112                                                  ------------------------------------------------------------
    113                                              		begin
    114                                              			if ParmPtrVar /= NULL then
    115                                              -- probably a mistake to do this
    116                                              -- Should instead do a resize of the structure like in ScoreboardPkg.
    117             1                    ***0***             Deallocate; 
    118                                                    end if; 
    119             1                    ***0***     			ParmPtrVar := new ParameterRecArrayType(0 to nparams-1);
    120             1                    ***0***     			for i in ParmPtrVar'range loop
    120             2                    ***0***     
    121             1                    ***0***     				ParmPtrVar(i).IParm := 0;
    122             1                    ***0***     			end loop;
    123                                              		end procedure Init;
    124                                              		
    125                                                  ------------------------------------------------------------
    126                                              --		--	Initialize the parameters array from initvals.
    127                                              --		procedure Init(InitVals : in integer_vector) is
    128                                                  ------------------------------------------------------------
    129                                              --      alias aInitVals : integer_vector(0 to InitVals'length-1) ;
    130                                              --		begin
    131                                              --      Deallocate ; 
    132                                              --			ParmPtrVar := new ParameterRecArrayType(0 to InitVals'length-1);
    133                                              --      for i in aInitVals'range loop 
    134                                              --        ParmPtrVar(i).IsInit := TRUE ;
    135                                              --        ParmPtrVar(i).IParm  := aInitVals(i) ;
    136                                              --      end loop ; 
    137                                              --		end procedure Init;
    138                                              		
    139                                                  ------------------------------------------------------------
    140                                              		procedure Set(Index: in natural; Data: in integer) is
    141                                                  ------------------------------------------------------------
    142                                              		begin
    143                                                    case ParmPtrVar(Index).ParmType is 
    144                                                      when NONE | eINT =>
    145             1                    ***0***               ParmPtrVar(Index).IParm     := Data;
    146             1                    ***0***               ParmPtrVar(Index).ParmType  := eINT;
    147                                                      
    148                                                      when eSLV =>
    149             1                    ***0***               ParmPtrVar(Index).SParm.all := std_logic_vector(to_signed(Data, ParmPtrVar(Index).SParm'length));
    150             1                    ***0***               ParmPtrVar(Index).ParmType  := eSLV;
    151                                                    end case ; 
    152                                                  end procedure Set;
    153                                              		
    154                                                  ------------------------------------------------------------
    155                                              		procedure Set(Data: in integer_vector) is
    156                                                  ------------------------------------------------------------
    157                                              		begin
    158             1                    ***0***           for i in Data'range loop 
    158             2                    ***0***     
    159             1                    ***0***             Set(i, Data(i)) ; 
    160             1                    ***0***           end loop ;
    161                                                  end procedure Set ; 
    162                                              		
    163                                                  ------------------------------------------------------------
    164                                              		procedure Set(Index: in natural; Data: in boolean) is
    165                                                  ------------------------------------------------------------
    166                                              		begin
    167                                                    case ParmPtrVar(Index).ParmType is 
    168                                                      when NONE | eINT =>
    169             1                    ***0***               ParmPtrVar(Index).IParm     := 1 when Data else 0 ;
    170             1                    ***0***               ParmPtrVar(Index).ParmType  := eINT;
    171                                                      
    172                                                      when eSLV =>
    173             1                    ***0***               ParmPtrVar(Index).SParm.all := (ParmPtrVar(Index).SParm'range => '0') ;
    174             1                    ***0***               ParmPtrVar(Index).SParm(0) := '1' when Data else '0';
    175             1                    ***0***               ParmPtrVar(Index).ParmType  := eSLV;
    176                                                    end case ; 
    177                                              		end procedure Set;
    178                                              		
    179                                                  ------------------------------------------------------------
    180                                              		procedure Set(Index: in natural; Data: in integer; len: positive) is
    181                                                  ------------------------------------------------------------
    182                                                    -- to_signed correctly handles non-negative integers up len in length
    183                                                    constant SlvVal : std_logic_vector(len-1 downto 0) := std_logic_vector(to_signed(Data, len));
    184                                              		begin
    185                                                    case ParmPtrVar(Index).ParmType is 
    186                                                      when NONE =>
    187             1                    ***0***               ParmPtrVar(Index).SParm    := new std_logic_vector'(SlvVal);
    188             1                    ***0***               ParmPtrVar(Index).ParmType := eSLV;
    189                                              
    190                                                      when eSLV  =>
    191                                              --? What if parameters do not match in size?
    192             1                    ***0***               ParmPtrVar(Index).SParm.all := resize(SlvVal, ParmPtrVar(Index).SParm'length);
    193                                                      
    194                                                      when eINT =>
    195             1                    ***0***               ParmPtrVar(Index).IParm    := Data;
    196             1                    ***0***               ParmPtrVar(Index).ParmType := eINT;
    197                                                    end case ; 
    198                                              		end procedure Set;
    199                                              
    200                                                  ------------------------------------------------------------
    201                                              		procedure Set(Index: in natural; Data: in std_logic_vector) is
    202                                                  ------------------------------------------------------------
    203                                                    alias aData : std_logic_vector(Data'length-1 downto 0) is Data ; 
    204                                              		begin
    205                                                    case ParmPtrVar(Index).ParmType is 
    206                                                      when NONE =>
    207             1                    ***0***               ParmPtrVar(Index).SParm    := new std_logic_vector'(aData)  ;
    208             1                    ***0***               ParmPtrVar(Index).ParmType := eSLV;
    209                                                      
    210                                                      when eSLV  =>
    211                                              --? What if parameters do not match in size?
    212             1                    ***0***               ParmPtrVar(Index).SParm.all := resize(aData, ParmPtrVar(Index).SParm'length);
    213                                              
    214                                                      when eINT =>
    215             1                    ***0***               ParmPtrVar(Index).IParm    := to_integer(signed(Data));
    216             1                    ***0***               ParmPtrVar(Index).ParmType := eINT;
    217                                                    end case ; 
    218                                              		end procedure Set;
    219                                              		
    220                                                  ------------------------------------------------------------
    221                                              		impure function Get(Index: natural) return integer is
    222                                                  ------------------------------------------------------------
    223                                              		begin
    224                                                    case ParmPtrVar(Index).ParmType is 
    225                                                      when NONE =>
    226             1                    ***0***               alert(AlertLogIDVar, "ModelParametersPType.Get[natural, return integer] No value set");
    227             1                    ***0***               return integer'left;
    228                                                      
    229                                                      when eINT =>
    230             1                    ***0***               return ParmPtrVar(Index).IParm;
    231                                              
    232                                                      when eSLV =>
    233                                              -- std_logic_vector values are unsigned
    234             1                    ***0***               return to_integer(unsigned(ParmPtrVar(Index).SParm.all));
    235                                                    end case ; 
    236                                              		end function Get;
    237                                              		
    238                                                  ------------------------------------------------------------
    239                                              		impure function Get(Index: natural) return boolean is
    240                                                  ------------------------------------------------------------
    241                                              		begin
    242                                                    case ParmPtrVar(Index).ParmType is 
    243                                                      when NONE =>
    244             1                    ***0***               alert(AlertLogIDVar, "ModelParametersPType.Get[natural, return boolean] No value set");
    245             1                    ***0***               return boolean'left;
    246                                                      
    247                                                      when eINT =>
    248             1                    ***0***               return (ParmPtrVar(Index).IParm /= 0);
    249                                              
    250                                                      when eSLV =>
    251             1                    ***0***               return (ParmPtrVar(Index).SParm(0) /= '0');
    252                                                    end case ; 
    253                                              		end function Get;
    254                                              		
    255                                                  ------------------------------------------------------------
    256                                              		impure function Get(Index: natural) return std_logic_vector is
    257                                                  ------------------------------------------------------------
    258                                              		begin
    259                                                    case ParmPtrVar(Index).ParmType is 
    260                                                      when NONE =>
    261             1                    ***0***               alert(AlertLogIDVar, "ModelParametersPType.Get[natural, return std_logic_vector] No value set");
    262             1                    ***0***               return 32SB"U";
    263                                                      
    264                                                      when eINT =>
    265             1                    ***0***               return std_logic_vector(to_signed(ParmPtrVar(Index).IParm, 32));
    266                                              
    267                                                      when eSLV =>
    268             1                    ***0***               return ParmPtrVar(Index).SParm.all;
    269                                                    end case ; 
    270                                              		end function Get;
    271                                              		
    272                                                  ------------------------------------------------------------
    273                                              		impure function Get(Index: natural; len: positive) return std_logic_vector is
    274                                                  ------------------------------------------------------------
    275                                                    constant AllU   : std_logic_vector(len-1 downto 0) := (others => 'U') ; 
    276                                                    variable Result : signed(31 downto 0) ;
    277                                              		begin
    278                                                    case ParmPtrVar(Index).ParmType is 
    279                                                      when NONE =>
    280             1                    ***0***               alert(AlertLogIDVar, "ModelParametersPType.Get[natural, positive return std_logic_vector] No value set");
    281             1                    ***0***               return AllU;
    282                                                      
    283                                                      when eINT =>
    284             1                    ***0***               Result := to_signed(ParmPtrVar(Index).IParm, 32) ;
    285             1                    ***0***               return std_logic_vector(Result(len-1 downto 0));
    286                                              
    287                                                      when eSLV =>
    288             1                    ***0***               return resize(ParmPtrVar(Index).SParm.all, len);
    289                                                    end case ; 
    290                                              		end function Get;
    291                                                  
    292                                                  ------------------------------------------------------------
    293                                                  procedure SetAlertLogID (A : AlertLogIDType) is
    294                                                  ------------------------------------------------------------
    295                                                  begin
    296             1                    ***0***           AlertLogIDVar := A ;
    297                                                  end procedure SetAlertLogID ;
    298                                              
    299                                                  ------------------------------------------------------------
    300                                                  procedure SetAlertLogID(Name : string ; ParentID : AlertLogIDType := ALERTLOG_BASE_ID ; CreateHierarchy : Boolean := TRUE) is
    301                                                  ------------------------------------------------------------
    302                                                  begin
    303             1                    ***0***           AlertLogIDVar := GetAlertLogID(Name, ParentID, CreateHierarchy) ;
    304                                                  end procedure SetAlertLogID ;
    305                                                  
    306                                                  ------------------------------------------------------------
    307                                                  impure function GetAlertLogID return AlertLogIDType is
    308                                                  ------------------------------------------------------------
    309                                                  begin
    310             1                    ***0***           return AlertLogIDVar ; 
    311                                                  end function GetAlertLogID ;
    312                                                  
    313                                              	end protected body ModelParametersPType;
    314                                              	
    315                                              end package body ModelParametersPkg;


=================================================================================
=== File: ../osvvm/Common/src/ModelParametersSingletonPkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        45         0        45     0.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/Common/src/ModelParametersSingletonPkg.vhd --

------------------------------------IF Branch------------------------------------
    161                                  ***0***     Count coming in to IF
    161             1                    ***0***           if ModNumItems > 0 then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    182                                  ***0***     Count coming in to IF
    182             1                    ***0***           if SingletonArrayPtr = NULL then
    184             1                    ***0***           elsif NewNumItems > SingletonArrayPtr'length then
                                         ***0***     All False Count
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------IF Branch------------------------------------
    213                                  ***0***     Count coming in to IF
    213             1                    ***0***           if NameID /= ID_NOT_FOUND.ID then
    216             1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    248                                  ***0***     Count coming in to IF
    248             1                    ***0***     			if SingletonArrayPtr(ID.ID).ParamPtr /= NULL then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    264                                  ***0***     Count coming in to CASE
    265             1                    ***0***             when NONE | eINT =>
    265             2                    ***0***     
    269             1                    ***0***             when eSLV =>
    273             1                    ***0***             when eSTR =>
Branch totals: 0 hits of 4 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    293                                  ***0***     Count coming in to CASE
    294             1                    ***0***             when NONE | eINT =>
    294             2                    ***0***     
    298             1                    ***0***             when eSLV =>
    303             1                    ***0***             when eSTR =>
Branch totals: 0 hits of 4 branches = 0.00%

------------------------------------IF Branch------------------------------------
    295                                  ***0***     Count coming in to IF
    295             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam     := 1 when Data else 0 ;
    295             2                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam     := 1 when Data else 0 ;
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    300                                  ***0***     Count coming in to IF
    300             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam(0) := '1' when Data else '0';
    300             2                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam(0) := '1' when Data else '0';
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    315                                  ***0***     Count coming in to CASE
    316             1                    ***0***             when NONE =>
    320             1                    ***0***             when eSLV  =>
    324             1                    ***0***             when eINT =>
    328             1                    ***0***             when eSTR =>
Branch totals: 0 hits of 4 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    339                                  ***0***     Count coming in to CASE
    340             1                    ***0***             when NONE =>
    344             1                    ***0***             when eSLV  =>
    348             1                    ***0***             when eINT =>
    352             1                    ***0***             when eSTR =>
Branch totals: 0 hits of 4 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    362                                  ***0***     Count coming in to CASE
    363             1                    ***0***             when NONE =>
    367             1                    ***0***             when eINT =>
    370             1                    ***0***             when eSLV =>
    374             1                    ***0***             when eSTR =>
Branch totals: 0 hits of 4 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    385                                  ***0***     Count coming in to CASE
    386             1                    ***0***             when NONE =>
    390             1                    ***0***             when eINT =>
    393             1                    ***0***             when eSLV =>
    396             1                    ***0***             when eSTR =>
Branch totals: 0 hits of 4 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    407                                  ***0***     Count coming in to CASE
    408             1                    ***0***             when NONE =>
    412             1                    ***0***             when eINT =>
    415             1                    ***0***             when eSLV =>
    418             1                    ***0***             when eSTR =>
Branch totals: 0 hits of 4 branches = 0.00%

------------------------------------CASE Branch------------------------------------
    431                                  ***0***     Count coming in to CASE
    432             1                    ***0***             when NONE =>
    436             1                    ***0***             when eINT =>
    440             1                    ***0***             when eSLV =>
    443             1                    ***0***             when eSTR =>
Branch totals: 0 hits of 4 branches = 0.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                     106         4       102     3.77%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/ModelParametersSingletonPkg.vhd --

    1                                                --
    2                                                --  File Name:         ModelParametersSingletonPkg.vhd
    3                                                --  Design Unit Name:  ModelParametersSingletonPkg
    4                                                --  Revision:          OSVVM MODELS STANDARD VERSION
    5                                                --
    6                                                --  Author:      Rob Gaddi  <rgaddi@highlandtechnology.com>
    7                                                --  Company      Highland Technology, Inc.
    8                                                --
    9                                                --  Contributor(s):
    10                                               --     Jim Lewis      jim@synthworks.com
    11                                               --
    12                                               --
    13                                               --  Description:
    14                                               --      Defines ModelParametersPType
    15                                               --
    16                                               --  Revision History:
    17                                               --    Date      Version    Description
    18                                               --    09/2023   2023.09    Made into Singleton
    19                                               --    05/2020   2020.05    Added handling to also store std_logic_vector values
    20                                               --                         Added AlertLogID for error handling
    21                                               --    05/2020   NONE       Refactored from AbstractMmPkg.vhd
    22                                               --                      
    23                                               --
    24                                               --
    25                                               --  This file is part of OSVVM.
    26                                               --
    27                                               --  Copyright (c) 2020 by Highland Technology
    28                                               --  Copyright (c) 2020-2023 by SynthWorks Design Inc.
    29                                               --
    30                                               --
    31                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    32                                               --  you may not use this file except in compliance with the License.
    33                                               --  You may obtain a copy of the License at
    34                                               --
    35                                               --      https://www.apache.org/licenses/LICENSE-2.0
    36                                               --
    37                                               --  Unless required by applicable law or agreed to in writing, software
    38                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    39                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    40                                               --  See the License for the specific language governing permissions and
    41                                               --  limitations under the License.
    42                                               --
    43                                               
    44                                               library ieee;
    45                                               use ieee.std_logic_1164.all;
    46                                               use ieee.numeric_std.all;
    47                                               use ieee.numeric_std_unsigned.all;
    48                                               use std.textio.all ; 
    49                                               
    50                                               library osvvm;
    51                                               context osvvm.OsvvmContext ; 
    52                                               
    53                                               
    54                                               package ModelParametersSingletonPkg is
    55                                               
    56                                                 type ModelParametersIDType is record
    57                                                     ID             : integer_max ;
    58                                                 end record ModelParametersIDType ; 
    59                                                 
    60                                                 constant OSVVM_MODEL_PARAM_ALERTLOG_ID : AlertLogIDType := OSVVM_ALERTLOG_ID ;
    61                                                 
    62                                                 type ModelParametersIDArrayType is array (integer range <>) of ModelParametersIDType ;  
    63                                                 
    64                                                 ------------------------------------------------------------
    65                                                 --- ///////////////////////////////////////////////////////////////////////////
    66                                                 ------------------------------------------------------------
    67                                                 impure function NewID (
    68                                                   Name                : String ;
    69                                                   NumParams           : positive ; 
    70                                                   ParentID            : AlertLogIDType          := OSVVM_MODEL_PARAM_ALERTLOG_ID ;
    71                                                   ReportMode          : AlertLogReportModeType  := DISABLED ;
    72                                                   Search              : NameSearchType          := PRIVATE_NAME ;
    73                                                   PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT
    74                                                 ) return ModelParametersIDType ;
    75                                                 
    76                                                 procedure Init(ID : ModelParametersIDType; NumParams : in positive);
    77                                                 
    78                                                 procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in integer);
    79                                                 procedure Set(ID : ModelParametersIDType; Data:  in integer_vector);
    80                                                 procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in integer; Size: positive);
    81                                                 procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in boolean);
    82                                                 procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in std_logic_vector);
    83                                                 
    84                                                 impure function Get(ID : ModelParametersIDType; Index: natural) return integer;
    85                                                 impure function Get(ID : ModelParametersIDType; Index: natural) return boolean;
    86                                                 impure function Get(ID : ModelParametersIDType; Index: natural) return std_logic_vector;
    87                                                 impure function Get(ID : ModelParametersIDType; Index: natural; Size: natural) return std_logic_vector;
    88                                                 
    89                                                 ------------------------------------------------------------
    90                                                 impure function GetAlertLogID (ID : ModelParametersIDType) return AlertLogIDType ;
    91                                               
    92                                               end package ModelParametersSingletonPkg;
    93                                               
    94                                               package body ModelParametersSingletonPkg is
    95                                               	
    96                                               	type ModelParametersSingletonType is protected
    97                                                   impure function NewID (
    98                                                     Name                : String ;
    99                                                     NumParams           : positive ; 
    100                                                    ParentID            : AlertLogIDType          := OSVVM_MODEL_PARAM_ALERTLOG_ID ;
    101                                                    ReportMode          : AlertLogReportModeType  := DISABLED ;
    102                                                    Search              : NameSearchType          := PRIVATE_NAME ;
    103                                                    PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT
    104                                                  ) return ModelParametersIDType ;
    105                                              
    106                                              		procedure Init(ID : ModelParametersIDType; NumParams : in positive);
    107                                              		
    108                                              		procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in integer);
    109                                              		procedure Set(ID : ModelParametersIDType; Data:  in integer_vector);
    110                                              		procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in integer; Size: positive);
    111                                              		procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in boolean);
    112                                              		procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in std_logic_vector);
    113                                              --		procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in string);
    114                                              		
    115                                              		impure function Get(ID : ModelParametersIDType; Index: natural) return integer;
    116                                              		impure function Get(ID : ModelParametersIDType; Index: natural) return boolean;
    117                                              		impure function Get(ID : ModelParametersIDType; Index: natural) return std_logic_vector;
    118                                                  impure function Get(ID : ModelParametersIDType; Index: natural; Size: natural) return std_logic_vector;
    119                                              --		impure function Get(ID : ModelParametersIDType; Index: natural) return string;
    120                                              
    121                                                  ------------------------------------------------------------
    122                                                  impure function GetAlertLogID(ID : ModelParametersIDType) return AlertLogIDType ;
    123                                              	end protected ModelParametersSingletonType;
    124                                              
    125                                              	type ModelParametersSingletonType is protected body
    126                                              		type SlvPtrType is access std_logic_vector;
    127                                                  
    128                                                  type ParamTypeType is (NONE, eSLV, eINT, eSTR) ; 
    129                                              
    130                                                  type ParameterRecType is record 
    131                                                    ParamType : ParamTypeType ; 
    132                                                    IntParam  : integer ; 
    133                                                    SlvParam  : SlvPtrType ;
    134                                                    StrParam  : Line ;
    135                                                  end record ParameterRecType ; 
    136                                                  type ParameterRecArrayType is array (natural range <>) of ParameterRecType ; 
    137                                              		type ParamPtrType is access ParameterRecArrayType ;
    138                                                  
    139                                                  type SingletonStructType is record
    140                                                    ParamPtr     : ParamPtrType ; 
    141                                                    AlertLogID   : AlertLogIDType ;
    142                                                  end record SingletonStructType ; 
    143                                                  
    144                                                  type     SingletonArrayType    is array (integer range <>) of SingletonStructType ;
    145                                                  type     SingletonArrayPtrType is access SingletonArrayType ;
    146                                              
    147                                                  variable SingletonArrayPtr : SingletonArrayPtrType ;   
    148             1                          1         variable NumItems          : integer := 0 ; 
    149             1                          1         constant MIN_NUM_ITEMS     : integer := 32 ; -- Min amount to resize array
    150             1                          1         variable LocalNameStore    : NameStorePType ;
    151                                              
    152                                                  ------------------------------------------------------------
    153                                                  -- Package Local
    154                                                  function NormalizeArraySize( NewNumItems, MinNumItems : integer ) return integer is
    155                                                  ------------------------------------------------------------
    156                                                    variable NormNumItems : integer ;
    157                                                    variable ModNumItems  : integer ;
    158                                                  begin
    159             1                    ***0***           NormNumItems := NewNumItems ; 
    160             1                    ***0***           ModNumItems  := NewNumItems mod MinNumItems ; 
    161                                                    if ModNumItems > 0 then 
    162             1                    ***0***             NormNumItems := NormNumItems + (MinNumItems - ModNumItems) ; 
    163                                                    end if ; 
    164             1                    ***0***           return NormNumItems ; 
    165                                                  end function NormalizeArraySize ;
    166                                              
    167                                                  ------------------------------------------------------------
    168                                                  -- Package Local
    169                                                  procedure GrowNumberItems (
    170                                                  ------------------------------------------------------------
    171                                                    variable SingletonArrayPtr : InOut SingletonArrayPtrType ;
    172                                                    variable NumItems          : InOut integer ;
    173                                                    constant GrowAmount        : in    integer ;
    174                                                    constant MinNumItems       : in    integer 
    175                                                  ) is
    176                                                    variable oldSingletonArrayPtr : SingletonArrayPtrType ;
    177                                                    variable NewNumItems     : integer ;
    178                                                    variable NewSize         : integer ;
    179                                                  begin
    180             1                    ***0***           NewNumItems := NumItems + GrowAmount ; 
    181             1                    ***0***           NewSize     := NormalizeArraySize(NewNumItems, MinNumItems) ;
    182                                                    if SingletonArrayPtr = NULL then
    183             1                    ***0***             SingletonArrayPtr := new SingletonArrayType(1 to NewSize) ;
    184                                                    elsif NewNumItems > SingletonArrayPtr'length then
    185             1                    ***0***             oldSingletonArrayPtr := SingletonArrayPtr ;
    186             1                    ***0***             SingletonArrayPtr    := new SingletonArrayType(1 to NewSize) ;
    187             1                    ***0***             SingletonArrayPtr.all(1 to NumItems) := oldSingletonArrayPtr.all(1 to NumItems) ;
    188             1                    ***0***             deallocate(oldSingletonArrayPtr) ;
    189                                                    end if ;
    190             1                    ***0***           NumItems := NewNumItems ; 
    191                                                  end procedure GrowNumberItems ;
    192                                              
    193                                                  ------------------------------------------------------------
    194                                                  impure function NewID (
    195                                                  ------------------------------------------------------------
    196                                                    Name                : String ;
    197                                                    NumParams           : positive ; 
    198                                                    ParentID            : AlertLogIDType          := OSVVM_MODEL_PARAM_ALERTLOG_ID ;
    199                                                    ReportMode          : AlertLogReportModeType  := DISABLED ;
    200                                                    Search              : NameSearchType          := PRIVATE_NAME ;
    201                                                    PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT
    202                                                  ) return ModelParametersIDType is
    203                                                    variable NameID              : integer ;
    204                                                    variable ResolvedSearch      : NameSearchType ;
    205                                                    variable ResolvedPrintParent : AlertLogPrintParentType ;
    206                                                    variable NewModelID          : ModelParametersIDType ;
    207                                                  begin
    208             1                    ***0***           ResolvedSearch      := ResolveSearch     (ParentID /= OSVVM_MODEL_PARAM_ALERTLOG_ID, Search) ;
    209             1                    ***0***           ResolvedPrintParent := ResolvePrintParent(ParentID /= OSVVM_MODEL_PARAM_ALERTLOG_ID, PrintParent) ;
    210                                              
    211             1                    ***0***           NameID := LocalNameStore.find(Name, ParentID, ResolvedSearch) ;
    212                                              
    213                                                    if NameID /= ID_NOT_FOUND.ID then
    214             1                    ***0***             NewModelID := (ID => NameID) ;
    215             1                    ***0***             return NewModelID ;
    216                                                    else
    217                                                      -- Add New Item to Singleton to Structure
    218             1                    ***0***             GrowNumberItems(SingletonArrayPtr, NumItems, 1, MIN_NUM_ITEMS) ;
    219             1                    ***0***             NewModelID := (ID => NumItems) ;
    220                                                      -- Create AlertLogID
    221             1                    ***0***             SingletonArrayPtr(NumItems).AlertLogID := NewID(Name, ParentID, ReportMode, ResolvedPrintParent, CreateHierarchy => FALSE) ;
    222                                                      -- Add item to NameStore
    223             1                    ***0***             NameID := LocalNameStore.NewID(Name, ParentID, ResolvedSearch) ;
    224                                                      -- Initialize 
    225             1                    ***0***             Init(NewModelID, NumParams) ; 
    226                                                      -- Check NameStore Index vs NumItems
    227             1                    ***0***             AlertIfNotEqual(SingletonArrayPtr(NumItems).AlertLogID, NameID, NumItems, "NewID: NewID /= NameStoreID") ;  
    228             1                    ***0***             return NewModelID ; 
    229                                                    end if ;
    230                                                  end function NewID ;
    231                                              	
    232                                                  ------------------------------------------------------------
    233                                                  procedure Deallocate(ID : ModelParametersIDType) is
    234                                                  ------------------------------------------------------------
    235                                                  begin
    236             1                    ***0***           for i in SingletonArrayPtr(ID.ID).ParamPtr'range loop  
    236             2                    ***0***     
    237             1                    ***0***             deallocate(SingletonArrayPtr(ID.ID).ParamPtr(i).SlvParam) ;
    238             1                    ***0***             deallocate(SingletonArrayPtr(ID.ID).ParamPtr(i).StrParam) ;
    239             1                    ***0***           end loop ;
    240             1                    ***0***           deallocate(SingletonArrayPtr(ID.ID).ParamPtr);
    241                                                  end procedure Deallocate ; 
    242                                                  
    243                                                  ------------------------------------------------------------
    244                                              		--	Create storage for NumParams parameters
    245                                              		procedure Init(ID : ModelParametersIDType; NumParams : in positive) is
    246                                                  ------------------------------------------------------------
    247                                              		begin
    248                                              			if SingletonArrayPtr(ID.ID).ParamPtr /= NULL then
    249                                              -- probably a mistake to do this
    250                                              -- Should instead do a resize of the structure like in ScoreboardPkg.
    251             1                    ***0***             Deallocate(SingletonArrayPtr(ID.ID).ParamPtr) ; 
    252                                                    end if; 
    253             1                    ***0***     			SingletonArrayPtr(ID.ID).ParamPtr := new ParameterRecArrayType(0 to NumParams-1);
    254             1                    ***0***     			for i in SingletonArrayPtr(ID.ID).ParamPtr'range loop
    254             2                    ***0***     
    255             1                    ***0***     				SingletonArrayPtr(ID.ID).ParamPtr(i).IntParam := 0;
    256             1                    ***0***     			end loop;
    257                                              		end procedure Init;
    258                                              		
    259                                              		
    260                                                  ------------------------------------------------------------
    261                                              		procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in integer) is
    262                                                  ------------------------------------------------------------
    263                                              		begin
    264                                                    case SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType is 
    265                                                      when NONE | eINT =>
    266             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam     := Data;
    267             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType  := eINT;
    268                                                      
    269                                                      when eSLV =>
    270             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam.all := std_logic_vector(to_signed(Data, SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam'length));
    271             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType  := eSLV;
    272                                              
    273                                                      when eSTR =>
    274             1                    ***0***               Alert(SingletonArrayPtr(ID.ID).AlertLogID, "Set: Require Type String") ; 
    275                                              
    276                                                    end case ; 
    277                                                  end procedure Set;
    278                                              		
    279                                                  ------------------------------------------------------------
    280                                              		procedure Set(ID : ModelParametersIDType; Data: in integer_vector) is
    281                                                  ------------------------------------------------------------
    282                                                    alias aData : integer_vector(0 to Data'length -1) is Data ; 
    283                                              		begin
    284             1                    ***0***           for i in aData'range loop 
    284             2                    ***0***     
    285             1                    ***0***             Set(ID, i, aData(i)) ; 
    286             1                    ***0***           end loop ;
    287                                                  end procedure Set ; 
    288                                              		
    289                                                  ------------------------------------------------------------
    290                                              		procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in boolean) is
    291                                                  ------------------------------------------------------------
    292                                              		begin
    293                                                    case SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType is 
    294                                                      when NONE | eINT =>
    295             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam     := 1 when Data else 0 ;
    296             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType  := eINT;
    297                                                      
    298                                                      when eSLV =>
    299             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam.all := (SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam'range => '0') ;
    300             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam(0) := '1' when Data else '0';
    301             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType  := eSLV;
    302                                              
    303                                                      when eSTR =>
    304             1                    ***0***               Alert(SingletonArrayPtr(ID.ID).AlertLogID, "Set: Require Type String") ; 
    305                                              
    306                                                    end case ; 
    307                                              		end procedure Set;
    308                                              		
    309                                                  ------------------------------------------------------------
    310                                              		procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in integer; Size: positive) is
    311                                                  ------------------------------------------------------------
    312                                                    -- to_signed correctly handles non-negative integers up Size in length
    313                                                    constant SlvVal : std_logic_vector(Size-1 downto 0) := std_logic_vector(to_signed(Data, Size));
    314                                              		begin
    315                                                    case SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType is 
    316                                                      when NONE =>
    317             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam    := new std_logic_vector'(SlvVal);
    318             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType := eSLV;
    319                                              
    320                                                      when eSLV  =>
    321                                              --? What if parameters do not match in size?
    322             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam.all := resize(SlvVal, SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam'length);
    323                                                      
    324                                                      when eINT =>
    325             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam    := Data;
    326             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType   := eINT;
    327                                              
    328                                                      when eSTR =>
    329             1                    ***0***               Alert(SingletonArrayPtr(ID.ID).AlertLogID, "Set: Require Type String") ; 
    330                                              
    331                                                    end case ; 
    332                                              		end procedure Set;
    333                                              
    334                                                  ------------------------------------------------------------
    335                                              		procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in std_logic_vector) is
    336                                                  ------------------------------------------------------------
    337                                                    alias aData : std_logic_vector(Data'length-1 downto 0) is Data ; 
    338                                              		begin
    339                                                    case SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType is 
    340                                                      when NONE =>
    341             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam    := new std_logic_vector'(aData)  ;
    342             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType := eSLV;
    343                                                      
    344                                                      when eSLV  =>
    345                                              --? What if parameters do not match in size?
    346             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam.all := resize(aData, SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam'length);
    347                                              
    348                                                      when eINT =>
    349             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam    := to_integer(signed(Data));
    350             1                    ***0***               SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType := eINT;
    351                                              
    352                                                      when eSTR =>
    353             1                    ***0***               Alert(SingletonArrayPtr(ID.ID).AlertLogID, "Set: Require Type String") ; 
    354                                              
    355                                                    end case ; 
    356                                              		end procedure Set;
    357                                              		
    358                                                  ------------------------------------------------------------
    359                                              		impure function Get(ID : ModelParametersIDType; Index: natural) return integer is
    360                                                  ------------------------------------------------------------
    361                                              		begin
    362                                                    case SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType is 
    363                                                      when NONE =>
    364             1                    ***0***               alert(SingletonArrayPtr(ID.ID).AlertLogID, "ModelParametersSingletonType.Get[natural, return integer] No value set");
    365             1                    ***0***               return integer'left;
    366                                                      
    367                                                      when eINT =>
    368             1                    ***0***               return SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam;
    369                                              
    370                                                      when eSLV =>
    371                                              -- std_logic_vector values are unsigned
    372             1                    ***0***               return to_integer(unsigned(SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam.all));
    373                                              
    374                                                      when eSTR =>
    375             1                    ***0***               Alert(SingletonArrayPtr(ID.ID).AlertLogID, "Expecting Type String") ; 
    376             1                    ***0***               return integer'left;
    377                                              
    378                                                    end case ; 
    379                                              		end function Get;
    380                                              		
    381                                                  ------------------------------------------------------------
    382                                              		impure function Get(ID : ModelParametersIDType; Index: natural) return boolean is
    383                                                  ------------------------------------------------------------
    384                                              		begin
    385                                                    case SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType is 
    386                                                      when NONE =>
    387             1                    ***0***               alert(SingletonArrayPtr(ID.ID).AlertLogID, "ModelParametersSingletonType.Get[natural, return boolean] No value set");
    388             1                    ***0***               return boolean'left;
    389                                                      
    390                                                      when eINT =>
    391             1                    ***0***               return (SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam /= 0);
    392                                              
    393                                                      when eSLV =>
    394             1                    ***0***               return (SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam(0) /= '0');
    395                                              
    396                                                      when eSTR =>
    397             1                    ***0***               Alert(SingletonArrayPtr(ID.ID).AlertLogID, "Expecting Type String") ; 
    398             1                    ***0***               return boolean'left;
    399                                              
    400                                                    end case ; 
    401                                              		end function Get;
    402                                              		
    403                                                  ------------------------------------------------------------
    404                                              		impure function Get(ID : ModelParametersIDType; Index: natural) return std_logic_vector is
    405                                                  ------------------------------------------------------------
    406                                              		begin
    407                                                    case SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType is 
    408                                                      when NONE =>
    409             1                    ***0***               alert(SingletonArrayPtr(ID.ID).AlertLogID, "ModelParametersSingletonType.Get[natural, return std_logic_vector] No value set");
    410             1                    ***0***               return 32SB"U";
    411                                                      
    412                                                      when eINT =>
    413             1                    ***0***               return std_logic_vector(to_signed(SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam, 32));
    414                                              
    415                                                      when eSLV =>
    416             1                    ***0***               return SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam.all;
    417                                              
    418                                                      when eSTR =>
    419             1                    ***0***               Alert(SingletonArrayPtr(ID.ID).AlertLogID, "Expecting Type String") ; 
    420             1                    ***0***               return 32SB"U";
    421                                              
    422                                                    end case ; 
    423                                              		end function Get;
    424                                              		
    425                                                  ------------------------------------------------------------
    426                                                  impure function Get(ID : ModelParametersIDType; Index: natural; Size: natural) return std_logic_vector is
    427                                                  ------------------------------------------------------------
    428                                                    constant AllU   : std_logic_vector(Size-1 downto 0) := (others => 'U') ; 
    429                                                    variable Result : signed(31 downto 0) ;
    430                                              		begin
    431                                                    case SingletonArrayPtr(ID.ID).ParamPtr(Index).ParamType is 
    432                                                      when NONE =>
    433             1                    ***0***               alert(SingletonArrayPtr(ID.ID).AlertLogID, "ModelParametersSingletonType.Get[natural, positive return std_logic_vector] No value set");
    434             1                    ***0***               return AllU;
    435                                                      
    436                                                      when eINT =>
    437             1                    ***0***               Result := to_signed(SingletonArrayPtr(ID.ID).ParamPtr(Index).IntParam, 32) ;
    438             1                    ***0***               return std_logic_vector(Result(Size-1 downto 0));
    439                                              
    440                                                      when eSLV =>
    441             1                    ***0***               return resize(SingletonArrayPtr(ID.ID).ParamPtr(Index).SlvParam.all, Size);
    442                                              
    443                                                      when eSTR =>
    444             1                    ***0***               Alert(SingletonArrayPtr(ID.ID).AlertLogID, "Expecting Type String") ; 
    445             1                    ***0***               return AllU;
    446                                              
    447                                                    end case ; 
    448                                              		end function Get;
    449                                                  
    450                                                  ------------------------------------------------------------
    451                                                  impure function GetAlertLogID(ID : ModelParametersIDType) return AlertLogIDType is
    452                                                  ------------------------------------------------------------
    453                                                  begin
    454             1                    ***0***           return SingletonArrayPtr(ID.ID).AlertLogID ; 
    455                                                  end function GetAlertLogID ;
    456                                                  
    457                                              				
    458             1                          1     	end protected body ModelParametersSingletonType;
    459                                                
    460                                              -- /////////////////////////////////////////
    461                                              -- /////////////////////////////////////////
    462                                              -- Singleton Data Structure
    463                                              -- /////////////////////////////////////////
    464                                              -- /////////////////////////////////////////
    465                                                shared variable ModelParameters : ModelParametersSingletonType ;
    466                                               
    467                                                impure function NewID (
    468                                                  Name                : String ;
    469                                                  NumParams           : positive ; 
    470                                                  ParentID            : AlertLogIDType          := OSVVM_MODEL_PARAM_ALERTLOG_ID ;
    471                                                  ReportMode          : AlertLogReportModeType  := DISABLED ;
    472                                                  Search              : NameSearchType          := PRIVATE_NAME ;
    473                                                  PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT
    474                                                ) return ModelParametersIDType is
    475                                                  variable Result : ModelParametersIDType ; 
    476                                                begin
    477             1                    ***0***         Result := ModelParameters.NewID(Name, NumParams, ParentID, ReportMode, Search, PrintParent) ; 
    478             1                    ***0***         return Result ; 
    479                                                end function NewID ; 
    480                                                
    481                                                procedure Init(ID : ModelParametersIDType; NumParams : in positive) is
    482                                                begin
    483             1                    ***0***         ModelParameters.Init(ID, NumParams) ; 
    484                                                end procedure Init ;
    485                                                
    486                                                procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in integer) is
    487                                                begin
    488             1                    ***0***         ModelParameters.Set(ID, Index, Data) ; 
    489                                                end procedure Set ; 
    490                                                
    491                                                procedure Set(ID : ModelParametersIDType; Data: in integer_vector) is
    492                                                begin
    493             1                    ***0***         ModelParameters.Set(ID, Data) ; 
    494                                                end procedure Set ; 
    495                                              
    496                                                procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in integer; Size: positive) is
    497                                                begin
    498             1                    ***0***         ModelParameters.Set(ID, Index, Data, Size) ; 
    499                                                end procedure Set ; 
    500                                                
    501                                                procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in boolean) is
    502                                                begin
    503             1                    ***0***         ModelParameters.Set(ID, Index, Data) ; 
    504                                                end procedure Set ; 
    505                                                
    506                                                procedure Set(ID : ModelParametersIDType; Index: in natural; Data: in std_logic_vector) is
    507                                                begin
    508             1                    ***0***         ModelParameters.Set(ID, Index, Data) ; 
    509                                                end procedure Set ; 
    510                                                
    511                                                
    512                                                impure function Get(ID : ModelParametersIDType; Index: natural) return integer is
    513                                                begin
    514             1                    ***0***         return ModelParameters.Get(ID, Index) ; 
    515                                                end function Get ; 
    516                                                
    517                                                impure function Get(ID : ModelParametersIDType; Index: natural) return boolean is
    518                                                begin
    519             1                    ***0***         return ModelParameters.Get(ID, Index) ; 
    520                                                end function Get ; 
    521                                                
    522                                                impure function Get(ID : ModelParametersIDType; Index: natural) return std_logic_vector is
    523                                                begin
    524             1                    ***0***         return ModelParameters.Get(ID, Index) ; 
    525                                                end function Get ; 
    526                                                
    527                                                impure function Get(ID : ModelParametersIDType; Index: natural; Size: natural) return std_logic_vector is
    528                                                begin
    529             1                    ***0***         return ModelParameters.Get(ID, Index, Size) ; 
    530                                                end function Get ; 
    531                                                
    532                                                
    533                                                ------------------------------------------------------------
    534                                                impure function GetAlertLogID (ID : ModelParametersIDType) return AlertLogIDType  is
    535                                                begin
    536             1                    ***0***         return ModelParameters.GetAlertLogID(ID) ; 
    537                                                end function GetAlertLogID ; 
    538                                                
    539                                              	
    540                                              end package body ModelParametersSingletonPkg;


=================================================================================
=== File: ../osvvm/Common/src/StreamTransactionArrayPkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                       141         0       141     0.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/Common/src/StreamTransactionArrayPkg.vhd --

------------------------------------CASE Branch------------------------------------
    1122                                 ***0***     Count coming in to CASE
    1123            1                    ***0***           when  0 =>  RequestTransaction(Rdy => TransactionRec( 0).Rdy, Ack => TransactionRec( 0).Ack) ; 
    1124            1                    ***0***           when  1 =>  RequestTransaction(Rdy => TransactionRec( 1).Rdy, Ack => TransactionRec( 1).Ack) ; 
    1125            1                    ***0***           when  2 =>  RequestTransaction(Rdy => TransactionRec( 2).Rdy, Ack => TransactionRec( 2).Ack) ; 
    1126            1                    ***0***           when  3 =>  RequestTransaction(Rdy => TransactionRec( 3).Rdy, Ack => TransactionRec( 3).Ack) ; 
    1127            1                    ***0***           when  4 =>  RequestTransaction(Rdy => TransactionRec( 4).Rdy, Ack => TransactionRec( 4).Ack) ; 
    1128            1                    ***0***           when  5 =>  RequestTransaction(Rdy => TransactionRec( 5).Rdy, Ack => TransactionRec( 5).Ack) ; 
    1129            1                    ***0***           when  6 =>  RequestTransaction(Rdy => TransactionRec( 6).Rdy, Ack => TransactionRec( 6).Ack) ; 
    1130            1                    ***0***           when  7 =>  RequestTransaction(Rdy => TransactionRec( 7).Rdy, Ack => TransactionRec( 7).Ack) ; 
    1131            1                    ***0***           when  8 =>  RequestTransaction(Rdy => TransactionRec( 8).Rdy, Ack => TransactionRec( 8).Ack) ; 
    1132            1                    ***0***           when  9 =>  RequestTransaction(Rdy => TransactionRec( 9).Rdy, Ack => TransactionRec( 9).Ack) ; 
    1133            1                    ***0***           when 10 =>  RequestTransaction(Rdy => TransactionRec(10).Rdy, Ack => TransactionRec(10).Ack) ; 
    1134            1                    ***0***           when 11 =>  RequestTransaction(Rdy => TransactionRec(11).Rdy, Ack => TransactionRec(11).Ack) ; 
    1135            1                    ***0***           when 12 =>  RequestTransaction(Rdy => TransactionRec(12).Rdy, Ack => TransactionRec(12).Ack) ; 
    1136            1                    ***0***           when 13 =>  RequestTransaction(Rdy => TransactionRec(13).Rdy, Ack => TransactionRec(13).Ack) ; 
    1137            1                    ***0***           when 14 =>  RequestTransaction(Rdy => TransactionRec(14).Rdy, Ack => TransactionRec(14).Ack) ; 
    1138            1                    ***0***           when 15 =>  RequestTransaction(Rdy => TransactionRec(15).Rdy, Ack => TransactionRec(15).Ack) ; 
    1139            1                    ***0***           when 16 =>  RequestTransaction(Rdy => TransactionRec(16).Rdy, Ack => TransactionRec(16).Ack) ; 
    1140            1                    ***0***           when 17 =>  RequestTransaction(Rdy => TransactionRec(17).Rdy, Ack => TransactionRec(17).Ack) ; 
    1141            1                    ***0***           when 18 =>  RequestTransaction(Rdy => TransactionRec(18).Rdy, Ack => TransactionRec(18).Ack) ; 
    1142            1                    ***0***           when 19 =>  RequestTransaction(Rdy => TransactionRec(19).Rdy, Ack => TransactionRec(19).Ack) ; 
    1143            1                    ***0***           when 20 =>  RequestTransaction(Rdy => TransactionRec(20).Rdy, Ack => TransactionRec(20).Ack) ; 
    1144            1                    ***0***           when 21 =>  RequestTransaction(Rdy => TransactionRec(21).Rdy, Ack => TransactionRec(21).Ack) ; 
    1145            1                    ***0***           when 22 =>  RequestTransaction(Rdy => TransactionRec(22).Rdy, Ack => TransactionRec(22).Ack) ; 
    1146            1                    ***0***           when 23 =>  RequestTransaction(Rdy => TransactionRec(23).Rdy, Ack => TransactionRec(23).Ack) ; 
    1147            1                    ***0***           when 24 =>  RequestTransaction(Rdy => TransactionRec(24).Rdy, Ack => TransactionRec(24).Ack) ; 
    1148            1                    ***0***           when 25 =>  RequestTransaction(Rdy => TransactionRec(25).Rdy, Ack => TransactionRec(25).Ack) ; 
    1149            1                    ***0***           when 26 =>  RequestTransaction(Rdy => TransactionRec(26).Rdy, Ack => TransactionRec(26).Ack) ; 
    1150            1                    ***0***           when 27 =>  RequestTransaction(Rdy => TransactionRec(27).Rdy, Ack => TransactionRec(27).Ack) ; 
    1151            1                    ***0***           when 28 =>  RequestTransaction(Rdy => TransactionRec(28).Rdy, Ack => TransactionRec(28).Ack) ; 
    1152            1                    ***0***           when 29 =>  RequestTransaction(Rdy => TransactionRec(29).Rdy, Ack => TransactionRec(29).Ack) ; 
    1153            1                    ***0***           when 30 =>  RequestTransaction(Rdy => TransactionRec(30).Rdy, Ack => TransactionRec(30).Ack) ; 
    1154            1                    ***0***           when 31 =>  RequestTransaction(Rdy => TransactionRec(31).Rdy, Ack => TransactionRec(31).Ack) ; 
    1155            1                    ***0***           when 32 =>  RequestTransaction(Rdy => TransactionRec(32).Rdy, Ack => TransactionRec(32).Ack) ; 
    1156            1                    ***0***           when 33 =>  RequestTransaction(Rdy => TransactionRec(33).Rdy, Ack => TransactionRec(33).Ack) ; 
    1157            1                    ***0***           when 34 =>  RequestTransaction(Rdy => TransactionRec(34).Rdy, Ack => TransactionRec(34).Ack) ; 
    1158            1                    ***0***           when 35 =>  RequestTransaction(Rdy => TransactionRec(35).Rdy, Ack => TransactionRec(35).Ack) ; 
    1159            1                    ***0***           when 36 =>  RequestTransaction(Rdy => TransactionRec(36).Rdy, Ack => TransactionRec(36).Ack) ; 
    1160            1                    ***0***           when 37 =>  RequestTransaction(Rdy => TransactionRec(37).Rdy, Ack => TransactionRec(37).Ack) ; 
    1161            1                    ***0***           when 38 =>  RequestTransaction(Rdy => TransactionRec(38).Rdy, Ack => TransactionRec(38).Ack) ; 
    1162            1                    ***0***           when 39 =>  RequestTransaction(Rdy => TransactionRec(39).Rdy, Ack => TransactionRec(39).Ack) ; 
    1163            1                    ***0***           when 40 =>  RequestTransaction(Rdy => TransactionRec(40).Rdy, Ack => TransactionRec(40).Ack) ; 
    1164            1                    ***0***           when 41 =>  RequestTransaction(Rdy => TransactionRec(41).Rdy, Ack => TransactionRec(41).Ack) ; 
    1165            1                    ***0***           when 42 =>  RequestTransaction(Rdy => TransactionRec(42).Rdy, Ack => TransactionRec(42).Ack) ; 
    1166            1                    ***0***           when 43 =>  RequestTransaction(Rdy => TransactionRec(43).Rdy, Ack => TransactionRec(43).Ack) ; 
    1167            1                    ***0***           when 44 =>  RequestTransaction(Rdy => TransactionRec(44).Rdy, Ack => TransactionRec(44).Ack) ; 
    1168            1                    ***0***           when 45 =>  RequestTransaction(Rdy => TransactionRec(45).Rdy, Ack => TransactionRec(45).Ack) ; 
    1169            1                    ***0***           when 46 =>  RequestTransaction(Rdy => TransactionRec(46).Rdy, Ack => TransactionRec(46).Ack) ; 
    1170            1                    ***0***           when 47 =>  RequestTransaction(Rdy => TransactionRec(47).Rdy, Ack => TransactionRec(47).Ack) ; 
    1171            1                    ***0***           when 48 =>  RequestTransaction(Rdy => TransactionRec(48).Rdy, Ack => TransactionRec(48).Ack) ; 
    1172            1                    ***0***           when 49 =>  RequestTransaction(Rdy => TransactionRec(49).Rdy, Ack => TransactionRec(49).Ack) ; 
    1173            1                    ***0***           when 50 =>  RequestTransaction(Rdy => TransactionRec(50).Rdy, Ack => TransactionRec(50).Ack) ; 
    1174            1                    ***0***           when 51 =>  RequestTransaction(Rdy => TransactionRec(51).Rdy, Ack => TransactionRec(51).Ack) ; 
    1175            1                    ***0***           when 52 =>  RequestTransaction(Rdy => TransactionRec(52).Rdy, Ack => TransactionRec(52).Ack) ; 
    1176            1                    ***0***           when 53 =>  RequestTransaction(Rdy => TransactionRec(53).Rdy, Ack => TransactionRec(53).Ack) ; 
    1177            1                    ***0***           when 54 =>  RequestTransaction(Rdy => TransactionRec(54).Rdy, Ack => TransactionRec(54).Ack) ; 
    1178            1                    ***0***           when 55 =>  RequestTransaction(Rdy => TransactionRec(55).Rdy, Ack => TransactionRec(55).Ack) ; 
    1179            1                    ***0***           when 56 =>  RequestTransaction(Rdy => TransactionRec(56).Rdy, Ack => TransactionRec(56).Ack) ; 
    1180            1                    ***0***           when 57 =>  RequestTransaction(Rdy => TransactionRec(57).Rdy, Ack => TransactionRec(57).Ack) ; 
    1181            1                    ***0***           when 58 =>  RequestTransaction(Rdy => TransactionRec(58).Rdy, Ack => TransactionRec(58).Ack) ; 
    1182            1                    ***0***           when 59 =>  RequestTransaction(Rdy => TransactionRec(59).Rdy, Ack => TransactionRec(59).Ack) ; 
    1183            1                    ***0***           when 60 =>  RequestTransaction(Rdy => TransactionRec(60).Rdy, Ack => TransactionRec(60).Ack) ; 
    1184            1                    ***0***           when 61 =>  RequestTransaction(Rdy => TransactionRec(61).Rdy, Ack => TransactionRec(61).Ack) ; 
    1185            1                    ***0***           when 62 =>  RequestTransaction(Rdy => TransactionRec(62).Rdy, Ack => TransactionRec(62).Ack) ; 
    1186            1                    ***0***           when 63 =>  RequestTransaction(Rdy => TransactionRec(63).Rdy, Ack => TransactionRec(63).Ack) ; 
    1187            1                    ***0***           when 64 =>  RequestTransaction(Rdy => TransactionRec(64).Rdy, Ack => TransactionRec(64).Ack) ; 
    1188            1                    ***0***           when 65 =>  RequestTransaction(Rdy => TransactionRec(65).Rdy, Ack => TransactionRec(65).Ack) ; 
    1189            1                    ***0***           when 66 =>  RequestTransaction(Rdy => TransactionRec(66).Rdy, Ack => TransactionRec(66).Ack) ; 
    1190            1                    ***0***           when 67 =>  RequestTransaction(Rdy => TransactionRec(67).Rdy, Ack => TransactionRec(67).Ack) ; 
    1191            1                    ***0***           when 68 =>  RequestTransaction(Rdy => TransactionRec(68).Rdy, Ack => TransactionRec(68).Ack) ; 
    1192            1                    ***0***           when 69 =>  RequestTransaction(Rdy => TransactionRec(69).Rdy, Ack => TransactionRec(69).Ack) ; 
    1193            1                    ***0***           when 70 =>  RequestTransaction(Rdy => TransactionRec(70).Rdy, Ack => TransactionRec(70).Ack) ; 
    1194            1                    ***0***           when 71 =>  RequestTransaction(Rdy => TransactionRec(71).Rdy, Ack => TransactionRec(71).Ack) ; 
    1195            1                    ***0***           when 72 =>  RequestTransaction(Rdy => TransactionRec(72).Rdy, Ack => TransactionRec(72).Ack) ; 
    1196            1                    ***0***           when 73 =>  RequestTransaction(Rdy => TransactionRec(73).Rdy, Ack => TransactionRec(73).Ack) ; 
    1197            1                    ***0***           when 74 =>  RequestTransaction(Rdy => TransactionRec(74).Rdy, Ack => TransactionRec(74).Ack) ; 
    1198            1                    ***0***           when 75 =>  RequestTransaction(Rdy => TransactionRec(75).Rdy, Ack => TransactionRec(75).Ack) ; 
    1199            1                    ***0***           when 76 =>  RequestTransaction(Rdy => TransactionRec(76).Rdy, Ack => TransactionRec(76).Ack) ; 
    1200            1                    ***0***           when 77 =>  RequestTransaction(Rdy => TransactionRec(77).Rdy, Ack => TransactionRec(77).Ack) ; 
    1201            1                    ***0***           when 78 =>  RequestTransaction(Rdy => TransactionRec(78).Rdy, Ack => TransactionRec(78).Ack) ; 
    1202            1                    ***0***           when 79 =>  RequestTransaction(Rdy => TransactionRec(79).Rdy, Ack => TransactionRec(79).Ack) ; 
    1203            1                    ***0***           when 80 =>  RequestTransaction(Rdy => TransactionRec(80).Rdy, Ack => TransactionRec(80).Ack) ; 
    1204            1                    ***0***           when 81 =>  RequestTransaction(Rdy => TransactionRec(81).Rdy, Ack => TransactionRec(81).Ack) ; 
    1205            1                    ***0***           when 82 =>  RequestTransaction(Rdy => TransactionRec(82).Rdy, Ack => TransactionRec(82).Ack) ; 
    1206            1                    ***0***           when 83 =>  RequestTransaction(Rdy => TransactionRec(83).Rdy, Ack => TransactionRec(83).Ack) ; 
    1207            1                    ***0***           when 84 =>  RequestTransaction(Rdy => TransactionRec(84).Rdy, Ack => TransactionRec(84).Ack) ; 
    1208            1                    ***0***           when 85 =>  RequestTransaction(Rdy => TransactionRec(85).Rdy, Ack => TransactionRec(85).Ack) ; 
    1209            1                    ***0***           when 86 =>  RequestTransaction(Rdy => TransactionRec(86).Rdy, Ack => TransactionRec(86).Ack) ; 
    1210            1                    ***0***           when 87 =>  RequestTransaction(Rdy => TransactionRec(87).Rdy, Ack => TransactionRec(87).Ack) ; 
    1211            1                    ***0***           when 88 =>  RequestTransaction(Rdy => TransactionRec(88).Rdy, Ack => TransactionRec(88).Ack) ; 
    1212            1                    ***0***           when 89 =>  RequestTransaction(Rdy => TransactionRec(89).Rdy, Ack => TransactionRec(89).Ack) ; 
    1213            1                    ***0***           when 90 =>  RequestTransaction(Rdy => TransactionRec(90).Rdy, Ack => TransactionRec(90).Ack) ; 
    1214            1                    ***0***           when 91 =>  RequestTransaction(Rdy => TransactionRec(91).Rdy, Ack => TransactionRec(91).Ack) ; 
    1215            1                    ***0***           when 92 =>  RequestTransaction(Rdy => TransactionRec(92).Rdy, Ack => TransactionRec(92).Ack) ; 
    1216            1                    ***0***           when 93 =>  RequestTransaction(Rdy => TransactionRec(93).Rdy, Ack => TransactionRec(93).Ack) ; 
    1217            1                    ***0***           when 94 =>  RequestTransaction(Rdy => TransactionRec(94).Rdy, Ack => TransactionRec(94).Ack) ; 
    1218            1                    ***0***           when 95 =>  RequestTransaction(Rdy => TransactionRec(95).Rdy, Ack => TransactionRec(95).Ack) ; 
    1219            1                    ***0***           when 96 =>  RequestTransaction(Rdy => TransactionRec(96).Rdy, Ack => TransactionRec(96).Ack) ; 
    1220            1                    ***0***           when 97 =>  RequestTransaction(Rdy => TransactionRec(97).Rdy, Ack => TransactionRec(97).Ack) ; 
    1221            1                    ***0***           when 98 =>  RequestTransaction(Rdy => TransactionRec(98).Rdy, Ack => TransactionRec(98).Ack) ; 
    1222            1                    ***0***           when 99 =>  RequestTransaction(Rdy => TransactionRec(99).Rdy, Ack => TransactionRec(99).Ack) ; 
    1223            1                    ***0***           when 100 =>  RequestTransaction(Rdy => TransactionRec(100).Rdy, Ack => TransactionRec(100).Ack) ; 
    1224            1                    ***0***           when 101 =>  RequestTransaction(Rdy => TransactionRec(101).Rdy, Ack => TransactionRec(101).Ack) ; 
    1225            1                    ***0***           when 102 =>  RequestTransaction(Rdy => TransactionRec(102).Rdy, Ack => TransactionRec(102).Ack) ; 
    1226            1                    ***0***           when 103 =>  RequestTransaction(Rdy => TransactionRec(103).Rdy, Ack => TransactionRec(103).Ack) ; 
    1227            1                    ***0***           when 104 =>  RequestTransaction(Rdy => TransactionRec(104).Rdy, Ack => TransactionRec(104).Ack) ; 
    1228            1                    ***0***           when 105 =>  RequestTransaction(Rdy => TransactionRec(105).Rdy, Ack => TransactionRec(105).Ack) ; 
    1229            1                    ***0***           when 106 =>  RequestTransaction(Rdy => TransactionRec(106).Rdy, Ack => TransactionRec(106).Ack) ; 
    1230            1                    ***0***           when 107 =>  RequestTransaction(Rdy => TransactionRec(107).Rdy, Ack => TransactionRec(107).Ack) ; 
    1231            1                    ***0***           when 108 =>  RequestTransaction(Rdy => TransactionRec(108).Rdy, Ack => TransactionRec(108).Ack) ; 
    1232            1                    ***0***           when 109 =>  RequestTransaction(Rdy => TransactionRec(109).Rdy, Ack => TransactionRec(109).Ack) ; 
    1233            1                    ***0***           when 110 =>  RequestTransaction(Rdy => TransactionRec(110).Rdy, Ack => TransactionRec(110).Ack) ; 
    1234            1                    ***0***           when 111 =>  RequestTransaction(Rdy => TransactionRec(111).Rdy, Ack => TransactionRec(111).Ack) ; 
    1235            1                    ***0***           when 112 =>  RequestTransaction(Rdy => TransactionRec(112).Rdy, Ack => TransactionRec(112).Ack) ; 
    1236            1                    ***0***           when 113 =>  RequestTransaction(Rdy => TransactionRec(113).Rdy, Ack => TransactionRec(113).Ack) ; 
    1237            1                    ***0***           when 114 =>  RequestTransaction(Rdy => TransactionRec(114).Rdy, Ack => TransactionRec(114).Ack) ; 
    1238            1                    ***0***           when 115 =>  RequestTransaction(Rdy => TransactionRec(115).Rdy, Ack => TransactionRec(115).Ack) ; 
    1239            1                    ***0***           when 116 =>  RequestTransaction(Rdy => TransactionRec(116).Rdy, Ack => TransactionRec(116).Ack) ; 
    1240            1                    ***0***           when 117 =>  RequestTransaction(Rdy => TransactionRec(117).Rdy, Ack => TransactionRec(117).Ack) ; 
    1241            1                    ***0***           when 118 =>  RequestTransaction(Rdy => TransactionRec(118).Rdy, Ack => TransactionRec(118).Ack) ; 
    1242            1                    ***0***           when 119 =>  RequestTransaction(Rdy => TransactionRec(119).Rdy, Ack => TransactionRec(119).Ack) ; 
    1243            1                    ***0***           when 120 =>  RequestTransaction(Rdy => TransactionRec(120).Rdy, Ack => TransactionRec(120).Ack) ; 
    1244            1                    ***0***           when 121 =>  RequestTransaction(Rdy => TransactionRec(121).Rdy, Ack => TransactionRec(121).Ack) ; 
    1245            1                    ***0***           when 122 =>  RequestTransaction(Rdy => TransactionRec(122).Rdy, Ack => TransactionRec(122).Ack) ; 
    1246            1                    ***0***           when 123 =>  RequestTransaction(Rdy => TransactionRec(123).Rdy, Ack => TransactionRec(123).Ack) ; 
    1247            1                    ***0***           when 124 =>  RequestTransaction(Rdy => TransactionRec(124).Rdy, Ack => TransactionRec(124).Ack) ; 
    1248            1                    ***0***           when 125 =>  RequestTransaction(Rdy => TransactionRec(125).Rdy, Ack => TransactionRec(125).Ack) ; 
    1249            1                    ***0***           when 126 =>  RequestTransaction(Rdy => TransactionRec(126).Rdy, Ack => TransactionRec(126).Ack) ; 
    1250            1                    ***0***           when 127 =>  RequestTransaction(Rdy => TransactionRec(127).Rdy, Ack => TransactionRec(127).Ack) ; 
    1251            1                    ***0***           when 128 =>  RequestTransaction(Rdy => TransactionRec(128).Rdy, Ack => TransactionRec(128).Ack) ; 
    1252            1                    ***0***           when 129 =>  RequestTransaction(Rdy => TransactionRec(129).Rdy, Ack => TransactionRec(129).Ack) ; 
    1253            1                    ***0***           when others => Alert("StreamTransactionArrayPkg: Please extend StreamArrayRequestTransaction to handle " & to_string(Index) & " indices") ; 
Branch totals: 0 hits of 131 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2571                                 ***0***     Count coming in to IF
    2571            1                    ***0***         if Available then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2603                                 ***0***     Count coming in to IF
    2603            1                    ***0***         if Available then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2636                                 ***0***     Count coming in to IF
    2636            1                    ***0***         if Available then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2669                                 ***0***     Count coming in to IF
    2669            1                    ***0***         if Available then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2703                                 ***0***     Count coming in to IF
    2703            1                    ***0***         if Available then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                     372         0       372     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/StreamTransactionArrayPkg.vhd --

    1                                                --
    2                                                --  File Name:         StreamTransactionArrayPkg.vhd
    3                                                --  Design Unit Name:  StreamTransactionArrayPkg
    4                                                --  Revision:          OSVVM MODELS STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com
    7                                                --  Contributor(s):
    8                                                --     Jim Lewis      jim@synthworks.com
    9                                                --
    10                                               --
    11                                               --  Description:
    12                                               --    Defines Stream transaction initiation procedures (Send, Get, ...)
    13                                               --    for arrays of Stream Interfaces (StreamRecArrayType).
    14                                               --    Companion to StreamTransactionPkg.vhd
    15                                               --    
    16                                               --    This works around a VHDL issue documented in 
    17                                               --    https://gitlab.com/IEEE-P1076/VHDL-Issues/-/issues/275
    18                                               --    When this issue is fixed and implemented, this package will
    19                                               --    no longer be needed
    20                                               --
    21                                               --
    22                                               --  Developed by:
    23                                               --        SynthWorks Design Inc.
    24                                               --        VHDL Training Classes
    25                                               --        http://www.SynthWorks.com
    26                                               --
    27                                               --  Revision History:
    28                                               --    Date      Version    Description
    29                                               --    11/2022   2022.11    initial
    30                                               --
    31                                               --
    32                                               --  This file is part of OSVVM.
    33                                               --  
    34                                               --  Copyright (c) 2022 by SynthWorks Design Inc.  
    35                                               --  
    36                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    37                                               --  you may not use this file except in compliance with the License.
    38                                               --  You may obtain a copy of the License at
    39                                               --  
    40                                               --      https://www.apache.org/licenses/LICENSE-2.0
    41                                               --  
    42                                               --  Unless required by applicable law or agreed to in writing, software
    43                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    44                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    45                                               --  See the License for the specific language governing permissions and
    46                                               --  limitations under the License.
    47                                               --  
    48                                               
    49                                               library ieee ;
    50                                                 use ieee.std_logic_1164.all ;
    51                                                 use ieee.numeric_std.all ;
    52                                                 use ieee.numeric_std_unsigned.all ;
    53                                               
    54                                                 use std.textio.all ;
    55                                               
    56                                               library osvvm ; 
    57                                                 context osvvm.OsvvmContext ;  
    58                                                 use osvvm.ScoreboardPkg_slv.all ; 
    59                                                 
    60                                                 use work.FifoFillPkg_slv.all ; 
    61                                                 use work.StreamTransactionPkg.all ; 
    62                                               
    63                                               package StreamTransactionArrayPkg is 
    64                                               
    65                                                 -- ========================================================
    66                                                 --  Directive Transactions  
    67                                                 --  Directive transactions interact with the verification component 
    68                                                 --  without generating any transactions or interface waveforms.
    69                                                 --  Supported by all verification components
    70                                                 -- ========================================================
    71                                                 ------------------------------------------------------------
    72                                                 procedure WaitForTransaction (
    73                                                 --  Wait until pending (transmit) or next (receive) transaction(s) complete
    74                                                 ------------------------------------------------------------
    75                                                   signal    TransactionRec   : inout StreamRecArrayType ;
    76                                                   constant  Index            : in    integer 
    77                                                 ) ; 
    78                                               
    79                                                 ------------------------------------------------------------
    80                                                 procedure WaitForClock (
    81                                                 -- Wait for NumberOfClocks number of clocks 
    82                                                 -- relative to the verification component clock
    83                                                 ------------------------------------------------------------
    84                                                   signal    TransactionRec   : inout StreamRecArrayType ;
    85                                                   constant  Index            : in    integer ;
    86                                                   constant  WaitCycles       : in    natural := 1
    87                                                 ) ; 
    88                                                 
    89                                                 ------------------------------------------------------------
    90                                                 procedure GetTransactionCount (
    91                                                 -- Get the number of transactions handled by the model.  
    92                                                 ------------------------------------------------------------
    93                                                   signal    TransactionRec   : inout StreamRecArrayType ;
    94                                                   constant  Index            : in    integer ;
    95                                                   variable  TransactionCount : out   integer 
    96                                                 ) ; 
    97                                               
    98                                                 ------------------------------------------------------------
    99                                                 procedure GetAlertLogID (
    100                                                -- Get the AlertLogID from the verification component.
    101                                                ------------------------------------------------------------
    102                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    103                                                  constant  Index            : in    integer ;
    104                                                  variable  AlertLogID       : out   AlertLogIDType 
    105                                                ) ; 
    106                                                
    107                                                ------------------------------------------------------------
    108                                                procedure GetErrorCount (
    109                                                -- Error reporting for testbenches that do not use OSVVM AlertLogPkg
    110                                                -- Returns error count.  If an error count /= 0, also print errors
    111                                                ------------------------------------------------------------
    112                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    113                                                  constant  Index            : in    integer ;
    114                                                  variable  ErrorCount       : out   natural
    115                                                ) ; 
    116                                                
    117                                                -- ========================================================
    118                                                --  Delay Coverage Transactions   
    119                                                --  Get Delay Coverage ID to change delay coverage parameters.
    120                                                -- ========================================================
    121                                                ------------------------------------------------------------
    122                                                procedure SetUseRandomDelays (
    123                                                ------------------------------------------------------------
    124                                                  signal    TransactionRec : InOut StreamRecArrayType ;
    125                                                  constant  Index          : in    integer ;
    126                                                  constant  OptVal         : In    boolean := TRUE
    127                                                ) ;
    128                                              
    129                                                ------------------------------------------------------------
    130                                                procedure GetUseRandomDelays (
    131                                                ------------------------------------------------------------
    132                                                  signal    TransactionRec : InOut StreamRecArrayType ;
    133                                                  constant  Index          : in    integer ;
    134                                                  variable  OptVal         : Out   boolean
    135                                                ) ;
    136                                              
    137                                                ------------------------------------------------------------
    138                                                procedure SetDelayCoverageID (
    139                                                ------------------------------------------------------------
    140                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    141                                                  constant  Index            : in    integer ;
    142                                                  constant  DelayCov         : in    DelayCoverageIdType 
    143                                                ) ;
    144                                              
    145                                                ------------------------------------------------------------
    146                                                procedure GetDelayCoverageID (
    147                                                ------------------------------------------------------------
    148                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    149                                                  constant  Index            : in    integer ;
    150                                                  variable  DelayCov         : out   DelayCoverageIdType 
    151                                                ) ;
    152                                              
    153                                                ------------------------------------------------------------
    154                                                --  SetBurstMode and GetBurstMode
    155                                                --  are directive transactions that configure the burst mode 
    156                                                --  into one of the modes defined for StreamFifoBurstModeType
    157                                                ------------------------------------------------------------
    158                                                ------------------------------------------------------------
    159                                                procedure SetBurstMode (
    160                                                ------------------------------------------------------------
    161                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    162                                                  constant  Index            : in    integer ;
    163                                                  constant  OptVal           : in    StreamFifoBurstModeType
    164                                                ) ;
    165                                              
    166                                                ------------------------------------------------------------
    167                                                procedure GetBurstMode (
    168                                                ------------------------------------------------------------
    169                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    170                                                  constant  Index            : in    integer ;
    171                                                  variable  OptVal           : out   StreamFifoBurstModeType
    172                                                ) ;
    173                                              
    174                                                ------------------------------------------------------------
    175                                                --  GotBurst   
    176                                                --  Check to see if Read Burst is available
    177                                                --  Primarily used internally
    178                                                ------------------------------------------------------------
    179                                                ------------------------------------------------------------
    180                                                procedure GotBurst (
    181                                                ------------------------------------------------------------
    182                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    183                                                  constant  Index            : in    integer ;
    184                                                  constant  NumFifoWords     : in    integer ;
    185                                                  variable  Available        : out   boolean
    186                                                ) ;
    187                                              
    188                                                -- ========================================================
    189                                                --  Set and Get Model Options  
    190                                                --  Model operations are directive transactions that are  
    191                                                --  used to configure the verification component.  
    192                                                --  They can either be used directly or with a model specific
    193                                                --  wrapper around them - see AXI models for examples.
    194                                                -- ========================================================
    195                                                ------------------------------------------------------------
    196                                                procedure SetModelOptions (
    197                                                ------------------------------------------------------------
    198                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    199                                                  constant  Index            : in    integer ;
    200                                                  constant  Option           : in    integer ;
    201                                                  constant  OptVal           : in    boolean
    202                                                ) ;
    203                                              
    204                                                ------------------------------------------------------------
    205                                                procedure SetModelOptions (
    206                                                ------------------------------------------------------------
    207                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    208                                                  constant  Index            : in    integer ;
    209                                                  constant  Option           : in    integer ;
    210                                                  constant  OptVal           : in    integer
    211                                                ) ;
    212                                              
    213                                                ------------------------------------------------------------
    214                                                procedure SetModelOptions (
    215                                                ------------------------------------------------------------
    216                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    217                                                  constant  Index            : in    integer ;
    218                                                  constant  Option           : in    integer ;
    219                                                  constant  OptVal           : in    std_logic_vector
    220                                                ) ;
    221                                                
    222                                                ------------------------------------------------------------
    223                                                procedure SetModelOptions (
    224                                                ------------------------------------------------------------
    225                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    226                                                  constant  Index            : in    integer ;
    227                                                  constant  Option           : in    integer ;
    228                                                  constant  OptVal           : in    time
    229                                                ) ;
    230                                                
    231                                                ------------------------------------------------------------
    232                                                procedure SetModelOptions (
    233                                                ------------------------------------------------------------
    234                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    235                                                  constant  Index            : in    integer ;
    236                                                  constant  Option           : in    integer 
    237                                                ) ;
    238                                                
    239                                                ------------------------------------------------------------
    240                                                procedure GetModelOptions (
    241                                                ------------------------------------------------------------
    242                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    243                                                  constant  Index            : in    integer ;
    244                                                  constant  Option           : in    integer ;
    245                                                  variable  OptVal           : out   boolean
    246                                                ) ;
    247                                              
    248                                                ------------------------------------------------------------
    249                                                procedure GetModelOptions (
    250                                                ------------------------------------------------------------
    251                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    252                                                  constant  Index            : in    integer ;
    253                                                  constant  Option           : in    integer ;
    254                                                  variable  OptVal           : out   integer
    255                                                ) ;
    256                                              
    257                                                ------------------------------------------------------------
    258                                                procedure GetModelOptions (
    259                                                ------------------------------------------------------------
    260                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    261                                                  constant  Index            : in    integer ;
    262                                                  constant  Option           : in    integer ;
    263                                                  variable  OptVal           : out   std_logic_vector
    264                                                ) ;
    265                                                
    266                                                ------------------------------------------------------------
    267                                                procedure GetModelOptions (
    268                                                ------------------------------------------------------------
    269                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    270                                                  constant  Index            : in    integer ;
    271                                                  constant  Option           : in    integer ;
    272                                                  variable  OptVal           : out   time
    273                                                ) ;
    274                                                
    275                                                ------------------------------------------------------------
    276                                                procedure GetModelOptions (
    277                                                ------------------------------------------------------------
    278                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    279                                                  constant  Index            : in    integer ;
    280                                                  constant  Option           : in    integer 
    281                                                ) ;
    282                                              
    283                                              
    284                                                -- ========================================================
    285                                                --  Transmitter Transactions
    286                                                -- ========================================================
    287                                              
    288                                                -- ========================================================
    289                                                -- Send
    290                                                -- Blocking Send Transaction. 
    291                                                -- Param, when present, is an extra parameter used by the verification component
    292                                                -- The UART verification component uses Param for error injection.
    293                                                -- ========================================================
    294                                                
    295                                                ------------------------------------------------------------
    296                                                procedure Send (
    297                                                ------------------------------------------------------------
    298                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    299                                                  constant  Index            : in    integer ;
    300                                                  constant  Data             : in    std_logic_vector ;
    301                                                  constant  Param            : in    std_logic_vector ;
    302                                                  constant  StatusMsgOn      : in    boolean := false 
    303                                                ) ; 
    304                                              
    305                                                ------------------------------------------------------------
    306                                                procedure Send (
    307                                                ------------------------------------------------------------
    308                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    309                                                  constant  Index            : in    integer ;
    310                                                  constant  Data             : in    std_logic_vector ;
    311                                                  constant  StatusMsgOn      : in    boolean := false 
    312                                                ) ; 
    313                                                
    314                                              
    315                                                -- ========================================================
    316                                                -- SendAsync
    317                                                -- Asynchronous / Non-Blocking Send Transaction
    318                                                -- Param, when present, is an extra parameter used by the verification component
    319                                                -- The UART verification component uses Param for error injection. 
    320                                                -- ========================================================
    321                                              
    322                                                ------------------------------------------------------------
    323                                                procedure SendAsync (
    324                                                ------------------------------------------------------------
    325                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    326                                                  constant  Index            : in    integer ;
    327                                                  constant  Data             : in    std_logic_vector ;
    328                                                  constant  Param            : in    std_logic_vector ;
    329                                                  constant  StatusMsgOn      : in    boolean := false 
    330                                                ) ; 
    331                                              
    332                                                ------------------------------------------------------------
    333                                                procedure SendAsync (
    334                                                ------------------------------------------------------------
    335                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    336                                                  constant  Index            : in    integer ;
    337                                                  constant  Data             : in    std_logic_vector ;
    338                                                  constant  StatusMsgOn      : in    boolean := false 
    339                                                ) ; 
    340                                              
    341                                              
    342                                                -- ========================================================
    343                                                -- SendBurst
    344                                                -- Blocking Send Burst Transaction. 
    345                                                -- Param, when present, is an extra parameter used by the verification component
    346                                                -- The UART verification component uses Param for error injection.
    347                                                -- ========================================================
    348                                              
    349                                                ------------------------------------------------------------
    350                                                procedure SendBurst (
    351                                                ------------------------------------------------------------
    352                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    353                                                  constant  Index            : in    integer ;
    354                                                  constant  NumFifoWords     : in    integer ;
    355                                                  constant  Param            : in    std_logic_vector ;
    356                                                  constant  StatusMsgOn      : in    boolean := false 
    357                                                ) ; 
    358                                              
    359                                                ------------------------------------------------------------
    360                                                procedure SendBurst (
    361                                                ------------------------------------------------------------
    362                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    363                                                  constant  Index            : in    integer ;
    364                                                  constant  NumFifoWords     : in    integer ;
    365                                                  constant  StatusMsgOn      : in    boolean := false 
    366                                                ) ; 
    367                                                
    368                                                ------------------------------------------------------------
    369                                                procedure SendBurstVector (
    370                                                ------------------------------------------------------------
    371                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    372                                                  constant  Index            : in    integer ;
    373                                                  constant  VectorOfWords    : in    slv_vector ;
    374                                                  constant  Param            : in    std_logic_vector ;
    375                                                  constant  StatusMsgOn      : in    boolean := false
    376                                                ) ;
    377                                                
    378                                                ------------------------------------------------------------
    379                                                procedure SendBurstVector (
    380                                                ------------------------------------------------------------
    381                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    382                                                  constant  Index            : in    integer ;
    383                                                  constant  VectorOfWords    : in    slv_vector ;
    384                                                  constant  StatusMsgOn      : in    boolean := false
    385                                                ) ;
    386                                                
    387                                              --  alias SendBurst is SendBurstVector[StreamRecArrayType, slv_vector, std_logic_vector, boolean] ; 
    388                                              --  alias SendBurst is SendBurstVector[StreamRecArrayType, slv_vector, boolean] ; 
    389                                              
    390                                                ------------------------------------------------------------
    391                                                procedure SendBurstVector (
    392                                                ------------------------------------------------------------
    393                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    394                                                  constant  Index            : in    integer ;
    395                                                  constant  VectorOfWords    : in    integer_vector ;
    396                                                  constant  Param            : in    std_logic_vector ;
    397                                                  constant  FifoWidth        : in    integer ; 
    398                                                  constant  StatusMsgOn      : in    boolean := false
    399                                                ) ;
    400                                                
    401                                                ------------------------------------------------------------
    402                                                procedure SendBurstVector (
    403                                                ------------------------------------------------------------
    404                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    405                                                  constant  Index            : in    integer ;
    406                                                  constant  VectorOfWords    : in    integer_vector ;
    407                                                  constant  FifoWidth        : in    integer ; 
    408                                                  constant  StatusMsgOn      : in    boolean := false
    409                                                ) ;
    410                                              
    411                                                ------------------------------------------------------------
    412                                                procedure SendBurstIncrement (
    413                                                ------------------------------------------------------------
    414                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    415                                                  constant  Index            : in    integer ;
    416                                                  constant  FirstWord        : in    std_logic_vector ;
    417                                                  constant  NumFifoWords     : in    integer ;
    418                                                  constant  Param            : in    std_logic_vector ;
    419                                                  constant  StatusMsgOn      : in    boolean := false
    420                                                ) ;
    421                                              
    422                                                ------------------------------------------------------------
    423                                                procedure SendBurstIncrement (
    424                                                ------------------------------------------------------------
    425                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    426                                                  constant  Index            : in    integer ;
    427                                                  constant  FirstWord        : in    std_logic_vector ;
    428                                                  constant  NumFifoWords     : in    integer ;
    429                                                  constant  StatusMsgOn      : in    boolean := false
    430                                                ) ;
    431                                              
    432                                                ------------------------------------------------------------
    433                                                procedure SendBurstRandom (
    434                                                ------------------------------------------------------------
    435                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    436                                                  constant  Index            : in    integer ;
    437                                                  constant  FirstWord        : in    std_logic_vector ;
    438                                                  constant  NumFifoWords     : in    integer ;
    439                                                  constant  Param            : in    std_logic_vector ;
    440                                                  constant  StatusMsgOn      : in    boolean := false
    441                                                ) ;
    442                                              
    443                                                ------------------------------------------------------------
    444                                                procedure SendBurstRandom (
    445                                                ------------------------------------------------------------
    446                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    447                                                  constant  Index            : in    integer ;
    448                                                  constant  FirstWord        : in    std_logic_vector ;
    449                                                  constant  NumFifoWords     : in    integer ;
    450                                                  constant  StatusMsgOn      : in    boolean := false
    451                                                ) ;
    452                                              
    453                                                ------------------------------------------------------------
    454                                                procedure SendBurstRandom (
    455                                                ------------------------------------------------------------
    456                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    457                                                  constant  Index            : in    integer ;
    458                                                  constant  CoverID          : in    CoverageIDType ;
    459                                                  constant  NumFifoWords     : in    integer ;
    460                                                  constant  FifoWidth        : in    integer ;
    461                                                  constant  Param            : in    std_logic_vector ;
    462                                                  constant  StatusMsgOn      : in    boolean := false
    463                                                ) ;
    464                                              
    465                                                ------------------------------------------------------------
    466                                                procedure SendBurstRandom (
    467                                                ------------------------------------------------------------
    468                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    469                                                  constant  Index            : in    integer ;
    470                                                  constant  CoverID          : in    CoverageIDType ;
    471                                                  constant  NumFifoWords     : in    integer ;
    472                                                  constant  FifoWidth        : in    integer ;
    473                                                  constant  StatusMsgOn      : in    boolean := false
    474                                                ) ;
    475                                              
    476                                                -- ========================================================
    477                                                -- SendBurstAsync
    478                                                -- Asynchronous / Non-Blocking Send Transaction
    479                                                -- Param, when present, is an extra parameter used by the verification component
    480                                                -- The UART verification component uses Param for error injection. 
    481                                                -- ========================================================
    482                                              
    483                                                ------------------------------------------------------------
    484                                                procedure SendBurstAsync (
    485                                                ------------------------------------------------------------
    486                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    487                                                  constant  Index            : in    integer ;
    488                                                  constant  NumFifoWords     : in    integer ;
    489                                                  constant  Param            : in    std_logic_vector ;
    490                                                  constant  StatusMsgOn      : in    boolean := false 
    491                                                ) ; 
    492                                              
    493                                                ------------------------------------------------------------
    494                                                procedure SendBurstAsync (
    495                                                ------------------------------------------------------------
    496                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    497                                                  constant  Index            : in    integer ;
    498                                                  constant  NumFifoWords     : in    integer ;
    499                                                  constant  StatusMsgOn      : in    boolean := false 
    500                                                ) ; 
    501                                                
    502                                                ------------------------------------------------------------
    503                                                procedure SendBurstVectorAsync (
    504                                                ------------------------------------------------------------
    505                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    506                                                  constant  Index            : in    integer ;
    507                                                  constant  VectorOfWords    : in    slv_vector ;
    508                                                  constant  Param            : in    std_logic_vector ;
    509                                                  constant  StatusMsgOn      : in    boolean := false
    510                                                ) ;
    511                                                
    512                                                ------------------------------------------------------------
    513                                                procedure SendBurstVectorAsync (
    514                                                ------------------------------------------------------------
    515                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    516                                                  constant  Index            : in    integer ;
    517                                                  constant  VectorOfWords    : in    slv_vector ;
    518                                                  constant  StatusMsgOn      : in    boolean := false
    519                                                ) ;
    520                                                
    521                                              --  alias SendBurstAsync is SendBurstVectorAsync[StreamRecArrayType, slv_vector, std_logic_vector, boolean] ; 
    522                                              --  alias SendBurstAsync is SendBurstVectorAsync[StreamRecArrayType, slv_vector, boolean] ; 
    523                                              
    524                                                ------------------------------------------------------------
    525                                                procedure SendBurstVectorAsync (
    526                                                ------------------------------------------------------------
    527                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    528                                                  constant  Index            : in    integer ;
    529                                                  constant  VectorOfWords    : in    integer_vector ;
    530                                                  constant  Param            : in    std_logic_vector ;
    531                                                  constant  FifoWidth        : in    integer ; 
    532                                                  constant  StatusMsgOn      : in    boolean := false
    533                                                ) ;
    534                                                
    535                                                ------------------------------------------------------------
    536                                                procedure SendBurstVectorAsync (
    537                                                ------------------------------------------------------------
    538                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    539                                                  constant  Index            : in    integer ;
    540                                                  constant  VectorOfWords    : in    integer_vector ;
    541                                                  constant  FifoWidth        : in    integer ; 
    542                                                  constant  StatusMsgOn      : in    boolean := false
    543                                                ) ;
    544                                              
    545                                                ------------------------------------------------------------
    546                                                procedure SendBurstIncrementAsync (
    547                                                ------------------------------------------------------------
    548                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    549                                                  constant  Index            : in    integer ;
    550                                                  constant  FirstWord        : in    std_logic_vector ;
    551                                                  constant  NumFifoWords     : in    integer ;
    552                                                  constant  Param            : in    std_logic_vector ;
    553                                                  constant  StatusMsgOn      : in    boolean := false
    554                                                ) ;
    555                                              
    556                                                ------------------------------------------------------------
    557                                                procedure SendBurstIncrementAsync (
    558                                                ------------------------------------------------------------
    559                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    560                                                  constant  Index            : in    integer ;
    561                                                  constant  FirstWord        : in    std_logic_vector ;
    562                                                  constant  NumFifoWords     : in    integer ;
    563                                                  constant  StatusMsgOn      : in    boolean := false
    564                                                ) ;
    565                                              
    566                                                ------------------------------------------------------------
    567                                                procedure SendBurstRandomAsync (
    568                                                ------------------------------------------------------------
    569                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    570                                                  constant  Index            : in    integer ;
    571                                                  constant  FirstWord        : in    std_logic_vector ;
    572                                                  constant  NumFifoWords     : in    integer ;
    573                                                  constant  Param            : in    std_logic_vector ;
    574                                                  constant  StatusMsgOn      : in    boolean := false
    575                                                ) ;
    576                                              
    577                                                ------------------------------------------------------------
    578                                                procedure SendBurstRandomAsync (
    579                                                ------------------------------------------------------------
    580                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    581                                                  constant  Index            : in    integer ;
    582                                                  constant  FirstWord        : in    std_logic_vector ;
    583                                                  constant  NumFifoWords     : in    integer ;
    584                                                  constant  StatusMsgOn      : in    boolean := false
    585                                                ) ;
    586                                                
    587                                                ------------------------------------------------------------
    588                                                procedure SendBurstRandomAsync (
    589                                                ------------------------------------------------------------
    590                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    591                                                  constant  Index            : in    integer ;
    592                                                  constant  CoverID          : in    CoverageIDType ;
    593                                                  constant  NumFifoWords     : in    integer ;
    594                                                  constant  FifoWidth        : in    integer ;
    595                                                  constant  Param            : in    std_logic_vector ;
    596                                                  constant  StatusMsgOn      : in    boolean := false
    597                                                ) ;
    598                                              
    599                                                ------------------------------------------------------------
    600                                                procedure SendBurstRandomAsync (
    601                                                ------------------------------------------------------------
    602                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    603                                                  constant  Index            : in    integer ;
    604                                                  constant  CoverID          : in    CoverageIDType ;
    605                                                  constant  NumFifoWords     : in    integer ;
    606                                                  constant  FifoWidth        : in    integer ;
    607                                                  constant  StatusMsgOn      : in    boolean := false
    608                                                ) ;
    609                                              
    610                                                -- ========================================================
    611                                                --  Receiver Transactions
    612                                                -- ========================================================
    613                                              
    614                                                -- ========================================================
    615                                                -- Get
    616                                                -- Blocking Get Transaction. 
    617                                                -- Param, when present, is an extra parameter used by the verification component
    618                                                -- The UART verification component uses Param for received error status.
    619                                                -- ========================================================
    620                                              
    621                                                ------------------------------------------------------------
    622                                                procedure Get (
    623                                                ------------------------------------------------------------
    624                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    625                                                  constant  Index            : in    integer ;
    626                                                  variable  Data             : out   std_logic_vector ;
    627                                                  variable  Param            : out   std_logic_vector ;
    628                                                  constant  StatusMsgOn      : in    boolean := false 
    629                                                ) ; 
    630                                              
    631                                                ------------------------------------------------------------
    632                                                procedure Get (
    633                                                ------------------------------------------------------------
    634                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    635                                                  constant  Index            : in    integer ;
    636                                                  variable  Data             : out   std_logic_vector ;
    637                                                  constant  StatusMsgOn      : in    boolean := false 
    638                                                ) ; 
    639                                              
    640                                              
    641                                                -- ========================================================
    642                                                -- TryGet
    643                                                -- Try Get Transaction
    644                                                -- If Data is available, get it and return available TRUE,
    645                                                -- otherwise Return Available FALSE.
    646                                                -- Param, when present, is an extra parameter used by the verification component
    647                                                -- The UART verification component uses Param for received error status.
    648                                                -- ========================================================
    649                                              
    650                                                ------------------------------------------------------------
    651                                                procedure TryGet (
    652                                                ------------------------------------------------------------
    653                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    654                                                  constant  Index            : in    integer ;
    655                                                  variable  Data             : out   std_logic_vector ;
    656                                                  variable  Available        : out   boolean ;
    657                                                  constant  StatusMsgOn      : in    boolean := false 
    658                                                ) ; 
    659                                                
    660                                                ------------------------------------------------------------
    661                                                procedure TryGet (
    662                                                ------------------------------------------------------------
    663                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    664                                                  constant  Index            : in    integer ;
    665                                                  variable  Data             : out   std_logic_vector ;
    666                                                  variable  Param            : out   std_logic_vector ;
    667                                                  variable  Available        : out   boolean ;
    668                                                  constant  StatusMsgOn      : in    boolean := false 
    669                                                ) ;  
    670                                              
    671                                              
    672                                                -- ========================================================
    673                                                -- GetBurst
    674                                                -- Blocking Get Burst Transaction. 
    675                                                -- Param, when present, is an extra parameter from the verification component
    676                                                -- The UART verification component uses Param for received error status.
    677                                                -- ========================================================
    678                                              
    679                                                ------------------------------------------------------------
    680                                                procedure GetBurst (
    681                                                ------------------------------------------------------------
    682                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    683                                                  constant  Index            : in    integer ;
    684                                                  variable  NumFifoWords     : inout integer ;
    685                                                  constant  StatusMsgOn      : in    boolean := false 
    686                                                ) ; 
    687                                                
    688                                                ------------------------------------------------------------
    689                                                procedure GetBurst (
    690                                                ------------------------------------------------------------
    691                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    692                                                  constant  Index            : in    integer ;
    693                                                  variable  NumFifoWords     : inout integer ;
    694                                                  variable  Param            : out   std_logic_vector ;
    695                                                  constant  StatusMsgOn      : in    boolean := false 
    696                                                ) ;  
    697                                              
    698                                                -- ========================================================
    699                                                -- TryGetBurst
    700                                                -- Try Get Burst Transaction
    701                                                -- If Data is available, get it and return available TRUE,
    702                                                -- otherwise Return Available FALSE.
    703                                                -- Param, when present, is an extra parameter used by the verification component
    704                                                -- The UART verification component uses Param for received error status.
    705                                                -- ========================================================
    706                                              
    707                                                ------------------------------------------------------------
    708                                                procedure TryGetBurst (
    709                                                ------------------------------------------------------------
    710                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    711                                                  constant  Index            : in    integer ;
    712                                                  variable  NumFifoWords     : inout integer ;
    713                                                  variable  Available        : out   boolean ;
    714                                                  constant  StatusMsgOn      : in    boolean := false 
    715                                                ) ; 
    716                                                
    717                                                ------------------------------------------------------------
    718                                                procedure TryGetBurst (
    719                                                ------------------------------------------------------------
    720                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    721                                                  constant  Index            : in    integer ;
    722                                                  variable  NumFifoWords     : inout integer ;
    723                                                  variable  Param            : out   std_logic_vector ;
    724                                                  variable  Available        : out   boolean ;
    725                                                  constant  StatusMsgOn      : in    boolean := false 
    726                                                ) ;  
    727                                              
    728                                              
    729                                                -- ========================================================
    730                                                -- Check
    731                                                -- Blocking Check Transaction. 
    732                                                -- Data is the expected value to be received.
    733                                                -- Param, when present, is an extra parameter used by the verification component
    734                                                -- The UART verification component uses Param for received error status.
    735                                                -- ========================================================
    736                                              
    737                                                ------------------------------------------------------------
    738                                                procedure Check (
    739                                                ------------------------------------------------------------
    740                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    741                                                  constant  Index            : in    integer ;
    742                                                  constant  Data             : in    std_logic_vector ;
    743                                                  constant  Param            : in    std_logic_vector ;
    744                                                  constant  StatusMsgOn      : in    boolean := false 
    745                                                ) ; 
    746                                              
    747                                                ------------------------------------------------------------
    748                                                procedure Check (
    749                                                ------------------------------------------------------------
    750                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    751                                                  constant  Index            : in    integer ;
    752                                                  constant  Data             : in    std_logic_vector ;
    753                                                  constant  StatusMsgOn      : in    boolean := false 
    754                                                ) ; 
    755                                              
    756                                              
    757                                                -- ========================================================
    758                                                -- TryCheck
    759                                                -- Try Check Transaction
    760                                                -- If Data is available, check it and return available TRUE,
    761                                                -- otherwise Return Available FALSE.
    762                                                -- Param, when present, is an extra parameter used by the verification component
    763                                                -- The UART verification component uses Param for received error status.
    764                                                -- ========================================================
    765                                              
    766                                                ------------------------------------------------------------
    767                                                procedure TryCheck (
    768                                                ------------------------------------------------------------
    769                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    770                                                  constant  Index            : in    integer ;
    771                                                  constant  Data             : in    std_logic_vector ;
    772                                                  constant  Param            : in    std_logic_vector ;
    773                                                  variable  Available        : out   boolean ;
    774                                                  constant  StatusMsgOn      : in    boolean := false 
    775                                                ) ; 
    776                                              
    777                                                ------------------------------------------------------------
    778                                                procedure TryCheck (
    779                                                ------------------------------------------------------------
    780                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    781                                                  constant  Index            : in    integer ;
    782                                                  constant  Data             : in    std_logic_vector ;
    783                                                  variable  Available        : out   boolean ;
    784                                                  constant  StatusMsgOn      : in    boolean := false 
    785                                                ) ; 
    786                                              
    787                                                -- ========================================================
    788                                                -- CheckBurst
    789                                                -- Blocking Check Burst Transaction. 
    790                                                -- Param, when present, is an extra parameter used by the verification component
    791                                                -- The UART verification component uses Param for checking error injection.
    792                                                -- ========================================================
    793                                                ------------------------------------------------------------
    794                                                procedure CheckBurst (
    795                                                ------------------------------------------------------------
    796                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    797                                                  constant  Index            : in    integer ;
    798                                                  constant  NumFifoWords     : in    integer ;
    799                                                  constant  Param            : in    std_logic_vector ;
    800                                                  constant  StatusMsgOn      : in    boolean := false 
    801                                                ) ; 
    802                                              
    803                                                ------------------------------------------------------------
    804                                                procedure CheckBurst (
    805                                                ------------------------------------------------------------
    806                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    807                                                  constant  Index            : in    integer ;
    808                                                  constant  NumFifoWords     : in    integer ;
    809                                                  constant  StatusMsgOn      : in    boolean := false 
    810                                                ) ; 
    811                                              
    812                                                ------------------------------------------------------------
    813                                                procedure CheckBurstVector (
    814                                                ------------------------------------------------------------
    815                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    816                                                  constant  Index            : in    integer ;
    817                                                  constant  VectorOfWords    : in    slv_vector ;
    818                                                  constant  Param            : in    std_logic_vector ;
    819                                                  constant  StatusMsgOn      : in    boolean := false
    820                                                ) ;
    821                                                
    822                                                ------------------------------------------------------------
    823                                                procedure CheckBurstVector (
    824                                                ------------------------------------------------------------
    825                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    826                                                  constant  Index            : in    integer ;
    827                                                  constant  VectorOfWords    : in    slv_vector ;
    828                                                  constant  StatusMsgOn      : in    boolean := false
    829                                                ) ;
    830                                                
    831                                              --  alias CheckBurst is CheckBurstVector[StreamRecArrayType, slv_vector, std_logic_vector, boolean] ; 
    832                                              --  alias CheckBurst is CheckBurstVector[StreamRecArrayType, slv_vector, boolean] ; 
    833                                              
    834                                                ------------------------------------------------------------
    835                                                procedure CheckBurstVector (
    836                                                ------------------------------------------------------------
    837                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    838                                                  constant  Index            : in    integer ;
    839                                                  constant  VectorOfWords    : in    integer_vector ;
    840                                                  constant  Param            : in    std_logic_vector ;
    841                                                  constant  FifoWidth        : in    integer ; 
    842                                                  constant  StatusMsgOn      : in    boolean := false
    843                                                ) ;
    844                                                
    845                                                ------------------------------------------------------------
    846                                                procedure CheckBurstVector (
    847                                                ------------------------------------------------------------
    848                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    849                                                  constant  Index            : in    integer ;
    850                                                  constant  VectorOfWords    : in    integer_vector ;
    851                                                  constant  FifoWidth        : in    integer ; 
    852                                                  constant  StatusMsgOn      : in    boolean := false
    853                                                ) ;
    854                                              
    855                                                ------------------------------------------------------------
    856                                                procedure CheckBurstIncrement (
    857                                                ------------------------------------------------------------
    858                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    859                                                  constant  Index            : in    integer ;
    860                                                  constant  FirstWord        : in    std_logic_vector ;
    861                                                  constant  NumFifoWords     : in    integer ;
    862                                                  constant  Param            : in    std_logic_vector ;
    863                                                  constant  StatusMsgOn      : in    boolean := false
    864                                                ) ;
    865                                              
    866                                                ------------------------------------------------------------
    867                                                procedure CheckBurstIncrement (
    868                                                ------------------------------------------------------------
    869                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    870                                                  constant  Index            : in    integer ;
    871                                                  constant  FirstWord        : in    std_logic_vector ;
    872                                                  constant  NumFifoWords     : in    integer ;
    873                                                  constant  StatusMsgOn      : in    boolean := false
    874                                                ) ;
    875                                              
    876                                                ------------------------------------------------------------
    877                                                procedure CheckBurstRandom (
    878                                                ------------------------------------------------------------
    879                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    880                                                  constant  Index            : in    integer ;
    881                                                  constant  FirstWord        : in    std_logic_vector ;
    882                                                  constant  NumFifoWords     : in    integer ;
    883                                                  constant  Param            : in    std_logic_vector ;
    884                                                  constant  StatusMsgOn      : in    boolean := false
    885                                                ) ;
    886                                              
    887                                                ------------------------------------------------------------
    888                                                procedure CheckBurstRandom (
    889                                                ------------------------------------------------------------
    890                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    891                                                  constant  Index            : in    integer ;
    892                                                  constant  FirstWord        : in    std_logic_vector ;
    893                                                  constant  NumFifoWords     : in    integer ;
    894                                                  constant  StatusMsgOn      : in    boolean := false
    895                                                ) ;
    896                                              
    897                                                ------------------------------------------------------------
    898                                                procedure CheckBurstRandom (
    899                                                ------------------------------------------------------------
    900                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    901                                                  constant  Index            : in    integer ;
    902                                                  constant  CoverID          : in    CoverageIDType ;
    903                                                  constant  NumFifoWords     : in    integer ;
    904                                                  constant  FifoWidth        : in    integer ;
    905                                                  constant  Param            : in    std_logic_vector ;
    906                                                  constant  StatusMsgOn      : in    boolean := false
    907                                                ) ;  
    908                                              
    909                                                ------------------------------------------------------------
    910                                                procedure CheckBurstRandom (
    911                                                ------------------------------------------------------------
    912                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    913                                                  constant  Index            : in    integer ;
    914                                                  constant  CoverID          : in    CoverageIDType ;
    915                                                  constant  NumFifoWords     : in    integer ;
    916                                                  constant  FifoWidth        : in    integer ;
    917                                                  constant  StatusMsgOn      : in    boolean := false
    918                                                ) ;  
    919                                              
    920                                                -- ========================================================
    921                                                -- TryCheckBurst
    922                                                -- Try / Non-Blocking Check Burst Transaction
    923                                                -- Param, when present, is an extra parameter used by the verification component
    924                                                -- The UART verification component uses Param for error injection. 
    925                                                -- ========================================================
    926                                              
    927                                                ------------------------------------------------------------
    928                                                procedure TryCheckBurst (
    929                                                ------------------------------------------------------------
    930                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    931                                                  constant  Index            : in    integer ;
    932                                                  constant  NumFifoWords     : in    integer ;
    933                                                  constant  Param            : in    std_logic_vector ;
    934                                                  variable  Available        : out   boolean ;
    935                                                  constant  StatusMsgOn      : in    boolean := false 
    936                                                ) ; 
    937                                                
    938                                                ------------------------------------------------------------
    939                                                procedure TryCheckBurst (
    940                                                ------------------------------------------------------------
    941                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    942                                                  constant  Index            : in    integer ;
    943                                                  constant  NumFifoWords     : in    integer ;
    944                                                  variable  Available        : out   boolean ;
    945                                                  constant  StatusMsgOn      : in    boolean := false 
    946                                                ) ; 
    947                                                
    948                                                ------------------------------------------------------------
    949                                                procedure TryCheckBurstVector (
    950                                                ------------------------------------------------------------
    951                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    952                                                  constant  Index            : in    integer ;
    953                                                  constant  VectorOfWords    : in    slv_vector ;
    954                                                  constant  Param            : in    std_logic_vector ;
    955                                                  variable  Available        : out   boolean ;
    956                                                  constant  StatusMsgOn      : in    boolean := false
    957                                                )  ;
    958                                                
    959                                                ------------------------------------------------------------
    960                                                procedure TryCheckBurstVector (
    961                                                ------------------------------------------------------------
    962                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    963                                                  constant  Index            : in    integer ;
    964                                                  constant  VectorOfWords    : in    slv_vector ;
    965                                                  variable  Available        : out   boolean ;
    966                                                  constant  StatusMsgOn      : in    boolean := false
    967                                                ) ;
    968                                              
    969                                              --  alias TryCheckBurst is TryCheckBurstVector[StreamRecArrayType, slv_vector, std_logic_vector, boolean, boolean] ; 
    970                                              --  alias TryCheckBurst is TryCheckBurstVector[StreamRecArrayType, slv_vector, boolean, boolean] ; 
    971                                                
    972                                                ------------------------------------------------------------
    973                                                procedure TryCheckBurstIncrement (
    974                                                ------------------------------------------------------------
    975                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    976                                                  constant  Index            : in    integer ;
    977                                                  constant  FirstWord        : in    std_logic_vector ;
    978                                                  constant  NumFifoWords     : in    integer ;
    979                                                  constant  Param            : in    std_logic_vector ;
    980                                                  variable  Available        : out   boolean ;
    981                                                  constant  StatusMsgOn      : in    boolean := false
    982                                                ) ;
    983                                              
    984                                                ------------------------------------------------------------
    985                                                procedure TryCheckBurstIncrement (
    986                                                ------------------------------------------------------------
    987                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    988                                                  constant  Index            : in    integer ;
    989                                                  constant  FirstWord        : in    std_logic_vector ;
    990                                                  constant  NumFifoWords     : in    integer ;
    991                                                  variable  Available        : out   boolean ;
    992                                                  constant  StatusMsgOn      : in    boolean := false
    993                                                ) ;
    994                                              
    995                                                ------------------------------------------------------------
    996                                                procedure TryCheckBurstRandom (
    997                                                ------------------------------------------------------------
    998                                                  signal    TransactionRec   : inout StreamRecArrayType ;
    999                                                  constant  Index            : in    integer ;
    1000                                                 constant  FirstWord        : in    std_logic_vector ;
    1001                                                 constant  NumFifoWords     : in    integer ;
    1002                                                 constant  Param            : in    std_logic_vector ;
    1003                                                 variable  Available        : out   boolean ;
    1004                                                 constant  StatusMsgOn      : in    boolean := false
    1005                                               ) ;
    1006                                             
    1007                                               ------------------------------------------------------------
    1008                                               procedure TryCheckBurstRandom (
    1009                                               ------------------------------------------------------------
    1010                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1011                                                 constant  Index            : in    integer ;
    1012                                                 constant  FirstWord        : in    std_logic_vector ;
    1013                                                 constant  NumFifoWords     : in    integer ;
    1014                                                 variable  Available        : out   boolean ;
    1015                                                 constant  StatusMsgOn      : in    boolean := false
    1016                                               ) ;
    1017                                             
    1018                                               ------------------------------------------------------------
    1019                                               procedure TryCheckBurstRandom (
    1020                                               ------------------------------------------------------------
    1021                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1022                                                 constant  Index            : in    integer ;
    1023                                                 constant  CoverID          : in    CoverageIDType ;
    1024                                                 constant  NumFifoWords     : in    integer ;
    1025                                                 constant  FifoWidth        : in    integer ;
    1026                                                 constant  Param            : in    std_logic_vector ;
    1027                                                 variable  Available        : out   boolean ;
    1028                                                 constant  StatusMsgOn      : in    boolean := false
    1029                                               ) ;  
    1030                                             
    1031                                               ------------------------------------------------------------
    1032                                               procedure TryCheckBurstRandom (
    1033                                               ------------------------------------------------------------
    1034                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1035                                                 constant  Index            : in    integer ;
    1036                                                 constant  CoverID          : in    CoverageIDType ;
    1037                                                 constant  NumFifoWords     : in    integer ;
    1038                                                 constant  FifoWidth        : in    integer ;
    1039                                                 variable  Available        : out   boolean ;
    1040                                                 constant  StatusMsgOn      : in    boolean := false
    1041                                               ) ;  
    1042                                             
    1043                                               -- ========================================================
    1044                                               --  Send And Get Transactions
    1045                                               -- 
    1046                                               -- ========================================================
    1047                                               ------------------------------------------------------------
    1048                                               procedure SendAndGet (
    1049                                               ------------------------------------------------------------
    1050                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1051                                                 constant  Index            : in    integer ;
    1052                                                 constant  iData            : in    std_logic_vector ;
    1053                                                 constant  iParam           : in    std_logic_vector ;
    1054                                                 variable  oData            : out   std_logic_vector ;
    1055                                                 variable  oParam           : out   std_logic_vector ;
    1056                                                 constant  StatusMsgOn      : in    boolean := false 
    1057                                               ) ;  
    1058                                             
    1059                                               ------------------------------------------------------------
    1060                                               procedure SendAndGet (
    1061                                               ------------------------------------------------------------
    1062                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1063                                                 constant  Index            : in    integer ;
    1064                                                 constant  iData            : in    std_logic_vector ;
    1065                                                 variable  oData            : out   std_logic_vector ;
    1066                                                 constant  StatusMsgOn      : in    boolean := false 
    1067                                               ) ;  
    1068                                             
    1069                                               ------------------------------------------------------------
    1070                                               procedure SendAndGetBurst (
    1071                                               ------------------------------------------------------------
    1072                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1073                                                 constant  Index            : in    integer ;
    1074                                                 constant  iNumFifoWords    : in    integer ;
    1075                                                 constant  iParam           : in    std_logic_vector ;
    1076                                                 variable  oNumFifoWords    : out   integer ;
    1077                                                 variable  oParam           : out   std_logic_vector ;
    1078                                                 constant  StatusMsgOn      : in    boolean := false 
    1079                                               ) ; 
    1080                                             
    1081                                               ------------------------------------------------------------
    1082                                               procedure SendAndGetBurst (
    1083                                               ------------------------------------------------------------
    1084                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1085                                                 constant  Index            : in    integer ;
    1086                                                 constant  iNumFifoWords    : in    integer ;
    1087                                                 variable  oNumFifoWords    : out   integer ;
    1088                                                 constant  StatusMsgOn      : in    boolean := false 
    1089                                               ) ; 
    1090                                             
    1091                                               -- ========================================================
    1092                                               --  Pseudo Transactions
    1093                                               --  Interact with the record only.
    1094                                               -- ========================================================
    1095                                               ------------------------------------------------------------
    1096                                               procedure ReleaseTransactionRecord (
    1097                                               --  Must run on same delta cycle as AcquireTransactionRecord
    1098                                               ------------------------------------------------------------
    1099                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1100                                                 constant  Index            : in    integer 
    1101                                               ) ; 
    1102                                               
    1103                                               ------------------------------------------------------------
    1104                                               procedure AcquireTransactionRecord (
    1105                                               --  Must run on same delta cycle as ReleaseTransactionRecord
    1106                                               ------------------------------------------------------------
    1107                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1108                                                 constant  Index            : in    integer 
    1109                                               ) ; 
    1110                                             end package StreamTransactionArrayPkg ;
    1111                                             
    1112                                             package body StreamTransactionArrayPkg is 
    1113                                             
    1114                                               ------------------------------------------------------------
    1115                                               procedure StreamArrayRequestTransaction (
    1116                                               --  Package Local
    1117                                               ------------------------------------------------------------
    1118                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1119                                                 constant  Index            : in    integer 
    1120                                               ) is
    1121                                               begin
    1122                                                 case Index is 
    1123            1                    ***0***           when  0 =>  RequestTransaction(Rdy => TransactionRec( 0).Rdy, Ack => TransactionRec( 0).Ack) ; 
    1124            1                    ***0***           when  1 =>  RequestTransaction(Rdy => TransactionRec( 1).Rdy, Ack => TransactionRec( 1).Ack) ; 
    1125            1                    ***0***           when  2 =>  RequestTransaction(Rdy => TransactionRec( 2).Rdy, Ack => TransactionRec( 2).Ack) ; 
    1126            1                    ***0***           when  3 =>  RequestTransaction(Rdy => TransactionRec( 3).Rdy, Ack => TransactionRec( 3).Ack) ; 
    1127            1                    ***0***           when  4 =>  RequestTransaction(Rdy => TransactionRec( 4).Rdy, Ack => TransactionRec( 4).Ack) ; 
    1128            1                    ***0***           when  5 =>  RequestTransaction(Rdy => TransactionRec( 5).Rdy, Ack => TransactionRec( 5).Ack) ; 
    1129            1                    ***0***           when  6 =>  RequestTransaction(Rdy => TransactionRec( 6).Rdy, Ack => TransactionRec( 6).Ack) ; 
    1130            1                    ***0***           when  7 =>  RequestTransaction(Rdy => TransactionRec( 7).Rdy, Ack => TransactionRec( 7).Ack) ; 
    1131            1                    ***0***           when  8 =>  RequestTransaction(Rdy => TransactionRec( 8).Rdy, Ack => TransactionRec( 8).Ack) ; 
    1132            1                    ***0***           when  9 =>  RequestTransaction(Rdy => TransactionRec( 9).Rdy, Ack => TransactionRec( 9).Ack) ; 
    1133            1                    ***0***           when 10 =>  RequestTransaction(Rdy => TransactionRec(10).Rdy, Ack => TransactionRec(10).Ack) ; 
    1134            1                    ***0***           when 11 =>  RequestTransaction(Rdy => TransactionRec(11).Rdy, Ack => TransactionRec(11).Ack) ; 
    1135            1                    ***0***           when 12 =>  RequestTransaction(Rdy => TransactionRec(12).Rdy, Ack => TransactionRec(12).Ack) ; 
    1136            1                    ***0***           when 13 =>  RequestTransaction(Rdy => TransactionRec(13).Rdy, Ack => TransactionRec(13).Ack) ; 
    1137            1                    ***0***           when 14 =>  RequestTransaction(Rdy => TransactionRec(14).Rdy, Ack => TransactionRec(14).Ack) ; 
    1138            1                    ***0***           when 15 =>  RequestTransaction(Rdy => TransactionRec(15).Rdy, Ack => TransactionRec(15).Ack) ; 
    1139            1                    ***0***           when 16 =>  RequestTransaction(Rdy => TransactionRec(16).Rdy, Ack => TransactionRec(16).Ack) ; 
    1140            1                    ***0***           when 17 =>  RequestTransaction(Rdy => TransactionRec(17).Rdy, Ack => TransactionRec(17).Ack) ; 
    1141            1                    ***0***           when 18 =>  RequestTransaction(Rdy => TransactionRec(18).Rdy, Ack => TransactionRec(18).Ack) ; 
    1142            1                    ***0***           when 19 =>  RequestTransaction(Rdy => TransactionRec(19).Rdy, Ack => TransactionRec(19).Ack) ; 
    1143            1                    ***0***           when 20 =>  RequestTransaction(Rdy => TransactionRec(20).Rdy, Ack => TransactionRec(20).Ack) ; 
    1144            1                    ***0***           when 21 =>  RequestTransaction(Rdy => TransactionRec(21).Rdy, Ack => TransactionRec(21).Ack) ; 
    1145            1                    ***0***           when 22 =>  RequestTransaction(Rdy => TransactionRec(22).Rdy, Ack => TransactionRec(22).Ack) ; 
    1146            1                    ***0***           when 23 =>  RequestTransaction(Rdy => TransactionRec(23).Rdy, Ack => TransactionRec(23).Ack) ; 
    1147            1                    ***0***           when 24 =>  RequestTransaction(Rdy => TransactionRec(24).Rdy, Ack => TransactionRec(24).Ack) ; 
    1148            1                    ***0***           when 25 =>  RequestTransaction(Rdy => TransactionRec(25).Rdy, Ack => TransactionRec(25).Ack) ; 
    1149            1                    ***0***           when 26 =>  RequestTransaction(Rdy => TransactionRec(26).Rdy, Ack => TransactionRec(26).Ack) ; 
    1150            1                    ***0***           when 27 =>  RequestTransaction(Rdy => TransactionRec(27).Rdy, Ack => TransactionRec(27).Ack) ; 
    1151            1                    ***0***           when 28 =>  RequestTransaction(Rdy => TransactionRec(28).Rdy, Ack => TransactionRec(28).Ack) ; 
    1152            1                    ***0***           when 29 =>  RequestTransaction(Rdy => TransactionRec(29).Rdy, Ack => TransactionRec(29).Ack) ; 
    1153            1                    ***0***           when 30 =>  RequestTransaction(Rdy => TransactionRec(30).Rdy, Ack => TransactionRec(30).Ack) ; 
    1154            1                    ***0***           when 31 =>  RequestTransaction(Rdy => TransactionRec(31).Rdy, Ack => TransactionRec(31).Ack) ; 
    1155            1                    ***0***           when 32 =>  RequestTransaction(Rdy => TransactionRec(32).Rdy, Ack => TransactionRec(32).Ack) ; 
    1156            1                    ***0***           when 33 =>  RequestTransaction(Rdy => TransactionRec(33).Rdy, Ack => TransactionRec(33).Ack) ; 
    1157            1                    ***0***           when 34 =>  RequestTransaction(Rdy => TransactionRec(34).Rdy, Ack => TransactionRec(34).Ack) ; 
    1158            1                    ***0***           when 35 =>  RequestTransaction(Rdy => TransactionRec(35).Rdy, Ack => TransactionRec(35).Ack) ; 
    1159            1                    ***0***           when 36 =>  RequestTransaction(Rdy => TransactionRec(36).Rdy, Ack => TransactionRec(36).Ack) ; 
    1160            1                    ***0***           when 37 =>  RequestTransaction(Rdy => TransactionRec(37).Rdy, Ack => TransactionRec(37).Ack) ; 
    1161            1                    ***0***           when 38 =>  RequestTransaction(Rdy => TransactionRec(38).Rdy, Ack => TransactionRec(38).Ack) ; 
    1162            1                    ***0***           when 39 =>  RequestTransaction(Rdy => TransactionRec(39).Rdy, Ack => TransactionRec(39).Ack) ; 
    1163            1                    ***0***           when 40 =>  RequestTransaction(Rdy => TransactionRec(40).Rdy, Ack => TransactionRec(40).Ack) ; 
    1164            1                    ***0***           when 41 =>  RequestTransaction(Rdy => TransactionRec(41).Rdy, Ack => TransactionRec(41).Ack) ; 
    1165            1                    ***0***           when 42 =>  RequestTransaction(Rdy => TransactionRec(42).Rdy, Ack => TransactionRec(42).Ack) ; 
    1166            1                    ***0***           when 43 =>  RequestTransaction(Rdy => TransactionRec(43).Rdy, Ack => TransactionRec(43).Ack) ; 
    1167            1                    ***0***           when 44 =>  RequestTransaction(Rdy => TransactionRec(44).Rdy, Ack => TransactionRec(44).Ack) ; 
    1168            1                    ***0***           when 45 =>  RequestTransaction(Rdy => TransactionRec(45).Rdy, Ack => TransactionRec(45).Ack) ; 
    1169            1                    ***0***           when 46 =>  RequestTransaction(Rdy => TransactionRec(46).Rdy, Ack => TransactionRec(46).Ack) ; 
    1170            1                    ***0***           when 47 =>  RequestTransaction(Rdy => TransactionRec(47).Rdy, Ack => TransactionRec(47).Ack) ; 
    1171            1                    ***0***           when 48 =>  RequestTransaction(Rdy => TransactionRec(48).Rdy, Ack => TransactionRec(48).Ack) ; 
    1172            1                    ***0***           when 49 =>  RequestTransaction(Rdy => TransactionRec(49).Rdy, Ack => TransactionRec(49).Ack) ; 
    1173            1                    ***0***           when 50 =>  RequestTransaction(Rdy => TransactionRec(50).Rdy, Ack => TransactionRec(50).Ack) ; 
    1174            1                    ***0***           when 51 =>  RequestTransaction(Rdy => TransactionRec(51).Rdy, Ack => TransactionRec(51).Ack) ; 
    1175            1                    ***0***           when 52 =>  RequestTransaction(Rdy => TransactionRec(52).Rdy, Ack => TransactionRec(52).Ack) ; 
    1176            1                    ***0***           when 53 =>  RequestTransaction(Rdy => TransactionRec(53).Rdy, Ack => TransactionRec(53).Ack) ; 
    1177            1                    ***0***           when 54 =>  RequestTransaction(Rdy => TransactionRec(54).Rdy, Ack => TransactionRec(54).Ack) ; 
    1178            1                    ***0***           when 55 =>  RequestTransaction(Rdy => TransactionRec(55).Rdy, Ack => TransactionRec(55).Ack) ; 
    1179            1                    ***0***           when 56 =>  RequestTransaction(Rdy => TransactionRec(56).Rdy, Ack => TransactionRec(56).Ack) ; 
    1180            1                    ***0***           when 57 =>  RequestTransaction(Rdy => TransactionRec(57).Rdy, Ack => TransactionRec(57).Ack) ; 
    1181            1                    ***0***           when 58 =>  RequestTransaction(Rdy => TransactionRec(58).Rdy, Ack => TransactionRec(58).Ack) ; 
    1182            1                    ***0***           when 59 =>  RequestTransaction(Rdy => TransactionRec(59).Rdy, Ack => TransactionRec(59).Ack) ; 
    1183            1                    ***0***           when 60 =>  RequestTransaction(Rdy => TransactionRec(60).Rdy, Ack => TransactionRec(60).Ack) ; 
    1184            1                    ***0***           when 61 =>  RequestTransaction(Rdy => TransactionRec(61).Rdy, Ack => TransactionRec(61).Ack) ; 
    1185            1                    ***0***           when 62 =>  RequestTransaction(Rdy => TransactionRec(62).Rdy, Ack => TransactionRec(62).Ack) ; 
    1186            1                    ***0***           when 63 =>  RequestTransaction(Rdy => TransactionRec(63).Rdy, Ack => TransactionRec(63).Ack) ; 
    1187            1                    ***0***           when 64 =>  RequestTransaction(Rdy => TransactionRec(64).Rdy, Ack => TransactionRec(64).Ack) ; 
    1188            1                    ***0***           when 65 =>  RequestTransaction(Rdy => TransactionRec(65).Rdy, Ack => TransactionRec(65).Ack) ; 
    1189            1                    ***0***           when 66 =>  RequestTransaction(Rdy => TransactionRec(66).Rdy, Ack => TransactionRec(66).Ack) ; 
    1190            1                    ***0***           when 67 =>  RequestTransaction(Rdy => TransactionRec(67).Rdy, Ack => TransactionRec(67).Ack) ; 
    1191            1                    ***0***           when 68 =>  RequestTransaction(Rdy => TransactionRec(68).Rdy, Ack => TransactionRec(68).Ack) ; 
    1192            1                    ***0***           when 69 =>  RequestTransaction(Rdy => TransactionRec(69).Rdy, Ack => TransactionRec(69).Ack) ; 
    1193            1                    ***0***           when 70 =>  RequestTransaction(Rdy => TransactionRec(70).Rdy, Ack => TransactionRec(70).Ack) ; 
    1194            1                    ***0***           when 71 =>  RequestTransaction(Rdy => TransactionRec(71).Rdy, Ack => TransactionRec(71).Ack) ; 
    1195            1                    ***0***           when 72 =>  RequestTransaction(Rdy => TransactionRec(72).Rdy, Ack => TransactionRec(72).Ack) ; 
    1196            1                    ***0***           when 73 =>  RequestTransaction(Rdy => TransactionRec(73).Rdy, Ack => TransactionRec(73).Ack) ; 
    1197            1                    ***0***           when 74 =>  RequestTransaction(Rdy => TransactionRec(74).Rdy, Ack => TransactionRec(74).Ack) ; 
    1198            1                    ***0***           when 75 =>  RequestTransaction(Rdy => TransactionRec(75).Rdy, Ack => TransactionRec(75).Ack) ; 
    1199            1                    ***0***           when 76 =>  RequestTransaction(Rdy => TransactionRec(76).Rdy, Ack => TransactionRec(76).Ack) ; 
    1200            1                    ***0***           when 77 =>  RequestTransaction(Rdy => TransactionRec(77).Rdy, Ack => TransactionRec(77).Ack) ; 
    1201            1                    ***0***           when 78 =>  RequestTransaction(Rdy => TransactionRec(78).Rdy, Ack => TransactionRec(78).Ack) ; 
    1202            1                    ***0***           when 79 =>  RequestTransaction(Rdy => TransactionRec(79).Rdy, Ack => TransactionRec(79).Ack) ; 
    1203            1                    ***0***           when 80 =>  RequestTransaction(Rdy => TransactionRec(80).Rdy, Ack => TransactionRec(80).Ack) ; 
    1204            1                    ***0***           when 81 =>  RequestTransaction(Rdy => TransactionRec(81).Rdy, Ack => TransactionRec(81).Ack) ; 
    1205            1                    ***0***           when 82 =>  RequestTransaction(Rdy => TransactionRec(82).Rdy, Ack => TransactionRec(82).Ack) ; 
    1206            1                    ***0***           when 83 =>  RequestTransaction(Rdy => TransactionRec(83).Rdy, Ack => TransactionRec(83).Ack) ; 
    1207            1                    ***0***           when 84 =>  RequestTransaction(Rdy => TransactionRec(84).Rdy, Ack => TransactionRec(84).Ack) ; 
    1208            1                    ***0***           when 85 =>  RequestTransaction(Rdy => TransactionRec(85).Rdy, Ack => TransactionRec(85).Ack) ; 
    1209            1                    ***0***           when 86 =>  RequestTransaction(Rdy => TransactionRec(86).Rdy, Ack => TransactionRec(86).Ack) ; 
    1210            1                    ***0***           when 87 =>  RequestTransaction(Rdy => TransactionRec(87).Rdy, Ack => TransactionRec(87).Ack) ; 
    1211            1                    ***0***           when 88 =>  RequestTransaction(Rdy => TransactionRec(88).Rdy, Ack => TransactionRec(88).Ack) ; 
    1212            1                    ***0***           when 89 =>  RequestTransaction(Rdy => TransactionRec(89).Rdy, Ack => TransactionRec(89).Ack) ; 
    1213            1                    ***0***           when 90 =>  RequestTransaction(Rdy => TransactionRec(90).Rdy, Ack => TransactionRec(90).Ack) ; 
    1214            1                    ***0***           when 91 =>  RequestTransaction(Rdy => TransactionRec(91).Rdy, Ack => TransactionRec(91).Ack) ; 
    1215            1                    ***0***           when 92 =>  RequestTransaction(Rdy => TransactionRec(92).Rdy, Ack => TransactionRec(92).Ack) ; 
    1216            1                    ***0***           when 93 =>  RequestTransaction(Rdy => TransactionRec(93).Rdy, Ack => TransactionRec(93).Ack) ; 
    1217            1                    ***0***           when 94 =>  RequestTransaction(Rdy => TransactionRec(94).Rdy, Ack => TransactionRec(94).Ack) ; 
    1218            1                    ***0***           when 95 =>  RequestTransaction(Rdy => TransactionRec(95).Rdy, Ack => TransactionRec(95).Ack) ; 
    1219            1                    ***0***           when 96 =>  RequestTransaction(Rdy => TransactionRec(96).Rdy, Ack => TransactionRec(96).Ack) ; 
    1220            1                    ***0***           when 97 =>  RequestTransaction(Rdy => TransactionRec(97).Rdy, Ack => TransactionRec(97).Ack) ; 
    1221            1                    ***0***           when 98 =>  RequestTransaction(Rdy => TransactionRec(98).Rdy, Ack => TransactionRec(98).Ack) ; 
    1222            1                    ***0***           when 99 =>  RequestTransaction(Rdy => TransactionRec(99).Rdy, Ack => TransactionRec(99).Ack) ; 
    1223            1                    ***0***           when 100 =>  RequestTransaction(Rdy => TransactionRec(100).Rdy, Ack => TransactionRec(100).Ack) ; 
    1224            1                    ***0***           when 101 =>  RequestTransaction(Rdy => TransactionRec(101).Rdy, Ack => TransactionRec(101).Ack) ; 
    1225            1                    ***0***           when 102 =>  RequestTransaction(Rdy => TransactionRec(102).Rdy, Ack => TransactionRec(102).Ack) ; 
    1226            1                    ***0***           when 103 =>  RequestTransaction(Rdy => TransactionRec(103).Rdy, Ack => TransactionRec(103).Ack) ; 
    1227            1                    ***0***           when 104 =>  RequestTransaction(Rdy => TransactionRec(104).Rdy, Ack => TransactionRec(104).Ack) ; 
    1228            1                    ***0***           when 105 =>  RequestTransaction(Rdy => TransactionRec(105).Rdy, Ack => TransactionRec(105).Ack) ; 
    1229            1                    ***0***           when 106 =>  RequestTransaction(Rdy => TransactionRec(106).Rdy, Ack => TransactionRec(106).Ack) ; 
    1230            1                    ***0***           when 107 =>  RequestTransaction(Rdy => TransactionRec(107).Rdy, Ack => TransactionRec(107).Ack) ; 
    1231            1                    ***0***           when 108 =>  RequestTransaction(Rdy => TransactionRec(108).Rdy, Ack => TransactionRec(108).Ack) ; 
    1232            1                    ***0***           when 109 =>  RequestTransaction(Rdy => TransactionRec(109).Rdy, Ack => TransactionRec(109).Ack) ; 
    1233            1                    ***0***           when 110 =>  RequestTransaction(Rdy => TransactionRec(110).Rdy, Ack => TransactionRec(110).Ack) ; 
    1234            1                    ***0***           when 111 =>  RequestTransaction(Rdy => TransactionRec(111).Rdy, Ack => TransactionRec(111).Ack) ; 
    1235            1                    ***0***           when 112 =>  RequestTransaction(Rdy => TransactionRec(112).Rdy, Ack => TransactionRec(112).Ack) ; 
    1236            1                    ***0***           when 113 =>  RequestTransaction(Rdy => TransactionRec(113).Rdy, Ack => TransactionRec(113).Ack) ; 
    1237            1                    ***0***           when 114 =>  RequestTransaction(Rdy => TransactionRec(114).Rdy, Ack => TransactionRec(114).Ack) ; 
    1238            1                    ***0***           when 115 =>  RequestTransaction(Rdy => TransactionRec(115).Rdy, Ack => TransactionRec(115).Ack) ; 
    1239            1                    ***0***           when 116 =>  RequestTransaction(Rdy => TransactionRec(116).Rdy, Ack => TransactionRec(116).Ack) ; 
    1240            1                    ***0***           when 117 =>  RequestTransaction(Rdy => TransactionRec(117).Rdy, Ack => TransactionRec(117).Ack) ; 
    1241            1                    ***0***           when 118 =>  RequestTransaction(Rdy => TransactionRec(118).Rdy, Ack => TransactionRec(118).Ack) ; 
    1242            1                    ***0***           when 119 =>  RequestTransaction(Rdy => TransactionRec(119).Rdy, Ack => TransactionRec(119).Ack) ; 
    1243            1                    ***0***           when 120 =>  RequestTransaction(Rdy => TransactionRec(120).Rdy, Ack => TransactionRec(120).Ack) ; 
    1244            1                    ***0***           when 121 =>  RequestTransaction(Rdy => TransactionRec(121).Rdy, Ack => TransactionRec(121).Ack) ; 
    1245            1                    ***0***           when 122 =>  RequestTransaction(Rdy => TransactionRec(122).Rdy, Ack => TransactionRec(122).Ack) ; 
    1246            1                    ***0***           when 123 =>  RequestTransaction(Rdy => TransactionRec(123).Rdy, Ack => TransactionRec(123).Ack) ; 
    1247            1                    ***0***           when 124 =>  RequestTransaction(Rdy => TransactionRec(124).Rdy, Ack => TransactionRec(124).Ack) ; 
    1248            1                    ***0***           when 125 =>  RequestTransaction(Rdy => TransactionRec(125).Rdy, Ack => TransactionRec(125).Ack) ; 
    1249            1                    ***0***           when 126 =>  RequestTransaction(Rdy => TransactionRec(126).Rdy, Ack => TransactionRec(126).Ack) ; 
    1250            1                    ***0***           when 127 =>  RequestTransaction(Rdy => TransactionRec(127).Rdy, Ack => TransactionRec(127).Ack) ; 
    1251            1                    ***0***           when 128 =>  RequestTransaction(Rdy => TransactionRec(128).Rdy, Ack => TransactionRec(128).Ack) ; 
    1252            1                    ***0***           when 129 =>  RequestTransaction(Rdy => TransactionRec(129).Rdy, Ack => TransactionRec(129).Ack) ; 
    1253            1                    ***0***           when others => Alert("StreamTransactionArrayPkg: Please extend StreamArrayRequestTransaction to handle " & to_string(Index) & " indices") ; 
    1254                                                 end case ;  
    1255                                               end procedure StreamArrayRequestTransaction ; 
    1256                                             
    1257                                               -- ========================================================
    1258                                               --  Directive Transactions  
    1259                                               --  Directive transactions interact with the verification component 
    1260                                               --  without generating any transactions or interface waveforms.
    1261                                               --  Supported by all verification components
    1262                                               -- ========================================================
    1263                                               ------------------------------------------------------------
    1264                                               procedure WaitForTransaction (
    1265                                               --  Wait until pending (transmit) or next (receive) transaction(s) complete
    1266                                               ------------------------------------------------------------
    1267                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1268                                                 constant  Index            : in    integer 
    1269                                               ) is
    1270                                               begin
    1271            1                    ***0***         TransactionRec(Index).Operation   <= WAIT_FOR_TRANSACTION ;
    1272            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    1273                                               end procedure WaitForTransaction ; 
    1274                                             
    1275                                               ------------------------------------------------------------
    1276                                               procedure WaitForClock (
    1277                                               -- Wait for NumberOfClocks number of clocks 
    1278                                               -- relative to the verification component clock
    1279                                               ------------------------------------------------------------
    1280                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1281                                                 constant  Index            : in    integer ;
    1282                                                 constant  WaitCycles       : in    natural := 1
    1283                                               ) is
    1284                                               begin
    1285            1                    ***0***         TransactionRec(Index).Operation   <= WAIT_FOR_CLOCK ;
    1286            1                    ***0***         TransactionRec(Index).IntToModel  <= WaitCycles ; 
    1287            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    1288                                               end procedure WaitForClock ; 
    1289                                             
    1290                                               ------------------------------------------------------------
    1291                                               procedure GetTransactionCount (
    1292                                               -- Get the number of transactions handled by the model.  
    1293                                               ------------------------------------------------------------
    1294                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1295                                                 constant  Index            : in    integer ;
    1296                                                 variable  TransactionCount : out   integer 
    1297                                               ) is
    1298                                               begin
    1299            1                    ***0***         TransactionRec(Index).Operation   <= GET_TRANSACTION_COUNT ;
    1300            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    1301            1                    ***0***         TransactionCount := TransactionRec(Index).IntFromModel ; 
    1302                                               end procedure GetTransactionCount ; 
    1303                                             
    1304                                               ------------------------------------------------------------
    1305                                               procedure GetAlertLogID (
    1306                                               -- Get the AlertLogID from the verification component.
    1307                                               ------------------------------------------------------------
    1308                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1309                                                 constant  Index            : in    integer ;
    1310                                                 variable  AlertLogID       : out   AlertLogIDType 
    1311                                               ) is
    1312                                               begin
    1313            1                    ***0***         TransactionRec(Index).Operation   <= GET_ALERTLOG_ID ;
    1314            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    1315            1                    ***0***         AlertLogID := AlertLogIDType(TransactionRec(Index).IntFromModel) ; 
    1316                                               end procedure GetAlertLogID ; 
    1317                                               
    1318                                               ------------------------------------------------------------
    1319                                               procedure GetErrorCount (
    1320                                               -- Error reporting for testbenches that do not use OSVVM AlertLogPkg
    1321                                               -- Returns error count.  If an error count /= 0, also print errors
    1322                                               ------------------------------------------------------------
    1323                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1324                                                 constant  Index            : in    integer ;
    1325                                                 variable  ErrorCount       : out   natural
    1326                                               ) is
    1327                                                 variable  AlertLogID : AlertLogIDType ;
    1328                                               begin
    1329            1                    ***0***         GetAlertLogID(TransactionRec, Index, AlertLogID) ;
    1330                                             --    ReportNonZeroAlerts(AlertLogID => AlertLogID) ;
    1331            1                    ***0***         ErrorCount := GetAlertCount(AlertLogID => AlertLogID) ;
    1332                                               end procedure GetErrorCount ; 
    1333                                               
    1334                                               -- ========================================================
    1335                                               --  Delay Coverage Transactions   
    1336                                               --  Get Delay Coverage ID to change delay coverage parameters.
    1337                                               -- ========================================================
    1338                                               ------------------------------------------------------------
    1339                                               procedure SetUseRandomDelays (
    1340                                               ------------------------------------------------------------
    1341                                                 signal    TransactionRec : InOut StreamRecArrayType ;
    1342                                                 constant  Index          : in    integer ;
    1343                                                 constant  OptVal         : In    boolean := TRUE
    1344                                               ) is
    1345                                               begin
    1346            1                    ***0***         TransactionRec(Index).Operation     <= SET_USE_RANDOM_DELAYS ;
    1347            1                    ***0***         TransactionRec(Index).BoolToModel   <= OptVal ;
    1348            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1349                                               end procedure SetUseRandomDelays ;
    1350                                             
    1351                                               ------------------------------------------------------------
    1352                                               procedure GetUseRandomDelays (
    1353                                               ------------------------------------------------------------
    1354                                                 signal    TransactionRec : InOut StreamRecArrayType ;
    1355                                                 constant  Index          : in    integer ;
    1356                                                 variable  OptVal         : Out   boolean
    1357                                               ) is
    1358                                               begin
    1359            1                    ***0***         TransactionRec(Index).Operation     <= GET_USE_RANDOM_DELAYS ;
    1360            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1361            1                    ***0***         OptVal := TransactionRec(Index).BoolFromModel    ;
    1362                                               end procedure GetUseRandomDelays ;
    1363                                             
    1364                                               ------------------------------------------------------------
    1365                                               procedure SetDelayCoverageID (
    1366                                               ------------------------------------------------------------
    1367                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1368                                                 constant  Index            : in    integer ;
    1369                                                 constant  DelayCov         : in    DelayCoverageIdType 
    1370                                               ) is
    1371                                               begin
    1372            1                    ***0***         TransactionRec(Index).Operation     <= SET_DELAYCOV_ID ;
    1373            1                    ***0***         TransactionRec(Index).IntToModel    <= DelayCov.ID ;
    1374            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1375                                               end procedure SetDelayCoverageID ;
    1376                                             
    1377                                               ------------------------------------------------------------
    1378                                               procedure GetDelayCoverageID (
    1379                                               ------------------------------------------------------------
    1380                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1381                                                 constant  Index            : in    integer ;
    1382                                                 variable  DelayCov         : out   DelayCoverageIdType 
    1383                                               ) is
    1384                                               begin
    1385            1                    ***0***         TransactionRec(Index).Operation     <= GET_DELAYCOV_ID ;
    1386            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1387            1                    ***0***         DelayCov := GetDelayCoverage(TransactionRec(Index).IntFromModel) ; 
    1388                                               end procedure GetDelayCoverageID ;
    1389                                             
    1390                                               -- ========================================================
    1391                                               --  Set and Get Burst Mode   
    1392                                               --  Set Burst Mode for models that do bursting.
    1393                                               -- ========================================================
    1394                                               ------------------------------------------------------------
    1395                                               procedure SetBurstMode (
    1396                                               ------------------------------------------------------------
    1397                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1398                                                 constant  Index            : in    integer ;
    1399                                                 constant  OptVal           : in    StreamFifoBurstModeType
    1400                                               ) is
    1401                                               begin
    1402            1                    ***0***         TransactionRec(Index).Operation     <= SET_BURST_MODE ;
    1403            1                    ***0***         TransactionRec(Index).IntToModel    <= OptVal ;
    1404            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1405                                               end procedure SetBurstMode ;
    1406                                             
    1407                                               ------------------------------------------------------------
    1408                                               procedure GetBurstMode (
    1409                                               ------------------------------------------------------------
    1410                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1411                                                 constant  Index            : in    integer ;
    1412                                                 variable  OptVal           : out   StreamFifoBurstModeType
    1413                                               ) is
    1414                                               begin
    1415            1                    ***0***         TransactionRec(Index).Operation     <= GET_BURST_MODE ;
    1416            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1417            1                    ***0***         OptVal := TransactionRec(Index).IntFromModel ; 
    1418                                               end procedure GetBurstMode ;
    1419                                             
    1420                                               ------------------------------------------------------------
    1421                                               --  GotBurst   
    1422                                               -- Check to see if Read Burst is available
    1423                                               ------------------------------------------------------------
    1424                                               ------------------------------------------------------------
    1425                                               procedure GotBurst (
    1426                                               ------------------------------------------------------------
    1427                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1428                                                 constant  Index            : in    integer ;
    1429                                                 constant  NumFifoWords     : in    integer ;
    1430                                                 variable  Available        : out   boolean
    1431                                               ) is
    1432                                               begin
    1433            1                    ***0***         TransactionRec(Index).Operation   <= GOT_BURST ;
    1434                                                 -- NumFifoWords not used in all implementations - needed when interface has no burst capability
    1435            1                    ***0***         TransactionRec(Index).IntToModel  <= NumFifoWords ; 
    1436            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1437            1                    ***0***         Available := TransactionRec(Index).BoolFromModel ; 
    1438                                               end procedure GotBurst ;
    1439                                             
    1440                                               -- ========================================================
    1441                                               --  Set and Get Model Options  
    1442                                               --  Model operations are directive transactions that are  
    1443                                               --  used to configure the verification component.  
    1444                                               --  They can either be used directly or with a model specific
    1445                                               --  wrapper around them - see AXI models for examples.
    1446                                               -- ========================================================
    1447                                               ------------------------------------------------------------
    1448                                               procedure SetModelOptions (
    1449                                               ------------------------------------------------------------
    1450                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1451                                                 constant  Index            : in    integer ;
    1452                                                 constant  Option           : in    integer ;
    1453                                                 constant  OptVal           : in    boolean
    1454                                               ) is
    1455                                               begin
    1456            1                    ***0***         TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;
    1457            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1458            1                    ***0***         TransactionRec(Index).BoolToModel   <= OptVal ;
    1459            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1460                                               end procedure SetModelOptions ;
    1461                                             
    1462                                               ------------------------------------------------------------
    1463                                               procedure SetModelOptions (
    1464                                               ------------------------------------------------------------
    1465                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1466                                                 constant  Index            : in    integer ;
    1467                                                 constant  Option           : in    integer ;
    1468                                                 constant  OptVal           : in    integer
    1469                                               ) is
    1470                                               begin
    1471            1                    ***0***         TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;
    1472            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1473            1                    ***0***         TransactionRec(Index).IntToModel    <= OptVal ;
    1474            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1475                                               end procedure SetModelOptions ;
    1476                                             
    1477                                               ------------------------------------------------------------
    1478                                               procedure SetModelOptions (
    1479                                               ------------------------------------------------------------
    1480                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1481                                                 constant  Index            : in    integer ;
    1482                                                 constant  Option           : in    integer ;
    1483                                                 constant  OptVal           : in    std_logic_vector
    1484                                               ) is
    1485                                               begin
    1486            1                    ***0***         TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;
    1487            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1488            1                    ***0***         TransactionRec(Index).IntToModel    <= to_integer(OptVal) ;
    1489            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1490                                               end procedure SetModelOptions ;
    1491                                               
    1492                                               ------------------------------------------------------------
    1493                                               procedure SetModelOptions (
    1494                                               ------------------------------------------------------------
    1495                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1496                                                 constant  Index            : in    integer ;
    1497                                                 constant  Option           : in    integer ;
    1498                                                 constant  OptVal           : in    time
    1499                                               ) is
    1500                                               begin
    1501            1                    ***0***         TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;
    1502            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1503            1                    ***0***         TransactionRec(Index).TimeToModel   <= OptVal ;
    1504            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1505                                               end procedure SetModelOptions ;
    1506                                             
    1507                                               ------------------------------------------------------------
    1508                                               procedure SetModelOptions (
    1509                                               ------------------------------------------------------------
    1510                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1511                                                 constant  Index            : in    integer ;
    1512                                                 constant  Option           : in    integer 
    1513                                               ) is
    1514                                               begin
    1515            1                    ***0***         TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;
    1516            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1517                                                 -- OptVal handled by Model Specific Package
    1518                                                 -- TransactionRec(Index).IntToModel    <= to_integer(OptVal) ;
    1519            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1520                                               end procedure SetModelOptions ;
    1521                                             
    1522                                               ------------------------------------------------------------
    1523                                               procedure GetModelOptions (
    1524                                               ------------------------------------------------------------
    1525                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1526                                                 constant  Index            : in    integer ;
    1527                                                 constant  Option           : in    integer ;
    1528                                                 variable  OptVal           : out   boolean
    1529                                               ) is
    1530                                               begin
    1531            1                    ***0***         TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;
    1532            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1533            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1534            1                    ***0***         OptVal := TransactionRec(Index).BoolFromModel    ;
    1535                                               end procedure GetModelOptions ;
    1536                                             
    1537                                               ------------------------------------------------------------
    1538                                               procedure GetModelOptions (
    1539                                               ------------------------------------------------------------
    1540                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1541                                                 constant  Index            : in    integer ;
    1542                                                 constant  Option           : in    integer ;
    1543                                                 variable  OptVal           : out   integer
    1544                                               ) is
    1545                                               begin
    1546            1                    ***0***         TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;
    1547            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1548            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1549            1                    ***0***         OptVal := TransactionRec(Index).IntFromModel ; 
    1550                                               end procedure GetModelOptions ;
    1551                                             
    1552                                               ------------------------------------------------------------
    1553                                               procedure GetModelOptions (
    1554                                               ------------------------------------------------------------
    1555                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1556                                                 constant  Index            : in    integer ;
    1557                                                 constant  Option           : in    integer ;
    1558                                                 variable  OptVal           : out   std_logic_vector
    1559                                               ) is
    1560                                               begin
    1561            1                    ***0***         TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;
    1562            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1563            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1564            1                    ***0***         OptVal := to_slv(TransactionRec(Index).IntFromModel, OptVal'length) ; 
    1565                                               end procedure GetModelOptions ;
    1566                                               
    1567                                               ------------------------------------------------------------
    1568                                               procedure GetModelOptions (
    1569                                               ------------------------------------------------------------
    1570                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1571                                                 constant  Index            : in    integer ;
    1572                                                 constant  Option           : in    integer ;
    1573                                                 variable  OptVal           : out   time
    1574                                               ) is
    1575                                               begin
    1576            1                    ***0***         TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;
    1577            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1578            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1579            1                    ***0***         OptVal := TransactionRec(Index).TimeFromModel ; 
    1580                                               end procedure GetModelOptions ;
    1581                                             
    1582                                               ------------------------------------------------------------
    1583                                               procedure GetModelOptions (
    1584                                               ------------------------------------------------------------
    1585                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1586                                                 constant  Index            : in    integer ;
    1587                                                 constant  Option           : in    integer 
    1588                                               ) is
    1589                                               begin
    1590            1                    ***0***         TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;
    1591            1                    ***0***         TransactionRec(Index).Options       <= Option ;
    1592            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;
    1593                                                 -- OptVal handled by Model Specific layer overloading
    1594                                                 -- OptVal := TransactionRec(Index).TimeFromModel ; 
    1595                                               end procedure GetModelOptions ;
    1596                                             
    1597                                             
    1598                                               -- ========================================================
    1599                                               --  Transmitter Transactions
    1600                                               -- ========================================================
    1601                                               
    1602                                               -- ========================================================
    1603                                               -- Send
    1604                                               -- Blocking Send Transaction. 
    1605                                               -- Param, when present, is an extra parameter used by the verification component
    1606                                               -- The UART verification component uses Param for error injection.
    1607                                               -- ========================================================
    1608                                               ------------------------------------------------------------
    1609                                               procedure LocalSend (
    1610                                               -- Package Local - simplifies the other calls to Send
    1611                                               ------------------------------------------------------------
    1612                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1613                                                 constant  Index            : in    integer ;
    1614                                                 constant  Operation        : in    StreamOperationType ;
    1615                                                 constant  Data             : in    std_logic_vector ;
    1616                                                 constant  Param            : in    std_logic_vector ;
    1617                                                 constant  StatusMsgOn      : in    boolean := false 
    1618                                               ) is 
    1619                                                 variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;
    1620                                               begin
    1621            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    1622            1                    ***0***         TransactionRec(Index).Operation     <= Operation ;
    1623            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(Data, TransactionRec(Index).DataToModel'length) ; 
    1624            1                    ***0***         TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; 
    1625            1                    ***0***         TransactionRec(Index).IntToModel    <= Data'length ;
    1626            1                    ***0***         TransactionRec(Index).BoolToModel   <= StatusMsgOn ; 
    1627            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    1628                                               end procedure LocalSend ; 
    1629                                             
    1630                                               ------------------------------------------------------------
    1631                                               procedure Send (
    1632                                               ------------------------------------------------------------
    1633                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1634                                                 constant  Index            : in    integer ;
    1635                                                 constant  Data             : in    std_logic_vector ;
    1636                                                 constant  Param            : in    std_logic_vector ;
    1637                                                 constant  StatusMsgOn      : in    boolean := false 
    1638                                               ) is 
    1639                                               begin
    1640            1                    ***0***         LocalSend(TransactionRec, Index, SEND, Data, Param, StatusMsgOn) ;
    1641                                               end procedure Send ; 
    1642                                             
    1643                                               ------------------------------------------------------------
    1644                                               procedure Send (
    1645                                               ------------------------------------------------------------
    1646                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1647                                                 constant  Index            : in    integer ;
    1648                                                 constant  Data             : in    std_logic_vector ;
    1649                                                 constant  StatusMsgOn      : in    boolean := false 
    1650                                               ) is 
    1651                                               begin
    1652            1                    ***0***         LocalSend(TransactionRec, Index, SEND, Data, "", StatusMsgOn);
    1653                                               end procedure Send ; 
    1654                                             
    1655                                               -- ========================================================
    1656                                               -- SendAsync
    1657                                               -- Asynchronous / Non-Blocking Send Transaction
    1658                                               -- Param, when present, is an extra parameter used by the verification component
    1659                                               -- The UART verification component uses Param for error injection. 
    1660                                               -- ========================================================
    1661                                             
    1662                                               ------------------------------------------------------------
    1663                                               procedure SendAsync (
    1664                                               ------------------------------------------------------------
    1665                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1666                                                 constant  Index            : in    integer ;
    1667                                                 constant  Data             : in    std_logic_vector ;
    1668                                                 constant  Param            : in    std_logic_vector ;
    1669                                                 constant  StatusMsgOn      : in    boolean := false 
    1670                                               ) is 
    1671                                               begin
    1672            1                    ***0***         LocalSend(TransactionRec, Index, SEND_ASYNC, Data, Param, StatusMsgOn) ;
    1673                                               end procedure SendAsync ; 
    1674                                             
    1675                                               ------------------------------------------------------------
    1676                                               procedure SendAsync (
    1677                                               ------------------------------------------------------------
    1678                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1679                                                 constant  Index            : in    integer ;
    1680                                                 constant  Data             : in    std_logic_vector ;
    1681                                                 constant  StatusMsgOn      : in    boolean := false 
    1682                                               ) is 
    1683                                               begin
    1684            1                    ***0***         LocalSend(TransactionRec, Index, SEND_ASYNC, Data, "", StatusMsgOn);
    1685                                               end procedure SendAsync ; 
    1686                                             
    1687                                             
    1688                                               -- ========================================================
    1689                                               -- SendBurst
    1690                                               -- Blocking Send Burst Transaction. 
    1691                                               -- Param, when present, is an extra parameter used by the verification component
    1692                                               -- The UART verification component uses Param for error injection.
    1693                                               -- ========================================================
    1694                                               ------------------------------------------------------------
    1695                                               procedure LocalSendBurst (
    1696                                               -- Package Local - simplifies the other calls to Send
    1697                                               ------------------------------------------------------------
    1698                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1699                                                 constant  Index            : in    integer ;
    1700                                                 constant  Operation        : in    StreamOperationType ;
    1701                                                 constant  NumFifoWords     : in    integer ;
    1702                                                 constant  Param            : in    std_logic_vector ;
    1703                                                 constant  StatusMsgOn      : in    boolean := false 
    1704                                               ) is 
    1705                                                 variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;
    1706                                               begin
    1707            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    1708            1                    ***0***         TransactionRec(Index).Operation     <= Operation ;
    1709            1                    ***0***         TransactionRec(Index).IntToModel    <= NumFifoWords ; 
    1710            1                    ***0***         TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; 
    1711            1                    ***0***         TransactionRec(Index).BoolToModel   <= StatusMsgOn ; 
    1712            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    1713                                               end procedure LocalSendBurst ; 
    1714                                             
    1715                                               ------------------------------------------------------------
    1716                                               procedure SendBurst (
    1717                                               ------------------------------------------------------------
    1718                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1719                                                 constant  Index            : in    integer ;
    1720                                                 constant  NumFifoWords     : in    integer ;
    1721                                                 constant  Param            : in    std_logic_vector ;
    1722                                                 constant  StatusMsgOn      : in    boolean := false 
    1723                                               ) is 
    1724                                               begin
    1725            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ;
    1726                                               end procedure SendBurst ; 
    1727                                             
    1728                                               ------------------------------------------------------------
    1729                                               procedure SendBurst (
    1730                                               ------------------------------------------------------------
    1731                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1732                                                 constant  Index            : in    integer ;
    1733                                                 constant  NumFifoWords     : in    integer ;
    1734                                                 constant  StatusMsgOn      : in    boolean := false 
    1735                                               ) is 
    1736                                               begin
    1737            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, "", StatusMsgOn) ;
    1738                                               end procedure SendBurst ; 
    1739                                             
    1740                                               ------------------------------------------------------------
    1741                                               procedure SendBurstVector (
    1742                                               ------------------------------------------------------------
    1743                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1744                                                 constant  Index            : in    integer ;
    1745                                                 constant  VectorOfWords    : in    slv_vector ;
    1746                                                 constant  Param            : in    std_logic_vector ;
    1747                                                 constant  StatusMsgOn      : in    boolean := false
    1748                                               ) is
    1749                                               begin
    1750            1                    ***0***         PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords) ;
    1751            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST, VectorOfWords'length, Param, StatusMsgOn) ; 
    1752                                               end procedure SendBurstVector ;
    1753                                               
    1754                                               ------------------------------------------------------------
    1755                                               procedure SendBurstVector (
    1756                                               ------------------------------------------------------------
    1757                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1758                                                 constant  Index            : in    integer ;
    1759                                                 constant  VectorOfWords    : in    slv_vector ;
    1760                                                 constant  StatusMsgOn      : in    boolean := false
    1761                                               ) is
    1762                                               begin
    1763            1                    ***0***         SendBurstVector(TransactionRec, Index, VectorOfWords, "", StatusMsgOn) ; 
    1764                                               end procedure SendBurstVector ;
    1765                                               
    1766                                               ------------------------------------------------------------
    1767                                               procedure SendBurstVector (
    1768                                               ------------------------------------------------------------
    1769                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1770                                                 constant  Index            : in    integer ;
    1771                                                 constant  VectorOfWords    : in    integer_vector ;
    1772                                                 constant  Param            : in    std_logic_vector ;
    1773                                                 constant  FifoWidth        : in    integer ; 
    1774                                                 constant  StatusMsgOn      : in    boolean := false
    1775                                               ) is
    1776                                               begin
    1777            1                    ***0***         PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords, FifoWidth) ;
    1778            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST, VectorOfWords'length, Param, StatusMsgOn) ; 
    1779                                               end procedure SendBurstVector ;
    1780                                               
    1781                                               ------------------------------------------------------------
    1782                                               procedure SendBurstVector (
    1783                                               ------------------------------------------------------------
    1784                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1785                                                 constant  Index            : in    integer ;
    1786                                                 constant  VectorOfWords    : in    integer_vector ;
    1787                                                 constant  FifoWidth        : in    integer ; 
    1788                                                 constant  StatusMsgOn      : in    boolean := false
    1789                                               ) is
    1790                                               begin
    1791            1                    ***0***         SendBurstVector(TransactionRec, Index, VectorOfWords, "", FifoWidth, StatusMsgOn) ; 
    1792                                               end procedure SendBurstVector ;
    1793                                               
    1794                                               ------------------------------------------------------------
    1795                                               procedure SendBurstIncrement (
    1796                                               ------------------------------------------------------------
    1797                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1798                                                 constant  Index            : in    integer ;
    1799                                                 constant  FirstWord        : in    std_logic_vector ;
    1800                                                 constant  NumFifoWords     : in    integer ;
    1801                                                 constant  Param            : in    std_logic_vector ;
    1802                                                 constant  StatusMsgOn      : in    boolean := false
    1803                                               ) is
    1804                                               begin
    1805            1                    ***0***         PushBurstIncrement(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;
    1806            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; 
    1807                                               end procedure SendBurstIncrement ;
    1808                                               
    1809                                               ------------------------------------------------------------
    1810                                               procedure SendBurstIncrement (
    1811                                               ------------------------------------------------------------
    1812                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1813                                                 constant  Index            : in    integer ;
    1814                                                 constant  FirstWord        : in    std_logic_vector ;
    1815                                                 constant  NumFifoWords     : in    integer ;
    1816                                                 constant  StatusMsgOn      : in    boolean := false
    1817                                               ) is
    1818                                               begin
    1819            1                    ***0***         SendBurstIncrement(TransactionRec, Index, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    1820                                               end procedure SendBurstIncrement ;
    1821                                             
    1822                                               ------------------------------------------------------------
    1823                                               procedure SendBurstRandom (
    1824                                               ------------------------------------------------------------
    1825                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1826                                                 constant  Index            : in    integer ;
    1827                                                 constant  FirstWord        : in    std_logic_vector ;
    1828                                                 constant  NumFifoWords     : in    integer ;
    1829                                                 constant  Param            : in    std_logic_vector ;
    1830                                                 constant  StatusMsgOn      : in    boolean := false
    1831                                               ) is
    1832                                               begin
    1833            1                    ***0***         PushBurstRandom(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;
    1834            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; 
    1835                                               end procedure SendBurstRandom ;
    1836                                               
    1837                                               ------------------------------------------------------------
    1838                                               procedure SendBurstRandom (
    1839                                               ------------------------------------------------------------
    1840                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1841                                                 constant  Index            : in    integer ;
    1842                                                 constant  FirstWord        : in    std_logic_vector ;
    1843                                                 constant  NumFifoWords     : in    integer ;
    1844                                                 constant  StatusMsgOn      : in    boolean := false
    1845                                               ) is
    1846                                               begin
    1847            1                    ***0***         SendBurstRandom(TransactionRec, Index, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    1848                                               end procedure SendBurstRandom ;
    1849                                             
    1850                                               ------------------------------------------------------------
    1851                                               procedure SendBurstRandom (
    1852                                               ------------------------------------------------------------
    1853                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1854                                                 constant  Index            : in    integer ;
    1855                                                 constant  CoverID          : in    CoverageIDType ;
    1856                                                 constant  NumFifoWords     : in    integer ;
    1857                                                 constant  FifoWidth        : in    integer ;
    1858                                                 constant  Param            : in    std_logic_vector ;
    1859                                                 constant  StatusMsgOn      : in    boolean := false
    1860                                               ) is
    1861                                               begin
    1862            1                    ***0***         PushBurstRandom(TransactionRec(Index).BurstFifo, CoverID, NumFifoWords, FifoWidth) ;
    1863            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; 
    1864                                               end procedure SendBurstRandom ;  
    1865                                             
    1866                                               ------------------------------------------------------------
    1867                                               procedure SendBurstRandom (
    1868                                               ------------------------------------------------------------
    1869                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1870                                                 constant  Index            : in    integer ;
    1871                                                 constant  CoverID          : in    CoverageIDType ;
    1872                                                 constant  NumFifoWords     : in    integer ;
    1873                                                 constant  FifoWidth        : in    integer ;
    1874                                                 constant  StatusMsgOn      : in    boolean := false
    1875                                               ) is
    1876                                               begin
    1877            1                    ***0***         SendBurstRandom(TransactionRec, Index, CoverID, NumFifoWords, FifoWidth, "", StatusMsgOn) ; 
    1878                                               end procedure SendBurstRandom ;  
    1879                                             
    1880                                             
    1881                                               -- ========================================================
    1882                                               -- SendBurstAsync
    1883                                               -- Asynchronous / Non-Blocking Send Transaction
    1884                                               -- Param, when present, is an extra parameter used by the verification component
    1885                                               -- The UART verification component uses Param for error injection. 
    1886                                               -- ========================================================
    1887                                             
    1888                                               ------------------------------------------------------------
    1889                                               procedure SendBurstAsync (
    1890                                               ------------------------------------------------------------
    1891                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1892                                                 constant  Index            : in    integer ;
    1893                                                 constant  NumFifoWords     : in    integer ;
    1894                                                 constant  Param            : in    std_logic_vector ;
    1895                                                 constant  StatusMsgOn      : in    boolean := false 
    1896                                               ) is 
    1897                                               begin
    1898            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ;
    1899                                               end procedure SendBurstAsync ; 
    1900                                             
    1901                                               ------------------------------------------------------------
    1902                                               procedure SendBurstAsync (
    1903                                               ------------------------------------------------------------
    1904                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1905                                                 constant  Index            : in    integer ;
    1906                                                 constant  NumFifoWords     : in    integer ;
    1907                                                 constant  StatusMsgOn      : in    boolean := false 
    1908                                               ) is 
    1909                                               begin
    1910            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, "", StatusMsgOn) ;
    1911                                               end procedure SendBurstAsync ; 
    1912                                             
    1913                                               ------------------------------------------------------------
    1914                                               procedure SendBurstVectorAsync (
    1915                                               ------------------------------------------------------------
    1916                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1917                                                 constant  Index            : in    integer ;
    1918                                                 constant  VectorOfWords    : in    slv_vector ;
    1919                                                 constant  Param            : in    std_logic_vector ;
    1920                                                 constant  StatusMsgOn      : in    boolean := false
    1921                                               ) is
    1922                                               begin
    1923            1                    ***0***         PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords) ;
    1924            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, VectorOfWords'length, Param, StatusMsgOn) ; 
    1925                                               end procedure SendBurstVectorAsync ;
    1926                                               
    1927                                               ------------------------------------------------------------
    1928                                               procedure SendBurstVectorAsync (
    1929                                               ------------------------------------------------------------
    1930                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1931                                                 constant  Index            : in    integer ;
    1932                                                 constant  VectorOfWords    : in    slv_vector ;
    1933                                                 constant  StatusMsgOn      : in    boolean := false
    1934                                               ) is
    1935                                               begin
    1936            1                    ***0***         SendBurstVectorAsync(TransactionRec, Index, VectorOfWords, "", StatusMsgOn) ; 
    1937                                               end procedure SendBurstVectorAsync ;
    1938                                               
    1939                                               ------------------------------------------------------------
    1940                                               procedure SendBurstVectorAsync (
    1941                                               ------------------------------------------------------------
    1942                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1943                                                 constant  Index            : in    integer ;
    1944                                                 constant  VectorOfWords    : in    integer_vector ;
    1945                                                 constant  Param            : in    std_logic_vector ;
    1946                                                 constant  FifoWidth        : in    integer ; 
    1947                                                 constant  StatusMsgOn      : in    boolean := false
    1948                                               ) is
    1949                                               begin
    1950            1                    ***0***         PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords, FifoWidth) ;
    1951            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, VectorOfWords'length, Param, StatusMsgOn) ; 
    1952                                               end procedure SendBurstVectorAsync ;
    1953                                               
    1954                                               ------------------------------------------------------------
    1955                                               procedure SendBurstVectorAsync (
    1956                                               ------------------------------------------------------------
    1957                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1958                                                 constant  Index            : in    integer ;
    1959                                                 constant  VectorOfWords    : in    integer_vector ;
    1960                                                 constant  FifoWidth        : in    integer ; 
    1961                                                 constant  StatusMsgOn      : in    boolean := false
    1962                                               ) is
    1963                                               begin
    1964            1                    ***0***         SendBurstVectorAsync(TransactionRec, Index, VectorOfWords, "", FifoWidth, StatusMsgOn) ; 
    1965                                               end procedure SendBurstVectorAsync ;
    1966                                             
    1967                                               ------------------------------------------------------------
    1968                                               procedure SendBurstIncrementAsync (
    1969                                               ------------------------------------------------------------
    1970                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1971                                                 constant  Index            : in    integer ;
    1972                                                 constant  FirstWord        : in    std_logic_vector ;
    1973                                                 constant  NumFifoWords     : in    integer ;
    1974                                                 constant  Param            : in    std_logic_vector ;
    1975                                                 constant  StatusMsgOn      : in    boolean := false
    1976                                               ) is
    1977                                               begin
    1978            1                    ***0***         PushBurstIncrement(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;
    1979            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; 
    1980                                               end procedure SendBurstIncrementAsync ;
    1981                                             
    1982                                               ------------------------------------------------------------
    1983                                               procedure SendBurstIncrementAsync (
    1984                                               ------------------------------------------------------------
    1985                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1986                                                 constant  Index            : in    integer ;
    1987                                                 constant  FirstWord        : in    std_logic_vector ;
    1988                                                 constant  NumFifoWords     : in    integer ;
    1989                                                 constant  StatusMsgOn      : in    boolean := false
    1990                                               ) is
    1991                                               begin
    1992            1                    ***0***         SendBurstIncrementAsync(TransactionRec, Index, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    1993                                               end procedure SendBurstIncrementAsync ;
    1994                                             
    1995                                               ------------------------------------------------------------
    1996                                               procedure SendBurstRandomAsync (
    1997                                               ------------------------------------------------------------
    1998                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    1999                                                 constant  Index            : in    integer ;
    2000                                                 constant  FirstWord        : in    std_logic_vector ;
    2001                                                 constant  NumFifoWords     : in    integer ;
    2002                                                 constant  Param            : in    std_logic_vector ;
    2003                                                 constant  StatusMsgOn      : in    boolean := false
    2004                                               ) is
    2005                                               begin
    2006            1                    ***0***         PushBurstRandom(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;
    2007            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; 
    2008                                               end procedure SendBurstRandomAsync ;
    2009                                             
    2010                                               ------------------------------------------------------------
    2011                                               procedure SendBurstRandomAsync (
    2012                                               ------------------------------------------------------------
    2013                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2014                                                 constant  Index            : in    integer ;
    2015                                                 constant  FirstWord        : in    std_logic_vector ;
    2016                                                 constant  NumFifoWords     : in    integer ;
    2017                                                 constant  StatusMsgOn      : in    boolean := false
    2018                                               ) is
    2019                                                 variable RV : RandomPType ; 
    2020                                               begin
    2021            1                    ***0***         SendBurstRandomAsync(TransactionRec, Index, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    2022                                               end procedure SendBurstRandomAsync ;
    2023                                             
    2024                                               ------------------------------------------------------------
    2025                                               procedure SendBurstRandomAsync (
    2026                                               ------------------------------------------------------------
    2027                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2028                                                 constant  Index            : in    integer ;
    2029                                                 constant  CoverID          : in    CoverageIDType ;
    2030                                                 constant  NumFifoWords     : in    integer ;
    2031                                                 constant  FifoWidth        : in    integer ;
    2032                                                 constant  Param            : in    std_logic_vector ;
    2033                                                 constant  StatusMsgOn      : in    boolean := false
    2034                                               ) is
    2035                                               begin
    2036            1                    ***0***         PushBurstRandom(TransactionRec(Index).BurstFifo, CoverID, NumFifoWords, FifoWidth) ;
    2037            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; 
    2038                                               end procedure SendBurstRandomAsync ;  
    2039                                             
    2040                                               ------------------------------------------------------------
    2041                                               procedure SendBurstRandomAsync (
    2042                                               ------------------------------------------------------------
    2043                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2044                                                 constant  Index            : in    integer ;
    2045                                                 constant  CoverID          : in    CoverageIDType ;
    2046                                                 constant  NumFifoWords     : in    integer ;
    2047                                                 constant  FifoWidth        : in    integer ;
    2048                                                 constant  StatusMsgOn      : in    boolean := false
    2049                                               ) is
    2050                                               begin
    2051            1                    ***0***         SendBurstRandomAsync(TransactionRec, Index, CoverID, NumFifoWords, FifoWidth, "", StatusMsgOn) ; 
    2052                                               end procedure SendBurstRandomAsync ;  
    2053                                             
    2054                                             
    2055                                               -- ========================================================
    2056                                               --  Receiver Transactions
    2057                                               -- ========================================================
    2058                                             
    2059                                               -- ========================================================
    2060                                               -- Get
    2061                                               -- Blocking Get Transaction. 
    2062                                               -- Param, when present, is an extra parameter used by the verification component
    2063                                               -- The UART verification component uses Param for received error status.
    2064                                               -- ========================================================
    2065                                             
    2066                                               ------------------------------------------------------------
    2067                                               procedure Get (
    2068                                               ------------------------------------------------------------
    2069                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2070                                                 constant  Index            : in    integer ;
    2071                                                 variable  Data             : out   std_logic_vector ;
    2072                                                 constant  StatusMsgOn      : in    boolean := false 
    2073                                               ) is 
    2074                                               begin
    2075            1                    ***0***         TransactionRec(Index).Operation   <= GET ;
    2076            1                    ***0***         TransactionRec(Index).IntToModel  <= Data'length ;
    2077            1                    ***0***         TransactionRec(Index).BoolToModel <= StatusMsgOn ;     
    2078            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    2079            1                    ***0***         Data  := SafeResize(TransactionRec(Index).DataFromModel, Data'length) ; 
    2080                                               end procedure Get ; 
    2081                                               
    2082                                               ------------------------------------------------------------
    2083                                               procedure Get (
    2084                                               ------------------------------------------------------------
    2085                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2086                                                 constant  Index            : in    integer ;
    2087                                                 variable  Data             : out   std_logic_vector ;
    2088                                                 variable  Param            : out   std_logic_vector ;
    2089                                                 constant  StatusMsgOn      : in    boolean := false 
    2090                                               ) is 
    2091                                               begin
    2092            1                    ***0***         Get(TransactionRec, Index, Data, StatusMsgOn) ;
    2093            1                    ***0***         Param := SafeResize(TransactionRec(Index).ParamFromModel, Param'length) ; 
    2094                                               end procedure Get ;  
    2095                                             
    2096                                               -- ========================================================
    2097                                               -- TryGet
    2098                                               -- Try Get Transaction
    2099                                               -- If Data is available, get it and return available TRUE,
    2100                                               -- otherwise Return Available FALSE.
    2101                                               -- Param, when present, is an extra parameter used by the verification component
    2102                                               -- The UART verification component uses Param for received error status.
    2103                                               -- ========================================================
    2104                                             
    2105                                               ------------------------------------------------------------
    2106                                               procedure TryGet (
    2107                                               ------------------------------------------------------------
    2108                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2109                                                 constant  Index            : in    integer ;
    2110                                                 variable  Data             : out   std_logic_vector ;
    2111                                                 variable  Available        : out   boolean ;
    2112                                                 constant  StatusMsgOn      : in    boolean := false 
    2113                                               ) is 
    2114                                               begin
    2115            1                    ***0***         TransactionRec(Index).Operation   <= TRY_GET ;
    2116            1                    ***0***         TransactionRec(Index).IntToModel  <= Data'length ;
    2117            1                    ***0***         TransactionRec(Index).BoolToModel <= StatusMsgOn ;     
    2118            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    2119            1                    ***0***         Data      := SafeResize(TransactionRec(Index).DataFromModel, Data'length) ; 
    2120            1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    2121                                               end procedure TryGet ; 
    2122                                               
    2123                                               ------------------------------------------------------------
    2124                                               procedure TryGet (
    2125                                               ------------------------------------------------------------
    2126                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2127                                                 constant  Index            : in    integer ;
    2128                                                 variable  Data             : out   std_logic_vector ;
    2129                                                 variable  Param            : out   std_logic_vector ;
    2130                                                 variable  Available        : out   boolean ;
    2131                                                 constant  StatusMsgOn      : in    boolean := false 
    2132                                               ) is 
    2133                                               begin
    2134            1                    ***0***         TryGet(TransactionRec, Index, Data, Available, StatusMsgOn) ;
    2135            1                    ***0***         Param := SafeResize(TransactionRec(Index).ParamFromModel, Param'length) ; 
    2136                                               end procedure TryGet ;  
    2137                                             
    2138                                             
    2139                                               -- ========================================================
    2140                                               -- GetBurst
    2141                                               -- Blocking Get Burst Transaction. 
    2142                                               -- Param, when present, is an extra parameter from the verification component
    2143                                               -- The UART verification component uses Param for received error status.
    2144                                               -- ========================================================
    2145                                             
    2146                                               ------------------------------------------------------------
    2147                                               procedure LocalGetBurst (
    2148                                               ------------------------------------------------------------
    2149                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2150                                                 constant  Index            : in    integer ;
    2151                                                 constant  NumFifoWords     : in    integer ;
    2152                                                 constant  StatusMsgOn      : in    boolean := false 
    2153                                               ) is 
    2154                                               begin
    2155            1                    ***0***         TransactionRec(Index).Operation   <= GET_BURST ;
    2156            1                    ***0***         TransactionRec(Index).IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)
    2157            1                    ***0***         TransactionRec(Index).BoolToModel <= StatusMsgOn ;     
    2158            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    2159                                               end procedure LocalGetBurst ; 
    2160                                               
    2161                                               ------------------------------------------------------------
    2162                                               procedure GetBurst (
    2163                                               ------------------------------------------------------------
    2164                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2165                                                 constant  Index            : in    integer ;
    2166                                                 variable  NumFifoWords     : inout integer ;
    2167                                                 constant  StatusMsgOn      : in    boolean := false 
    2168                                               ) is 
    2169                                               begin
    2170            1                    ***0***         LocalGetBurst(TransactionRec, Index, NumFifoWords, StatusMsgOn) ; 
    2171            1                    ***0***         NumFifoWords := TransactionRec(Index).IntFromModel ;
    2172                                               end procedure GetBurst ; 
    2173                                               
    2174                                               ------------------------------------------------------------
    2175                                               procedure GetBurst (
    2176                                               ------------------------------------------------------------
    2177                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2178                                                 constant  Index            : in    integer ;
    2179                                                 variable  NumFifoWords     : inout integer ;
    2180                                                 variable  Param            : out   std_logic_vector ;
    2181                                                 constant  StatusMsgOn      : in    boolean := false 
    2182                                               ) is 
    2183                                               begin
    2184            1                    ***0***         LocalGetBurst(TransactionRec, Index, NumFifoWords, StatusMsgOn) ; 
    2185            1                    ***0***         NumFifoWords := TransactionRec(Index).IntFromModel ;
    2186            1                    ***0***         Param := SafeResize(TransactionRec(Index).ParamFromModel, Param'length) ; 
    2187                                               end procedure GetBurst ;  
    2188                                             
    2189                                               -- ========================================================
    2190                                               -- TryGetBurst
    2191                                               -- Try Get Burst Transaction
    2192                                               -- If Data is available, get it and return available TRUE,
    2193                                               -- otherwise Return Available FALSE.
    2194                                               -- Param, when present, is an extra parameter used by the verification component
    2195                                               -- The UART verification component uses Param for received error status.
    2196                                               -- ========================================================
    2197                                             
    2198                                               ------------------------------------------------------------
    2199                                               procedure LocalTryGetBurst (
    2200                                               ------------------------------------------------------------
    2201                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2202                                                 constant  Index            : in    integer ;
    2203                                                 constant  NumFifoWords     : in    integer ;
    2204                                                 variable  Available        : out   boolean ;
    2205                                                 constant  StatusMsgOn      : in    boolean := false 
    2206                                               ) is 
    2207                                               begin
    2208            1                    ***0***         TransactionRec(Index).Operation   <= TRY_GET_BURST ;
    2209            1                    ***0***         TransactionRec(Index).IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)
    2210            1                    ***0***         TransactionRec(Index).BoolToModel <= StatusMsgOn ;     
    2211            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    2212            1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    2213                                               end procedure LocalTryGetBurst ; 
    2214                                             
    2215                                               ------------------------------------------------------------
    2216                                               procedure TryGetBurst (
    2217                                               ------------------------------------------------------------
    2218                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2219                                                 constant  Index            : in    integer ;
    2220                                                 variable  NumFifoWords     : inout integer ;
    2221                                                 variable  Available        : out   boolean ;
    2222                                                 constant  StatusMsgOn      : in    boolean := false 
    2223                                               ) is 
    2224                                               begin
    2225            1                    ***0***         LocalTryGetBurst(TransactionRec, Index, NumFifoWords, Available, StatusMsgOn) ;
    2226            1                    ***0***         NumFifoWords  := TransactionRec(Index).IntFromModel ;
    2227                                               end procedure TryGetBurst ; 
    2228                                             
    2229                                               ------------------------------------------------------------
    2230                                               procedure TryGetBurst (
    2231                                               ------------------------------------------------------------
    2232                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2233                                                 constant  Index            : in    integer ;
    2234                                                 variable  NumFifoWords     : inout integer ;
    2235                                                 variable  Param            : out   std_logic_vector ;
    2236                                                 variable  Available        : out   boolean ;
    2237                                                 constant  StatusMsgOn      : in    boolean := false 
    2238                                               ) is 
    2239                                               begin
    2240            1                    ***0***         LocalTryGetBurst(TransactionRec, Index, NumFifoWords, Available, StatusMsgOn) ;
    2241            1                    ***0***         NumFifoWords  := TransactionRec(Index).IntFromModel ;
    2242            1                    ***0***         Param := SafeResize(TransactionRec(Index).ParamFromModel, Param'length) ; 
    2243                                               end procedure TryGetBurst ;  
    2244                                             
    2245                                             
    2246                                               -- ========================================================
    2247                                               -- Check
    2248                                               -- Blocking Get Transaction. 
    2249                                               -- Data is the expected value to be received.
    2250                                               -- Param, when present, is an extra parameter used by the verification component
    2251                                               -- The UART verification component uses Param for received error status.
    2252                                               -- ========================================================
    2253                                             
    2254                                               ------------------------------------------------------------
    2255                                               procedure Check (
    2256                                               ------------------------------------------------------------
    2257                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2258                                                 constant  Index            : in    integer ;
    2259                                                 constant  Data             : in    std_logic_vector ;
    2260                                                 constant  Param            : in    std_logic_vector ;
    2261                                                 constant  StatusMsgOn      : in    boolean := false 
    2262                                               ) is 
    2263                                                 variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;
    2264                                               begin
    2265            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    2266            1                    ***0***         TransactionRec(Index).Operation     <= CHECK ;
    2267            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(Data, TransactionRec(Index).DataToModel'length) ; 
    2268            1                    ***0***         TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; 
    2269            1                    ***0***         TransactionRec(Index).IntToModel    <= Data'length ;
    2270            1                    ***0***         TransactionRec(Index).BoolToModel   <= StatusMsgOn ;     
    2271            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    2272                                               end procedure Check ; 
    2273                                             
    2274                                               ------------------------------------------------------------
    2275                                               procedure Check (
    2276                                               ------------------------------------------------------------
    2277                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2278                                                 constant  Index            : in    integer ;
    2279                                                 constant  Data             : in    std_logic_vector ;
    2280                                                 constant  StatusMsgOn      : in    boolean := false 
    2281                                               ) is 
    2282                                               begin
    2283            1                    ***0***         Check(TransactionRec, Index, Data, "", StatusMsgOn) ;
    2284                                               end procedure Check ; 
    2285                                             
    2286                                             
    2287                                               -- ========================================================
    2288                                               -- TryCheck
    2289                                               -- Try Check Transaction
    2290                                               -- If Data is available, check it and return available TRUE,
    2291                                               -- otherwise Return Available FALSE.
    2292                                               -- Param, when present, is an extra parameter used by the verification component
    2293                                               -- The UART verification component uses Param for received error status.
    2294                                               -- ========================================================
    2295                                             
    2296                                               ------------------------------------------------------------
    2297                                               procedure TryCheck (
    2298                                               ------------------------------------------------------------
    2299                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2300                                                 constant  Index            : in    integer ;
    2301                                                 constant  Data             : in    std_logic_vector ;
    2302                                                 constant  Param            : in    std_logic_vector ;
    2303                                                 variable  Available        : out   boolean ;
    2304                                                 constant  StatusMsgOn      : in    boolean := false 
    2305                                               ) is 
    2306                                                 variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;
    2307                                               begin
    2308            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    2309            1                    ***0***         TransactionRec(Index).Operation     <= TRY_CHECK ;
    2310            1                    ***0***         TransactionRec(Index).DataToModel   <= SafeResize(Data, TransactionRec(Index).DataToModel'length) ; 
    2311            1                    ***0***         TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; 
    2312            1                    ***0***         TransactionRec(Index).IntToModel    <= Data'length ;
    2313            1                    ***0***         TransactionRec(Index).BoolToModel   <= StatusMsgOn ;     
    2314            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    2315            1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    2316                                               end procedure TryCheck ; 
    2317                                             
    2318                                               ------------------------------------------------------------
    2319                                               procedure TryCheck (
    2320                                               ------------------------------------------------------------
    2321                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2322                                                 constant  Index            : in    integer ;
    2323                                                 constant  Data             : in    std_logic_vector ;
    2324                                                 variable  Available        : out   boolean ;
    2325                                                 constant  StatusMsgOn      : in    boolean := false 
    2326                                               ) is 
    2327                                               begin
    2328            1                    ***0***         TryCheck(TransactionRec, Index, Data, "", Available, StatusMsgOn) ;
    2329                                               end procedure TryCheck ; 
    2330                                             
    2331                                             
    2332                                               -- ========================================================
    2333                                               -- CheckBurst
    2334                                               -- Blocking Check Burst Transaction. 
    2335                                               -- Param, when present, is an extra parameter used by the verification component
    2336                                               -- The UART verification component uses Param for checking error injection.
    2337                                               -- ========================================================
    2338                                               ------------------------------------------------------------
    2339                                               procedure LocalCheckBurst (
    2340                                               -- Package Local - simplifies the other calls to Check
    2341                                               ------------------------------------------------------------
    2342                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2343                                                 constant  Index            : in    integer ;
    2344                                                 constant  Operation        : in    StreamOperationType ;
    2345                                                 constant  NumFifoWords     : in    integer ;
    2346                                                 constant  Param            : in    std_logic_vector ;
    2347                                                 constant  StatusMsgOn      : in    boolean := false 
    2348                                               ) is 
    2349                                                 variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;
    2350                                               begin
    2351            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    2352            1                    ***0***         TransactionRec(Index).Operation     <= Operation ;
    2353            1                    ***0***         TransactionRec(Index).IntToModel    <= NumFifoWords ; 
    2354            1                    ***0***         TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; 
    2355            1                    ***0***         TransactionRec(Index).BoolToModel   <= StatusMsgOn ; 
    2356            1                    ***0***         StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; 
    2357                                               end procedure LocalCheckBurst ; 
    2358                                             
    2359                                               ------------------------------------------------------------
    2360                                               procedure CheckBurst (
    2361                                               ------------------------------------------------------------
    2362                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2363                                                 constant  Index            : in    integer ;
    2364                                                 constant  NumFifoWords     : in    integer ;
    2365                                                 constant  Param            : in    std_logic_vector ;
    2366                                                 constant  StatusMsgOn      : in    boolean := false 
    2367                                               ) is 
    2368                                               begin
    2369            1                    ***0***         LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2370                                               end procedure CheckBurst ; 
    2371                                               
    2372                                               ------------------------------------------------------------
    2373                                               procedure CheckBurst (
    2374                                               ------------------------------------------------------------
    2375                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2376                                                 constant  Index            : in    integer ;
    2377                                                 constant  NumFifoWords     : in    integer ;
    2378                                                 constant  StatusMsgOn      : in    boolean := false 
    2379                                               ) is 
    2380                                               begin
    2381            1                    ***0***         LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, "", StatusMsgOn) ;
    2382                                               end procedure CheckBurst ; 
    2383                                             
    2384                                               ------------------------------------------------------------
    2385                                               procedure CheckBurstVector (
    2386                                               ------------------------------------------------------------
    2387                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2388                                                 constant  Index            : in    integer ;
    2389                                                 constant  VectorOfWords    : in    slv_vector ;
    2390                                                 constant  Param            : in    std_logic_vector ;
    2391                                                 constant  StatusMsgOn      : in    boolean := false
    2392                                               ) is
    2393                                               begin
    2394            1                    ***0***         PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords) ;
    2395            1                    ***0***         LocalCheckBurst(TransactionRec, Index, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;
    2396                                               end procedure CheckBurstVector ;
    2397                                               
    2398                                               ------------------------------------------------------------
    2399                                               procedure CheckBurstVector (
    2400                                               ------------------------------------------------------------
    2401                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2402                                                 constant  Index            : in    integer ;
    2403                                                 constant  VectorOfWords    : in    slv_vector ;
    2404                                                 constant  StatusMsgOn      : in    boolean := false
    2405                                               ) is
    2406                                               begin
    2407            1                    ***0***         CheckBurstVector(TransactionRec, Index, VectorOfWords, "", StatusMsgOn) ; 
    2408                                               end procedure CheckBurstVector ;
    2409                                               
    2410                                               ------------------------------------------------------------
    2411                                               procedure CheckBurstVector (
    2412                                               ------------------------------------------------------------
    2413                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2414                                                 constant  Index            : in    integer ;
    2415                                                 constant  VectorOfWords    : in    integer_vector ;
    2416                                                 constant  Param            : in    std_logic_vector ;
    2417                                                 constant  FifoWidth        : in    integer ; 
    2418                                                 constant  StatusMsgOn      : in    boolean := false
    2419                                               ) is
    2420                                               begin
    2421            1                    ***0***         PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords, FifoWidth) ;
    2422            1                    ***0***         LocalCheckBurst(TransactionRec, Index, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;
    2423                                               end procedure CheckBurstVector ;
    2424                                               
    2425                                               ------------------------------------------------------------
    2426                                               procedure CheckBurstVector (
    2427                                               ------------------------------------------------------------
    2428                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2429                                                 constant  Index            : in    integer ;
    2430                                                 constant  VectorOfWords    : in    integer_vector ;
    2431                                                 constant  FifoWidth        : in    integer ; 
    2432                                                 constant  StatusMsgOn      : in    boolean := false
    2433                                               ) is
    2434                                               begin
    2435            1                    ***0***         CheckBurstVector(TransactionRec, Index, VectorOfWords, "", FifoWidth, StatusMsgOn) ; 
    2436                                               end procedure CheckBurstVector ;
    2437                                               
    2438                                               ------------------------------------------------------------
    2439                                               procedure CheckBurstIncrement (
    2440                                               ------------------------------------------------------------
    2441                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2442                                                 constant  Index            : in    integer ;
    2443                                                 constant  FirstWord        : in    std_logic_vector ;
    2444                                                 constant  NumFifoWords     : in    integer ;
    2445                                                 constant  Param            : in    std_logic_vector ;
    2446                                                 constant  StatusMsgOn      : in    boolean := false
    2447                                               ) is
    2448                                               begin
    2449            1                    ***0***         PushBurstIncrement(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;
    2450            1                    ***0***         LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2451                                               end procedure CheckBurstIncrement ;
    2452                                             
    2453                                               ------------------------------------------------------------
    2454                                               procedure CheckBurstIncrement (
    2455                                               ------------------------------------------------------------
    2456                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2457                                                 constant  Index            : in    integer ;
    2458                                                 constant  FirstWord        : in    std_logic_vector ;
    2459                                                 constant  NumFifoWords     : in    integer ;
    2460                                                 constant  StatusMsgOn      : in    boolean := false
    2461                                               ) is
    2462                                               begin
    2463            1                    ***0***         CheckBurstIncrement(TransactionRec, Index, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    2464                                               end procedure CheckBurstIncrement ;
    2465                                             
    2466                                               ------------------------------------------------------------
    2467                                               procedure CheckBurstRandom (
    2468                                               ------------------------------------------------------------
    2469                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2470                                                 constant  Index            : in    integer ;
    2471                                                 constant  FirstWord        : in    std_logic_vector ;
    2472                                                 constant  NumFifoWords     : in    integer ;
    2473                                                 constant  Param            : in    std_logic_vector ;
    2474                                                 constant  StatusMsgOn      : in    boolean := false
    2475                                               ) is
    2476                                               begin
    2477            1                    ***0***         PushBurstRandom(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;
    2478            1                    ***0***         LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2479                                               end procedure CheckBurstRandom ;
    2480                                               
    2481                                               ------------------------------------------------------------
    2482                                               procedure CheckBurstRandom (
    2483                                               ------------------------------------------------------------
    2484                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2485                                                 constant  Index            : in    integer ;
    2486                                                 constant  FirstWord        : in    std_logic_vector ;
    2487                                                 constant  NumFifoWords     : in    integer ;
    2488                                                 constant  StatusMsgOn      : in    boolean := false
    2489                                               ) is
    2490                                               begin
    2491            1                    ***0***         CheckBurstRandom(TransactionRec, Index, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    2492                                               end procedure CheckBurstRandom ;
    2493                                             
    2494                                               ------------------------------------------------------------
    2495                                               procedure CheckBurstRandom (
    2496                                               ------------------------------------------------------------
    2497                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2498                                                 constant  Index            : in    integer ;
    2499                                                 constant  CoverID          : in    CoverageIDType ;
    2500                                                 constant  NumFifoWords     : in    integer ;
    2501                                                 constant  FifoWidth        : in    integer ;
    2502                                                 constant  Param            : in    std_logic_vector ;
    2503                                                 constant  StatusMsgOn      : in    boolean := false
    2504                                               ) is
    2505                                               begin
    2506            1                    ***0***         PushBurstRandom(TransactionRec(Index).BurstFifo, CoverID, NumFifoWords, FifoWidth) ;
    2507            1                    ***0***         LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2508                                               end procedure CheckBurstRandom ;  
    2509                                             
    2510                                               ------------------------------------------------------------
    2511                                               procedure CheckBurstRandom (
    2512                                               ------------------------------------------------------------
    2513                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2514                                                 constant  Index            : in    integer ;
    2515                                                 constant  CoverID          : in    CoverageIDType ;
    2516                                                 constant  NumFifoWords     : in    integer ;
    2517                                                 constant  FifoWidth        : in    integer ;
    2518                                                 constant  StatusMsgOn      : in    boolean := false
    2519                                               ) is
    2520                                               begin
    2521            1                    ***0***         CheckBurstRandom(TransactionRec, Index, CoverID, NumFifoWords, FifoWidth, "", StatusMsgOn) ;
    2522                                               end procedure CheckBurstRandom ;  
    2523                                             
    2524                                               -- ========================================================
    2525                                               -- TryCheckBurst
    2526                                               -- Try / Non-Blocking Check Burst Transaction
    2527                                               -- Param, when present, is an extra parameter used by the verification component
    2528                                               -- The UART verification component uses Param for error injection. 
    2529                                               -- ========================================================
    2530                                               ------------------------------------------------------------
    2531                                               procedure TryCheckBurst (
    2532                                               ------------------------------------------------------------
    2533                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2534                                                 constant  Index            : in    integer ;
    2535                                                 constant  NumFifoWords     : in    integer ;
    2536                                                 constant  Param            : in    std_logic_vector ;
    2537                                                 variable  Available        : out   boolean ;
    2538                                                 constant  StatusMsgOn      : in    boolean := false 
    2539                                               ) is 
    2540                                               begin
    2541            1                    ***0***         LocalCheckBurst(TransactionRec, Index, TRY_CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2542            1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    2543                                               end procedure TryCheckBurst ; 
    2544                                             
    2545                                               ------------------------------------------------------------
    2546                                               procedure TryCheckBurst (
    2547                                               ------------------------------------------------------------
    2548                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2549                                                 constant  Index            : in    integer ;
    2550                                                 constant  NumFifoWords     : in    integer ;
    2551                                                 variable  Available        : out   boolean ;
    2552                                                 constant  StatusMsgOn      : in    boolean := false 
    2553                                               ) is 
    2554                                               begin
    2555            1                    ***0***         LocalCheckBurst(TransactionRec, Index, TRY_CHECK_BURST, NumFifoWords, "", StatusMsgOn) ;
    2556            1                    ***0***         Available := TransactionRec(Index).BoolFromModel ;
    2557                                               end procedure TryCheckBurst ; 
    2558                                             
    2559                                               ------------------------------------------------------------
    2560                                               procedure TryCheckBurstVector (
    2561                                               ------------------------------------------------------------
    2562                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2563                                                 constant  Index            : in    integer ;
    2564                                                 constant  VectorOfWords    : in    slv_vector ;
    2565                                                 constant  Param            : in    std_logic_vector ;
    2566                                                 variable  Available        : out   boolean ;
    2567                                                 constant  StatusMsgOn      : in    boolean := false
    2568                                               ) is
    2569                                               begin
    2570            1                    ***0***         GotBurst(TransactionRec, Index, VectorOfWords'length, Available) ; 
    2571                                                 if Available then 
    2572            1                    ***0***           PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords) ;
    2573            1                    ***0***           LocalCheckBurst(TransactionRec, Index, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;
    2574                                                 end if ; 
    2575                                               end procedure TryCheckBurstVector ;
    2576                                                 
    2577                                               ------------------------------------------------------------
    2578                                               procedure TryCheckBurstVector (
    2579                                               ------------------------------------------------------------
    2580                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2581                                                 constant  Index            : in    integer ;
    2582                                                 constant  VectorOfWords    : in    slv_vector ;
    2583                                                 variable  Available        : out   boolean ;
    2584                                                 constant  StatusMsgOn      : in    boolean := false
    2585                                               ) is
    2586                                               begin
    2587            1                    ***0***         TryCheckBurstVector(TransactionRec, Index, VectorOfWords, "", Available, StatusMsgOn) ;
    2588                                               end procedure TryCheckBurstVector ;
    2589                                               
    2590                                               ------------------------------------------------------------
    2591                                               procedure TryCheckBurstVector (
    2592                                               ------------------------------------------------------------
    2593                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2594                                                 constant  Index            : in    integer ;
    2595                                                 constant  VectorOfWords    : in    integer_vector ;
    2596                                                 constant  Param            : in    std_logic_vector ;
    2597                                                 variable  Available        : out   boolean ;
    2598                                                 constant  FifoWidth        : in    integer ; 
    2599                                                 constant  StatusMsgOn      : in    boolean := false
    2600                                               ) is
    2601                                               begin
    2602            1                    ***0***         GotBurst(TransactionRec, Index, VectorOfWords'length, Available) ; 
    2603                                                 if Available then 
    2604            1                    ***0***           PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords, FifoWidth) ;
    2605            1                    ***0***           LocalCheckBurst(TransactionRec, Index, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;
    2606                                                 end if ; 
    2607                                               end procedure TryCheckBurstVector ;
    2608                                                 
    2609                                               ------------------------------------------------------------
    2610                                               procedure TryCheckBurstVector (
    2611                                               ------------------------------------------------------------
    2612                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2613                                                 constant  Index            : in    integer ;
    2614                                                 constant  VectorOfWords    : in    integer_vector ;
    2615                                                 variable  Available        : out   boolean ;
    2616                                                 constant  FifoWidth        : in    integer ; 
    2617                                                 constant  StatusMsgOn      : in    boolean := false
    2618                                               ) is
    2619                                               begin
    2620            1                    ***0***         TryCheckBurstVector(TransactionRec, Index, VectorOfWords, "", Available, FifoWidth, StatusMsgOn) ;
    2621                                               end procedure TryCheckBurstVector ;
    2622                                             
    2623                                               ------------------------------------------------------------
    2624                                               procedure TryCheckBurstIncrement (
    2625                                               ------------------------------------------------------------
    2626                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2627                                                 constant  Index            : in    integer ;
    2628                                                 constant  FirstWord        : in    std_logic_vector ;
    2629                                                 constant  NumFifoWords     : in    integer ;
    2630                                                 constant  Param            : in    std_logic_vector ;
    2631                                                 variable  Available        : out   boolean ;
    2632                                                 constant  StatusMsgOn      : in    boolean := false
    2633                                               ) is
    2634                                               begin
    2635            1                    ***0***         GotBurst(TransactionRec, Index, NumFifoWords, Available) ; 
    2636                                                 if Available then
    2637            1                    ***0***           PushBurstIncrement(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;
    2638            1                    ***0***           LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2639                                                 end if ; 
    2640                                               end procedure TryCheckBurstIncrement ;
    2641                                             
    2642                                               ------------------------------------------------------------
    2643                                               procedure TryCheckBurstIncrement (
    2644                                               ------------------------------------------------------------
    2645                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2646                                                 constant  Index            : in    integer ;
    2647                                                 constant  FirstWord        : in    std_logic_vector ;
    2648                                                 constant  NumFifoWords     : in    integer ;
    2649                                                 variable  Available        : out   boolean ;
    2650                                                 constant  StatusMsgOn      : in    boolean := false
    2651                                               ) is
    2652                                               begin
    2653            1                    ***0***         TryCheckBurstIncrement(TransactionRec, Index, FirstWord, NumFifoWords, "", Available, StatusMsgOn) ; 
    2654                                               end procedure TryCheckBurstIncrement ;
    2655                                             
    2656                                               ------------------------------------------------------------
    2657                                               procedure TryCheckBurstRandom (
    2658                                               ------------------------------------------------------------
    2659                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2660                                                 constant  Index            : in    integer ;
    2661                                                 constant  FirstWord        : in    std_logic_vector ;
    2662                                                 constant  NumFifoWords     : in    integer ;
    2663                                                 constant  Param            : in    std_logic_vector ;
    2664                                                 variable  Available        : out   boolean ;
    2665                                                 constant  StatusMsgOn      : in    boolean := false
    2666                                               ) is
    2667                                               begin
    2668            1                    ***0***         GotBurst(TransactionRec, Index, NumFifoWords, Available) ; 
    2669                                                 if Available then
    2670            1                    ***0***           PushBurstRandom(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;
    2671            1                    ***0***           LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2672                                                 end if ; 
    2673                                               end procedure TryCheckBurstRandom ;
    2674                                             
    2675                                               ------------------------------------------------------------
    2676                                               procedure TryCheckBurstRandom (
    2677                                               ------------------------------------------------------------
    2678                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2679                                                 constant  Index            : in    integer ;
    2680                                                 constant  FirstWord        : in    std_logic_vector ;
    2681                                                 constant  NumFifoWords     : in    integer ;
    2682                                                 variable  Available        : out   boolean ;
    2683                                                 constant  StatusMsgOn      : in    boolean := false
    2684                                               ) is
    2685                                               begin
    2686            1                    ***0***         TryCheckBurstRandom(TransactionRec, Index, FirstWord, NumFifoWords, "", Available, StatusMsgOn) ; 
    2687                                               end procedure TryCheckBurstRandom ;
    2688                                             
    2689                                               ------------------------------------------------------------
    2690                                               procedure TryCheckBurstRandom (
    2691                                               ------------------------------------------------------------
    2692                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2693                                                 constant  Index            : in    integer ;
    2694                                                 constant  CoverID          : in    CoverageIDType ;
    2695                                                 constant  NumFifoWords     : in    integer ;
    2696                                                 constant  FifoWidth        : in    integer ;
    2697                                                 constant  Param            : in    std_logic_vector ;
    2698                                                 variable  Available        : out   boolean ;
    2699                                                 constant  StatusMsgOn      : in    boolean := false
    2700                                               ) is
    2701                                               begin
    2702            1                    ***0***         GotBurst(TransactionRec, Index, NumFifoWords, Available) ; 
    2703                                                 if Available then
    2704            1                    ***0***           PushBurstRandom(TransactionRec(Index).BurstFifo, CoverID, NumFifoWords, FifoWidth) ;
    2705            1                    ***0***           LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2706                                                 end if ; 
    2707                                               end procedure TryCheckBurstRandom ;  
    2708                                             
    2709                                               ------------------------------------------------------------
    2710                                               procedure TryCheckBurstRandom (
    2711                                               ------------------------------------------------------------
    2712                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2713                                                 constant  Index            : in    integer ;
    2714                                                 constant  CoverID          : in    CoverageIDType ;
    2715                                                 constant  NumFifoWords     : in    integer ;
    2716                                                 constant  FifoWidth        : in    integer ;
    2717                                                 variable  Available        : out   boolean ;
    2718                                                 constant  StatusMsgOn      : in    boolean := false
    2719                                               ) is
    2720                                               begin
    2721            1                    ***0***         TryCheckBurstRandom(TransactionRec, Index, CoverID, NumFifoWords, FifoWidth, "", Available, StatusMsgOn) ;
    2722                                               end procedure TryCheckBurstRandom ;  
    2723                                             
    2724                                               -- ========================================================
    2725                                               --  Send And Get Transactions
    2726                                               -- 
    2727                                               -- ========================================================
    2728                                               ------------------------------------------------------------
    2729                                               procedure SendAndGet (
    2730                                               ------------------------------------------------------------
    2731                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2732                                                 constant  Index            : in    integer ;
    2733                                                 constant  iData            : in    std_logic_vector ;
    2734                                                 constant  iParam           : in    std_logic_vector ;
    2735                                                 variable  oData            : out   std_logic_vector ;
    2736                                                 variable  oParam           : out   std_logic_vector ;
    2737                                                 constant  StatusMsgOn      : in    boolean := false 
    2738                                               ) is 
    2739                                               begin
    2740            1                    ***0***         LocalSend(TransactionRec, Index, SEND_AND_GET, iData, iParam, StatusMsgOn) ;
    2741            1                    ***0***         oData  := SafeResize(TransactionRec(Index).DataFromModel,  oData'length) ; 
    2742            1                    ***0***         oParam := SafeResize(TransactionRec(Index).ParamFromModel, oParam'length) ; 
    2743                                               end procedure SendAndGet ;  
    2744                                             
    2745                                               ------------------------------------------------------------
    2746                                               procedure SendAndGet (
    2747                                               ------------------------------------------------------------
    2748                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2749                                                 constant  Index            : in    integer ;
    2750                                                 constant  iData            : in    std_logic_vector ;
    2751                                                 variable  oData            : out   std_logic_vector ;
    2752                                                 constant  StatusMsgOn      : in    boolean := false 
    2753                                               ) is 
    2754                                               begin
    2755            1                    ***0***         LocalSend(TransactionRec, Index, SEND_AND_GET, iData, "", StatusMsgOn) ;
    2756            1                    ***0***         oData  := SafeResize(TransactionRec(Index).DataFromModel, oData'length) ; 
    2757                                               end procedure SendAndGet ;  
    2758                                             
    2759                                               ------------------------------------------------------------
    2760                                               procedure SendAndGetBurst (
    2761                                               ------------------------------------------------------------
    2762                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2763                                                 constant  Index            : in    integer ;
    2764                                                 constant  iNumFifoWords    : in    integer ;
    2765                                                 constant  iParam           : in    std_logic_vector ;
    2766                                                 variable  oNumFifoWords    : out   integer ;
    2767                                                 variable  oParam           : out   std_logic_vector ;
    2768                                                 constant  StatusMsgOn      : in    boolean := false 
    2769                                               ) is 
    2770                                               begin
    2771            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_AND_GET_BURST, iNumFifoWords, iParam, StatusMsgOn) ;
    2772            1                    ***0***         oNumFifoWords := TransactionRec(Index).IntFromModel ;
    2773            1                    ***0***         oParam        := SafeResize(TransactionRec(Index).ParamFromModel, oParam'length) ; 
    2774                                               end procedure SendAndGetBurst ; 
    2775                                             
    2776                                               ------------------------------------------------------------
    2777                                               procedure SendAndGetBurst (
    2778                                               ------------------------------------------------------------
    2779                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2780                                                 constant  Index            : in    integer ;
    2781                                                 constant  iNumFifoWords    : in    integer ;
    2782                                                 variable  oNumFifoWords    : out   integer ;
    2783                                                 constant  StatusMsgOn      : in    boolean := false 
    2784                                               ) is 
    2785                                               begin
    2786            1                    ***0***         LocalSendBurst(TransactionRec, Index, SEND_AND_GET_BURST, iNumFifoWords, "", StatusMsgOn) ;
    2787            1                    ***0***         oNumFifoWords := TransactionRec(Index).IntFromModel ;
    2788                                               end procedure SendAndGetBurst ; 
    2789                                             
    2790                                               -- ========================================================
    2791                                               --  Pseudo Transactions
    2792                                               --  Interact with the record only.
    2793                                               -- ========================================================
    2794                                               ------------------------------------------------------------
    2795                                               procedure ReleaseTransactionRecord (
    2796                                               --  Must run on same delta cycle as AcquireTransactionRecord
    2797                                               ------------------------------------------------------------
    2798                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2799                                                 constant  Index            : in    integer 
    2800                                               ) is
    2801                                               begin
    2802                                                 -- Set everything driven by TestCtrl to type'left (except Rdy)
    2803            1                    ***0***         TransactionRec(Index).Rdy           <= RdyType'left ;   
    2804            1                    ***0***         TransactionRec(Index).Operation     <= NOT_DRIVEN ;
    2805            1                    ***0***         TransactionRec(Index).DataToModel   <= (TransactionRec(Index).DataToModel'range => 'U') ;
    2806            1                    ***0***         TransactionRec(Index).ParamToModel  <= (TransactionRec(Index).ParamToModel'range => 'U') ;
    2807            1                    ***0***         TransactionRec(Index).IntToModel    <= integer'left ; 
    2808            1                    ***0***         TransactionRec(Index).BoolToModel   <= boolean'left ; 
    2809            1                    ***0***         TransactionRec(Index).TimeToModel   <= time'left ; 
    2810            1                    ***0***         TransactionRec(Index).Options       <= integer'left ;    
    2811                                               end procedure ReleaseTransactionRecord ; 
    2812                                               
    2813                                               ------------------------------------------------------------
    2814                                               procedure AcquireTransactionRecord (
    2815                                               --  Must run on same delta cycle as ReleaseTransactionRecord
    2816                                               ------------------------------------------------------------
    2817                                                 signal    TransactionRec   : inout StreamRecArrayType ;
    2818                                                 constant  Index            : in    integer 
    2819                                               ) is
    2820                                               begin
    2821                                                 -- Start Driving Rdy on next delta cycle with the current value.  
    2822            1                    ***0***         TransactionRec(Index).Rdy           <= TransactionRec(Index).Rdy ; 
    2823                                               end procedure AcquireTransactionRecord ; 
    2824                                             
    2825                                             end package body StreamTransactionArrayPkg ;


=================================================================================
=== File: ../osvvm/Common/src/StreamTransactionPkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        22         0        22     0.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/Common/src/StreamTransactionPkg.vhd --

------------------------------------IF Branch------------------------------------
    1338                                 ***0***     Count coming in to IF
    1338            1                    ***0***           if s(i) /= NOT_DRIVEN then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1339                                 ***0***     Count coming in to IF
    1339            1                    ***0***             if result = NOT_DRIVEN then 
    1341            1                    ***0***             else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2596                                 ***0***     Count coming in to IF
    2596            1                    ***0***         if Available then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2626                                 ***0***     Count coming in to IF
    2626            1                    ***0***         if Available then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2657                                 ***0***     Count coming in to IF
    2657            1                    ***0***         if Available then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2688                                 ***0***     Count coming in to IF
    2688            1                    ***0***         if Available then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2720                                 ***0***     Count coming in to IF
    2720            1                    ***0***         if Available then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2896                                 ***0***     Count coming in to IF
    2896            1                    ***0***         if Operation = MULTIPLE_DRIVER_DETECT then
    2899            1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2921                                 ***0***     Count coming in to IF
    2921            1                    ***0***         if Operation = MULTIPLE_DRIVER_DETECT then
    2924            1                    ***0***         elsif IsReceiverOperation(Operation) then
    2927            1                    ***0***         else
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------IF Branch------------------------------------
    2949                                 ***0***     Count coming in to IF
    2949            1                    ***0***         if Operation = MULTIPLE_DRIVER_DETECT then
    2952            1                    ***0***         elsif IsTransmitterOperation(Operation) then
    2955            1                    ***0***         else
Branch totals: 0 hits of 3 branches = 0.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                     263         0       263     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/Common/src/StreamTransactionPkg.vhd --

    1                                                --
    2                                                --  File Name:         StreamTransactionPkg.vhd
    3                                                --  Design Unit Name:  StreamTransactionPkg
    4                                                --  Revision:          OSVVM MODELS STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com
    7                                                --  Contributor(s):
    8                                                --     Jim Lewis      jim@synthworks.com
    9                                                --
    10                                               --
    11                                               --  Description:
    12                                               --    Defines the OSVVM Stream Model Independent Transaction
    13                                               --    Interface (StreamRecType) and transaction initiation 
    14                                               --    procedures (Send, Get, ...), as well as supporting types,
    15                                               --    constants, and subprograms that are essential to both 
    16                                               --    to Verification Components and testbenches (test 
    17                                               --    harnesses and test sequencers) that use streaming type
    18                                               --    interfaces (such as UART, AxiStream, ...)
    19                                               --
    20                                               --
    21                                               --  Developed by:
    22                                               --        SynthWorks Design Inc.
    23                                               --        VHDL Training Classes
    24                                               --        http://www.SynthWorks.com
    25                                               --
    26                                               --  Revision History:
    27                                               --    Date      Version    Description
    28                                               --    09/2023   2023.09    Added ModelParametersIDType to Record, 
    29                                               --                         Added SendAndGet and SendAndGetBurst,
    30                                               --                         Added OperationType ENUMs:  EXTEND_DIRECTIVE_OP, EXTEND_OP, EXTEND_TX_OP, EXTEND_RX_OP
    31                                               --                         Added ClassifyUnimplementedOperation, ClassifyUnimplementedTransmitterOperation, ClassifyUnimplementedReceiverOperation
    32                                               --    05/2023   2023.05    Added SetDelayCoverageID and GetDelayCoverageID
    33                                               --    11/2022   2022.11    Added StreamRecArrayType
    34                                               --    01/2022   2022.01    Burst patterns - Burst, BurstInc, BurstRandom
    35                                               --    06/2021   2021.06    Updated bursting 
    36                                               --    10/2020   2020.10    Added bursting to stream transactions
    37                                               --    09/2020   2020.09    Updating comments to serve as documentation
    38                                               --    07/2020   2020.07    Updated
    39                                               --    01/2020   2020.01    Updated license notice
    40                                               --    07/2019   2019.07    Refactored from UartTbPkg and AxiStreamTransactionPkg
    41                                               --
    42                                               --
    43                                               --  This file is part of OSVVM.
    44                                               --  
    45                                               --  Copyright (c) 2019 - 2023 by SynthWorks Design Inc.  
    46                                               --  
    47                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    48                                               --  you may not use this file except in compliance with the License.
    49                                               --  You may obtain a copy of the License at
    50                                               --  
    51                                               --      https://www.apache.org/licenses/LICENSE-2.0
    52                                               --  
    53                                               --  Unless required by applicable law or agreed to in writing, software
    54                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    55                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    56                                               --  See the License for the specific language governing permissions and
    57                                               --  limitations under the License.
    58                                               --  
    59                                               
    60                                               library ieee ;
    61                                                 use ieee.std_logic_1164.all ;
    62                                                 use ieee.numeric_std.all ;
    63                                                 use ieee.numeric_std_unsigned.all ;
    64                                               
    65                                                 use std.textio.all ;
    66                                               
    67                                               library osvvm ; 
    68                                                 context osvvm.OsvvmContext ;  
    69                                                 use osvvm.ScoreboardPkg_slv.all ; 
    70                                                 
    71                                                 use work.ModelParametersSingletonPkg.all ; 
    72                                                 use work.FifoFillPkg_slv.all ; 
    73                                               
    74                                               package StreamTransactionPkg is 
    75                                               
    76                                                 -- ========================================================
    77                                                 --  StreamOperationType 
    78                                                 --  Enumeration type used to communication transaction type
    79                                                 --  to the model via the transaction interface
    80                                                 -- ========================================================
    81                                                 type StreamUnresolvedOperationType is (
    82                                                   -- Default. Used by resolution function for Multiple Driver Detection
    83                                                   NOT_DRIVEN,  
    84                                                   -- Directives
    85                                                   WAIT_FOR_CLOCK, 
    86                                                   WAIT_FOR_TRANSACTION,
    87                                                   GET_TRANSACTION_COUNT,
    88                                                   GET_ALERTLOG_ID,
    89                                                   -- Delay Coverage ID
    90                                                   SET_USE_RANDOM_DELAYS,
    91                                                   GET_USE_RANDOM_DELAYS,
    92                                                   SET_DELAYCOV_ID,
    93                                                   GET_DELAYCOV_ID,
    94                                                   -- Burst FIFO Configuration
    95                                                   SET_BURST_MODE,
    96                                                   GET_BURST_MODE,
    97                                                   -- Check to see if Read Burst is available
    98                                                   GOT_BURST, 
    99                                                   -- Model Options
    100                                                  SET_MODEL_OPTIONS,
    101                                                  GET_MODEL_OPTIONS,
    102                                                  -- VC Customization of Directives and Functional Operations
    103                                                  EXTEND_DIRECTIVE_OP,
    104                                                  EXTEND_OP,
    105                                                  --  Transmitter
    106                                                  START_OF_TX_OPS,
    107                                                  SEND, 
    108                                                  SEND_ASYNC,
    109                                                  SEND_BURST,
    110                                                  SEND_BURST_ASYNC,
    111                                                  -- VC Customization of TX Operations
    112                                                  EXTEND_TX_OP,
    113                                                  -- Receiver
    114                                                  START_OF_RX_OPS,
    115                                                  GET,             
    116                                                  TRY_GET,
    117                                                  GET_BURST,
    118                                                  TRY_GET_BURST,
    119                                                  CHECK,
    120                                                  TRY_CHECK,
    121                                                  CHECK_BURST,
    122                                                  TRY_CHECK_BURST,
    123                                                  -- VC Customization of RX Operations
    124                                                  EXTEND_RX_OP,
    125                                                  -- Send and Get
    126                                                  SEND_AND_GET, 
    127                                                  SEND_AND_GET_BURST, 
    128                                              
    129                                                  -- Resolution function detected Multiple drivers
    130                                                  MULTIPLE_DRIVER_DETECT 
    131                                                ) ;
    132                                                type StreamUnresolvedOperationVectorType is array (natural range <>) of StreamUnresolvedOperationType ;
    133                                                -- Maximum is implicitly defined for any array type in VHDL-2008.   
    134                                                -- alias resolved_max is maximum[ StreamUnresolvedOperationVectorType return StreamUnresolvedOperationType] ;
    135                                                -- Function resolved_max is a fall back.
    136                                                function resolved_max ( s : StreamUnresolvedOperationVectorType) return StreamUnresolvedOperationType ;
    137                                                subtype StreamOperationType is resolved_max StreamUnresolvedOperationType ;
    138                                              
    139                                                -- ========================================================
    140                                                --  Stream Transaction Interface (StreamRecType) 
    141                                                --  The Stream Transaction Interface (StreamRecType) defines the 
    142                                                --  transaction interface between the test sequencer and the 
    143                                                --  verification component.   As such, it is the primary channel for 
    144                                                --  information exchange between the two.   It is defined as follows.
    145                                                --
    146                                                --  The record element types, bit_max, std_logic_vector_max_c, 
    147                                                --  integer_max, time_max, and boolean_max, are defined in the
    148                                                --  OSVVM package ResolutionPkg.  These types allow the record to 
    149                                                --  support multiple drivers and use resolution functions based on 
    150                                                --  function maximum (return largest value). 
    151                                                -- ========================================================
    152                                                type StreamRecType is record
    153                                                  -- Handshaking controls
    154                                                  --   Used by RequestTransaction in the Transaction Procedures
    155                                                  --   Used by WaitForTransaction in the Verification Component
    156                                                  --   RequestTransaction and WaitForTransaction are in osvvm.TbUtilPkg
    157                                                  Rdy             : RdyType ;
    158                                                  Ack             : AckType ;
    159                                                  -- Transaction Type
    160                                                  Operation       : StreamOperationType ;
    161                                                  -- Data and Transaction Parameter to and from verification component 
    162                                                  DataToModel     : std_logic_vector_max_c ; 
    163                                                  ParamToModel    : std_logic_vector_max_c ; 
    164                                                  DataFromModel   : std_logic_vector_max_c ; 
    165                                                  ParamFromModel  : std_logic_vector_max_c ; 
    166                                                  -- BurstFifo
    167                                                  BurstFifo       : ScoreboardIdType ; 
    168                                              --    UseCheckFifo    : boolean_max ; 
    169                                              --    CheckFifo       : ScoreboardIdType ; 
    170                                                  -- Parameters - internal settings for the VC in a singleton data structure   
    171                                                  Params          : ModelParametersIDType ;  
    172                                                  -- Verification Component Options Parameters - used by SetModelOptions
    173                                                  IntToModel      : integer_max ;
    174                                                  IntFromModel    : integer_max ; 
    175                                                  BoolToModel     : boolean_max ; 
    176                                                  BoolFromModel   : boolean_max ;
    177                                                  TimeToModel     : time_max ; 
    178                                                  TimeFromModel   : time_max ; 
    179                                                  -- Verification Component Options Type 
    180                                                  Options         : integer_max ; 
    181                                                end record StreamRecType ; 
    182                                              
    183                                                type StreamRecArrayType  is array (integer range <>) of StreamRecType ;
    184                                              
    185                                              
    186                                                -- --------------------------------------------------------
    187                                                -- Usage of the Transaction Interface (StreamRecType)
    188                                                -- The Data and Parameter fields of StreamRecType are unconstrained.
    189                                                -- Unconstrained objects may be used on component/entity interfaces.    
    190                                                -- The record fields will be sized by the record signal that is mapped
    191                                                -- as the actual in the test harness of the testbench.  
    192                                                -- Such a declaration is shown below:
    193                                                --
    194                                                --   signal StreamTxRec, StreamRxRec : StreamRecType(
    195                                                --         DataToModel   (AXI_DATA_WIDTH-1  downto 0),
    196                                                --         ParamToModel  (AXI_PARAM_WIDTH-1 downto 0),
    197                                                --         DataFromModel (AXI_DATA_WIDTH-1  downto 0),
    198                                                --         ParamFromModel(AXI_PARAM_WIDTH-1 downto 0)
    199                                                --       ) ; 
    200                                                --
    201                                                -- --------------------------------------------------------
    202                                                
    203                                              
    204                                              --!TODO add VHDL-2019 Interfaces
    205                                              
    206                                              
    207                                                -- ========================================================
    208                                                --  Types of Transactions
    209                                                --  A transaction may be either a directive or an interface transaction.
    210                                                --
    211                                                --  Directive transactions interact with the verification component 
    212                                                --  without generating any transactions or interface waveforms.
    213                                                --
    214                                                --  An interface transaction results in interface signaling to the DUT.
    215                                                --  An interface transaction may be either blocking (such as Send or Get)
    216                                                --  or non-blocking (such as SendAsync or TryGet).
    217                                                --
    218                                                --  A blocking transaction is an interface transaction that does not 
    219                                                --  does not return (complete) until the interface operation   
    220                                                --  requested by the transaction has completed.
    221                                                --
    222                                                --  An asynchronous transaction is nonblocking interface transaction
    223                                                --  that returns before the transaction has completed - typically 
    224                                                --  immediately and before the transaction has started.   
    225                                                --  An asynchronous transaction has "Async" as part of its name.
    226                                                --
    227                                                --  A Try transaction is nonblocking interface transaction that 
    228                                                --  checks to see if transaction information is available, 
    229                                                --  such as read data, and if it is returns it.  
    230                                                --  A Try transaction has "Try" as part of its name.
    231                                                --
    232                                                -- ========================================================
    233                                              
    234                                              
    235                                                -- ========================================================
    236                                                --  Directive Transactions  
    237                                                --  Directive transactions interact with the verification component 
    238                                                --  without generating any transactions or interface waveforms.
    239                                                --  Supported by all verification components
    240                                                -- ========================================================
    241                                                ------------------------------------------------------------
    242                                                procedure WaitForTransaction (
    243                                                --  Wait until pending (transmit) or next (receive) transaction(s) complete
    244                                                ------------------------------------------------------------
    245                                                  signal    TransactionRec   : inout StreamRecType 
    246                                                ) ; 
    247                                              
    248                                                ------------------------------------------------------------
    249                                                procedure WaitForClock (
    250                                                -- Wait for NumberOfClocks number of clocks 
    251                                                -- relative to the verification component clock
    252                                                ------------------------------------------------------------
    253                                                  signal    TransactionRec   : inout StreamRecType ;
    254                                                  constant  WaitCycles       : in    natural := 1
    255                                                ) ; 
    256                                                
    257                                               alias NoOp is WaitForClock [StreamRecType, natural] ;
    258                                              
    259                                                ------------------------------------------------------------
    260                                                procedure GetTransactionCount (
    261                                                -- Get the number of transactions handled by the model.  
    262                                                ------------------------------------------------------------
    263                                                  signal    TransactionRec   : inout StreamRecType ;
    264                                                  variable  TransactionCount : out   integer 
    265                                                ) ; 
    266                                              
    267                                                ------------------------------------------------------------
    268                                                procedure GetAlertLogID (
    269                                                -- Get the AlertLogID from the verification component.
    270                                                ------------------------------------------------------------
    271                                                  signal    TransactionRec   : inout StreamRecType ;
    272                                                  variable  AlertLogID       : out   AlertLogIDType 
    273                                                ) ; 
    274                                                
    275                                                ------------------------------------------------------------
    276                                                procedure GetErrorCount (
    277                                                -- Error reporting for testbenches that do not use OSVVM AlertLogPkg
    278                                                -- Returns error count.  If an error count /= 0, also print errors
    279                                                ------------------------------------------------------------
    280                                                  signal    TransactionRec   : inout StreamRecType ;
    281                                                  variable  ErrorCount       : out   natural
    282                                                ) ; 
    283                                              
    284                                                -- ========================================================
    285                                                --  Delay Coverage Transactions   
    286                                                --  Get Delay Coverage ID to change delay coverage parameters.
    287                                                -- ========================================================
    288                                                ------------------------------------------------------------
    289                                                procedure SetUseRandomDelays (
    290                                                ------------------------------------------------------------
    291                                                  signal   TransactionRec : InOut StreamRecType ;
    292                                                  constant OptVal         : In    boolean := TRUE
    293                                                ) ;
    294                                                
    295                                                ------------------------------------------------------------
    296                                                procedure GetUseRandomDelays (
    297                                                ------------------------------------------------------------
    298                                                  signal   TransactionRec : InOut StreamRecType ;
    299                                                  variable OptVal         : Out   boolean
    300                                                ) ;
    301                                              
    302                                                alias SetUseDelayCoverage is SetUseRandomDelays[StreamRecType, boolean] ; 
    303                                                alias GetUseDelayCoverage is GetUseRandomDelays[StreamRecType, boolean] ; 
    304                                              
    305                                              
    306                                                ------------------------------------------------------------
    307                                                procedure SetDelayCoverageID (
    308                                                ------------------------------------------------------------
    309                                                  signal    TransactionRec   : inout StreamRecType ;
    310                                                  constant  DelayCov         : in    DelayCoverageIdType 
    311                                              --    constant  Index            : in    integer := 1 
    312                                                ) ;
    313                                              
    314                                                ------------------------------------------------------------
    315                                                procedure GetDelayCoverageID (
    316                                                ------------------------------------------------------------
    317                                                  signal    TransactionRec   : inout StreamRecType ;
    318                                                  variable  DelayCov         : out   DelayCoverageIdType 
    319                                              --    constant  Index            : in    integer := 1 
    320                                                ) ;
    321                                              
    322                                                -- ========================================================
    323                                                -- BurstFIFOs and Burst Mode Controls
    324                                                -- The burst FIFOs hold bursts of data that is to be sent to 
    325                                                -- or was received from the interface.   The burst FIFO can be 
    326                                                -- configured in the modes defined for StreamFifoBurstModeType.
    327                                                -- Currently these modes defined as a subtype of integer, shown below.
    328                                                -- The intention of using integers is to facilitate model specific 
    329                                                -- extensions without the need to define separate transactions.
    330                                                -- ========================================================
    331                                                subtype StreamFifoBurstModeType is integer ;
    332                                                
    333                                                -- Word mode indicates the burst FIFO contains interface words.
    334                                                -- The size of the word may either be interface specific (such as 
    335                                                -- a UART which supports up to 8 bits) or be interface instance specific 
    336                                                -- (such as AxiStream which supports interfaces sizes of 1, 2, 4, 8, 
    337                                                -- 16, ... bytes)
    338                                                constant STREAM_BURST_WORD_MODE       : StreamFifoBurstModeType  := 0 ;
    339                                                
    340                                                -- Word + Param mode indicates the burst FIFO contains interface 
    341                                                -- words plus a parameter.   The size of the parameter is also either
    342                                                -- interface specific (such as the OSVVM UART, which uses 3 bits - 
    343                                                -- one bit for each of parity, stop, and break error injection) or
    344                                                -- interface instance specific (such as AxiStream which uses the Param
    345                                                -- field to hold TUser).  AxiStream TUser may be different size for
    346                                                -- different applications.
    347                                                constant STREAM_BURST_WORD_PARAM_MODE : StreamFifoBurstModeType  := 1 ;
    348                                                
    349                                                -- Byte mode indicates that the burst FIFO contains bytes.  
    350                                                -- The verification component assembles interface words from the bytes.
    351                                                -- This allows transfers to be conceptualized in an interface independent 
    352                                                --manner.    
    353                                                constant STREAM_BURST_BYTE_MODE       : StreamFifoBurstModeType  := 2 ; 
    354                                                  
    355                                                ------------------------------------------------------------
    356                                                --  SetBurstMode and GetBurstMode
    357                                                --  are directive transactions that configure the burst mode 
    358                                                --  into one of the modes defined for StreamFifoBurstModeType
    359                                                ------------------------------------------------------------
    360                                                ------------------------------------------------------------
    361                                                procedure SetBurstMode (
    362                                                ------------------------------------------------------------
    363                                                  signal    TransactionRec   : inout StreamRecType ;
    364                                                  constant  OptVal           : in    StreamFifoBurstModeType
    365                                                ) ;
    366                                              
    367                                                ------------------------------------------------------------
    368                                                procedure GetBurstMode (
    369                                                ------------------------------------------------------------
    370                                                  signal    TransactionRec   : inout StreamRecType ;
    371                                                  variable  OptVal           : out   StreamFifoBurstModeType
    372                                                ) ;
    373                                              
    374                                                ------------------------------------------------------------
    375                                                --  GotBurst   
    376                                                --  Check to see if Read Burst is available
    377                                                ------------------------------------------------------------
    378                                                ------------------------------------------------------------
    379                                                procedure GotBurst (
    380                                                --  Do not refactor. Required by Co-Sim interface 
    381                                                ------------------------------------------------------------
    382                                                  signal    TransactionRec   : inout StreamRecType ;
    383                                                  constant  NumFifoWords     : in    integer ;
    384                                                  variable  Available        : out   boolean
    385                                                ) ;
    386                                              
    387                                                -- ========================================================
    388                                                --  Set and Get Model Options  
    389                                                --  Model operations are directive transactions that are  
    390                                                --  used to configure the verification component.  
    391                                                --  They can either be used directly or with a model specific
    392                                                --  wrapper around them - see AXI models for examples.
    393                                                -- ========================================================
    394                                                ------------------------------------------------------------
    395                                                procedure SetModelOptions (
    396                                                ------------------------------------------------------------
    397                                                  signal    TransactionRec   : inout StreamRecType ;
    398                                                  constant  Option           : in    integer ;
    399                                                  constant  OptVal           : in    boolean
    400                                                ) ;
    401                                              
    402                                                ------------------------------------------------------------
    403                                                procedure SetModelOptions (
    404                                                ------------------------------------------------------------
    405                                                  signal    TransactionRec   : inout StreamRecType ;
    406                                                  constant  Option           : in    integer ;
    407                                                  constant  OptVal           : in    integer
    408                                                ) ;
    409                                              
    410                                                ------------------------------------------------------------
    411                                                procedure SetModelOptions (
    412                                                ------------------------------------------------------------
    413                                                  signal    TransactionRec   : inout StreamRecType ;
    414                                                  constant  Option           : in    integer ;
    415                                                  constant  OptVal           : in    std_logic_vector
    416                                                ) ;
    417                                                
    418                                                ------------------------------------------------------------
    419                                                procedure SetModelOptions (
    420                                                ------------------------------------------------------------
    421                                                  signal    TransactionRec   : inout StreamRecType ;
    422                                                  constant  Option           : in    integer ;
    423                                                  constant  OptVal           : in    time
    424                                                ) ;
    425                                                
    426                                                ------------------------------------------------------------
    427                                                procedure SetModelOptions (
    428                                                ------------------------------------------------------------
    429                                                  signal    TransactionRec   : inout StreamRecType ;
    430                                                  constant  Option           : in    integer 
    431                                                ) ;
    432                                                
    433                                                ------------------------------------------------------------
    434                                                procedure GetModelOptions (
    435                                                ------------------------------------------------------------
    436                                                  signal    TransactionRec   : inout StreamRecType ;
    437                                                  constant  Option           : in    integer ;
    438                                                  variable  OptVal           : out   boolean
    439                                                ) ;
    440                                              
    441                                                ------------------------------------------------------------
    442                                                procedure GetModelOptions (
    443                                                ------------------------------------------------------------
    444                                                  signal    TransactionRec   : inout StreamRecType ;
    445                                                  constant  Option           : in    integer ;
    446                                                  variable  OptVal           : out   integer
    447                                                ) ;
    448                                              
    449                                                ------------------------------------------------------------
    450                                                procedure GetModelOptions (
    451                                                ------------------------------------------------------------
    452                                                  signal    TransactionRec   : inout StreamRecType ;
    453                                                  constant  Option           : in    integer ;
    454                                                  variable  OptVal           : out   std_logic_vector
    455                                                ) ;
    456                                                
    457                                                ------------------------------------------------------------
    458                                                procedure GetModelOptions (
    459                                                ------------------------------------------------------------
    460                                                  signal    TransactionRec   : inout StreamRecType ;
    461                                                  constant  Option           : in    integer ;
    462                                                  variable  OptVal           : out   time
    463                                                ) ;
    464                                                
    465                                                ------------------------------------------------------------
    466                                                procedure GetModelOptions (
    467                                                ------------------------------------------------------------
    468                                                  signal    TransactionRec   : inout StreamRecType ;
    469                                                  constant  Option           : in    integer 
    470                                                ) ;
    471                                              
    472                                              
    473                                                -- ========================================================
    474                                                --  Transmitter Transactions
    475                                                -- ========================================================
    476                                              
    477                                                -- ========================================================
    478                                                -- Send
    479                                                -- Blocking Send Transaction. 
    480                                                -- Param, when present, is an extra parameter used by the verification component
    481                                                -- The UART verification component uses Param for error injection.
    482                                                -- ========================================================
    483                                                
    484                                                ------------------------------------------------------------
    485                                                procedure Send (
    486                                                ------------------------------------------------------------
    487                                                  signal    TransactionRec   : inout StreamRecType ;
    488                                                  constant  Data             : in    std_logic_vector ;
    489                                                  constant  Param            : in    std_logic_vector ;
    490                                                  constant  StatusMsgOn      : in    boolean := false 
    491                                                ) ; 
    492                                              
    493                                                ------------------------------------------------------------
    494                                                procedure Send (
    495                                                ------------------------------------------------------------
    496                                                  signal    TransactionRec   : inout StreamRecType ;
    497                                                  constant  Data             : in    std_logic_vector ;
    498                                                  constant  StatusMsgOn      : in    boolean := false 
    499                                                ) ; 
    500                                                
    501                                              
    502                                                -- ========================================================
    503                                                -- SendAsync
    504                                                -- Asynchronous / Non-Blocking Send Transaction
    505                                                -- Param, when present, is an extra parameter used by the verification component
    506                                                -- The UART verification component uses Param for error injection. 
    507                                                -- ========================================================
    508                                              
    509                                                ------------------------------------------------------------
    510                                                procedure SendAsync (
    511                                                ------------------------------------------------------------
    512                                                  signal    TransactionRec   : inout StreamRecType ;
    513                                                  constant  Data             : in    std_logic_vector ;
    514                                                  constant  Param            : in    std_logic_vector ;
    515                                                  constant  StatusMsgOn      : in    boolean := false 
    516                                                ) ; 
    517                                              
    518                                                ------------------------------------------------------------
    519                                                procedure SendAsync (
    520                                                ------------------------------------------------------------
    521                                                  signal    TransactionRec   : inout StreamRecType ;
    522                                                  constant  Data             : in    std_logic_vector ;
    523                                                  constant  StatusMsgOn      : in    boolean := false 
    524                                                ) ; 
    525                                              
    526                                              
    527                                                -- ========================================================
    528                                                -- SendBurst
    529                                                -- Blocking Send Burst Transaction. 
    530                                                -- Param, when present, is an extra parameter used by the verification component
    531                                                -- The UART verification component uses Param for error injection.
    532                                                -- ========================================================
    533                                              
    534                                                ------------------------------------------------------------
    535                                                procedure SendBurst (
    536                                                ------------------------------------------------------------
    537                                                  signal    TransactionRec   : inout StreamRecType ;
    538                                                  constant  NumFifoWords     : in    integer ;
    539                                                  constant  Param            : in    std_logic_vector ;
    540                                                  constant  StatusMsgOn      : in    boolean := false 
    541                                                ) ; 
    542                                              
    543                                                ------------------------------------------------------------
    544                                                procedure SendBurst (
    545                                                ------------------------------------------------------------
    546                                                  signal    TransactionRec   : inout StreamRecType ;
    547                                                  constant  NumFifoWords     : in    integer ;
    548                                                  constant  StatusMsgOn      : in    boolean := false 
    549                                                ) ; 
    550                                                
    551                                                ------------------------------------------------------------
    552                                                procedure SendBurstVector (
    553                                                ------------------------------------------------------------
    554                                                  signal    TransactionRec   : inout StreamRecType ;
    555                                                  constant  VectorOfWords    : in    slv_vector ;
    556                                                  constant  Param            : in    std_logic_vector ;
    557                                                  constant  StatusMsgOn      : in    boolean := false
    558                                                ) ;
    559                                                
    560                                                ------------------------------------------------------------
    561                                                procedure SendBurstVector (
    562                                                ------------------------------------------------------------
    563                                                  signal    TransactionRec   : inout StreamRecType ;
    564                                                  constant  VectorOfWords    : in    slv_vector ;
    565                                                  constant  StatusMsgOn      : in    boolean := false
    566                                                ) ;
    567                                                
    568                                              --  alias SendBurst is SendBurstVector[StreamRecType, slv_vector, std_logic_vector, boolean] ; 
    569                                              --  alias SendBurst is SendBurstVector[StreamRecType, slv_vector, boolean] ; 
    570                                              
    571                                                ------------------------------------------------------------
    572                                                procedure SendBurstVector (
    573                                                ------------------------------------------------------------
    574                                                  signal    TransactionRec   : inout StreamRecType ;
    575                                                  constant  VectorOfWords    : in    integer_vector ;
    576                                                  constant  Param            : in    std_logic_vector ;
    577                                                  constant  FifoWidth        : in    integer ; 
    578                                                  constant  StatusMsgOn      : in    boolean := false
    579                                                ) ;
    580                                                
    581                                                ------------------------------------------------------------
    582                                                procedure SendBurstVector (
    583                                                ------------------------------------------------------------
    584                                                  signal    TransactionRec   : inout StreamRecType ;
    585                                                  constant  VectorOfWords    : in    integer_vector ;
    586                                                  constant  FifoWidth        : in    integer ; 
    587                                                  constant  StatusMsgOn      : in    boolean := false
    588                                                ) ;
    589                                                
    590                                                ------------------------------------------------------------
    591                                                procedure SendBurstIncrement (
    592                                                ------------------------------------------------------------
    593                                                  signal    TransactionRec   : inout StreamRecType ;
    594                                                  constant  FirstWord        : in    std_logic_vector ;
    595                                                  constant  NumFifoWords     : in    integer ;
    596                                                  constant  Param            : in    std_logic_vector ;
    597                                                  constant  StatusMsgOn      : in    boolean := false
    598                                                ) ;
    599                                              
    600                                                ------------------------------------------------------------
    601                                                procedure SendBurstIncrement (
    602                                                ------------------------------------------------------------
    603                                                  signal    TransactionRec   : inout StreamRecType ;
    604                                                  constant  FirstWord        : in    std_logic_vector ;
    605                                                  constant  NumFifoWords     : in    integer ;
    606                                                  constant  StatusMsgOn      : in    boolean := false
    607                                                ) ;
    608                                              
    609                                                ------------------------------------------------------------
    610                                                procedure SendBurstRandom (
    611                                                ------------------------------------------------------------
    612                                                  signal    TransactionRec   : inout StreamRecType ;
    613                                                  constant  FirstWord        : in    std_logic_vector ;
    614                                                  constant  NumFifoWords     : in    integer ;
    615                                                  constant  Param            : in    std_logic_vector ;
    616                                                  constant  StatusMsgOn      : in    boolean := false
    617                                                ) ;
    618                                              
    619                                                ------------------------------------------------------------
    620                                                procedure SendBurstRandom (
    621                                                ------------------------------------------------------------
    622                                                  signal    TransactionRec   : inout StreamRecType ;
    623                                                  constant  FirstWord        : in    std_logic_vector ;
    624                                                  constant  NumFifoWords     : in    integer ;
    625                                                  constant  StatusMsgOn      : in    boolean := false
    626                                                ) ;
    627                                              
    628                                                ------------------------------------------------------------
    629                                                procedure SendBurstRandom (
    630                                                ------------------------------------------------------------
    631                                                  signal    TransactionRec   : inout StreamRecType ;
    632                                                  constant  CoverID          : in    CoverageIDType ;
    633                                                  constant  NumFifoWords     : in    integer ;
    634                                                  constant  FifoWidth        : in    integer ;
    635                                                  constant  Param            : in    std_logic_vector ;
    636                                                  constant  StatusMsgOn      : in    boolean := false
    637                                                ) ;
    638                                              
    639                                                ------------------------------------------------------------
    640                                                procedure SendBurstRandom (
    641                                                ------------------------------------------------------------
    642                                                  signal    TransactionRec   : inout StreamRecType ;
    643                                                  constant  CoverID          : in    CoverageIDType ;
    644                                                  constant  NumFifoWords     : in    integer ;
    645                                                  constant  FifoWidth        : in    integer ;
    646                                                  constant  StatusMsgOn      : in    boolean := false
    647                                                ) ;
    648                                              
    649                                                -- ========================================================
    650                                                -- SendBurstAsync
    651                                                -- Asynchronous / Non-Blocking Send Transaction
    652                                                -- Param, when present, is an extra parameter used by the verification component
    653                                                -- The UART verification component uses Param for error injection. 
    654                                                -- ========================================================
    655                                              
    656                                                ------------------------------------------------------------
    657                                                procedure SendBurstAsync (
    658                                                ------------------------------------------------------------
    659                                                  signal    TransactionRec   : inout StreamRecType ;
    660                                                  constant  NumFifoWords     : in    integer ;
    661                                                  constant  Param            : in    std_logic_vector ;
    662                                                  constant  StatusMsgOn      : in    boolean := false 
    663                                                ) ; 
    664                                              
    665                                                ------------------------------------------------------------
    666                                                procedure SendBurstAsync (
    667                                                ------------------------------------------------------------
    668                                                  signal    TransactionRec   : inout StreamRecType ;
    669                                                  constant  NumFifoWords     : in    integer ;
    670                                                  constant  StatusMsgOn      : in    boolean := false 
    671                                                ) ; 
    672                                                
    673                                                ------------------------------------------------------------
    674                                                procedure SendBurstVectorAsync (
    675                                                ------------------------------------------------------------
    676                                                  signal    TransactionRec   : inout StreamRecType ;
    677                                                  constant  VectorOfWords    : in    slv_vector ;
    678                                                  constant  Param            : in    std_logic_vector ;
    679                                                  constant  StatusMsgOn      : in    boolean := false
    680                                                ) ;
    681                                                
    682                                                ------------------------------------------------------------
    683                                                procedure SendBurstVectorAsync (
    684                                                ------------------------------------------------------------
    685                                                  signal    TransactionRec   : inout StreamRecType ;
    686                                                  constant  VectorOfWords    : in    slv_vector ;
    687                                                  constant  StatusMsgOn      : in    boolean := false
    688                                                ) ;
    689                                                
    690                                              --  alias SendBurstAsync is SendBurstVectorAsync[StreamRecType, slv_vector, std_logic_vector, boolean] ; 
    691                                              --  alias SendBurstAsync is SendBurstVectorAsync[StreamRecType, slv_vector, boolean] ; 
    692                                              
    693                                                ------------------------------------------------------------
    694                                                procedure SendBurstVectorAsync (
    695                                                ------------------------------------------------------------
    696                                                  signal    TransactionRec   : inout StreamRecType ;
    697                                                  constant  VectorOfWords    : in    integer_vector ;
    698                                                  constant  Param            : in    std_logic_vector ;
    699                                                  constant  FifoWidth        : in    integer ; 
    700                                                  constant  StatusMsgOn      : in    boolean := false
    701                                                ) ;
    702                                                
    703                                                ------------------------------------------------------------
    704                                                procedure SendBurstVectorAsync (
    705                                                ------------------------------------------------------------
    706                                                  signal    TransactionRec   : inout StreamRecType ;
    707                                                  constant  VectorOfWords    : in    integer_vector ;
    708                                                  constant  FifoWidth        : in    integer ; 
    709                                                  constant  StatusMsgOn      : in    boolean := false
    710                                                ) ;
    711                                                
    712                                                ------------------------------------------------------------
    713                                                procedure SendBurstIncrementAsync (
    714                                                ------------------------------------------------------------
    715                                                  signal    TransactionRec   : inout StreamRecType ;
    716                                                  constant  FirstWord        : in    std_logic_vector ;
    717                                                  constant  NumFifoWords     : in    integer ;
    718                                                  constant  Param            : in    std_logic_vector ;
    719                                                  constant  StatusMsgOn      : in    boolean := false
    720                                                ) ;
    721                                              
    722                                                ------------------------------------------------------------
    723                                                procedure SendBurstIncrementAsync (
    724                                                ------------------------------------------------------------
    725                                                  signal    TransactionRec   : inout StreamRecType ;
    726                                                  constant  FirstWord        : in    std_logic_vector ;
    727                                                  constant  NumFifoWords     : in    integer ;
    728                                                  constant  StatusMsgOn      : in    boolean := false
    729                                                ) ;
    730                                              
    731                                                ------------------------------------------------------------
    732                                                procedure SendBurstRandomAsync (
    733                                                ------------------------------------------------------------
    734                                                  signal    TransactionRec   : inout StreamRecType ;
    735                                                  constant  FirstWord        : in    std_logic_vector ;
    736                                                  constant  NumFifoWords     : in    integer ;
    737                                                  constant  Param            : in    std_logic_vector ;
    738                                                  constant  StatusMsgOn      : in    boolean := false
    739                                                ) ;
    740                                              
    741                                                ------------------------------------------------------------
    742                                                procedure SendBurstRandomAsync (
    743                                                ------------------------------------------------------------
    744                                                  signal    TransactionRec   : inout StreamRecType ;
    745                                                  constant  FirstWord        : in    std_logic_vector ;
    746                                                  constant  NumFifoWords     : in    integer ;
    747                                                  constant  StatusMsgOn      : in    boolean := false
    748                                                ) ;
    749                                                
    750                                                ------------------------------------------------------------
    751                                                procedure SendBurstRandomAsync (
    752                                                ------------------------------------------------------------
    753                                                  signal    TransactionRec   : inout StreamRecType ;
    754                                                  constant  CoverID          : in    CoverageIDType ;
    755                                                  constant  NumFifoWords     : in    integer ;
    756                                                  constant  FifoWidth        : in    integer ;
    757                                                  constant  Param            : in    std_logic_vector ;
    758                                                  constant  StatusMsgOn      : in    boolean := false
    759                                                ) ;
    760                                              
    761                                                ------------------------------------------------------------
    762                                                procedure SendBurstRandomAsync (
    763                                                ------------------------------------------------------------
    764                                                  signal    TransactionRec   : inout StreamRecType ;
    765                                                  constant  CoverID          : in    CoverageIDType ;
    766                                                  constant  NumFifoWords     : in    integer ;
    767                                                  constant  FifoWidth        : in    integer ;
    768                                                  constant  StatusMsgOn      : in    boolean := false
    769                                                ) ;
    770                                              
    771                                                -- ========================================================
    772                                                --  Receiver Transactions
    773                                                -- ========================================================
    774                                              
    775                                                -- ========================================================
    776                                                -- Get
    777                                                -- Blocking Get Transaction. 
    778                                                -- Param, when present, is an extra parameter used by the verification component
    779                                                -- The UART verification component uses Param for received error status.
    780                                                -- ========================================================
    781                                              
    782                                                ------------------------------------------------------------
    783                                                procedure Get (
    784                                                ------------------------------------------------------------
    785                                                  signal    TransactionRec   : inout StreamRecType ;
    786                                                  variable  Data             : out   std_logic_vector ;
    787                                                  variable  Param            : out   std_logic_vector ;
    788                                                  constant  StatusMsgOn      : in    boolean := false 
    789                                                ) ; 
    790                                              
    791                                                ------------------------------------------------------------
    792                                                procedure Get (
    793                                                ------------------------------------------------------------
    794                                                  signal    TransactionRec   : inout StreamRecType ;
    795                                                  variable  Data             : out   std_logic_vector ;
    796                                                  constant  StatusMsgOn      : in    boolean := false 
    797                                                ) ; 
    798                                              
    799                                              
    800                                                -- ========================================================
    801                                                -- TryGet
    802                                                -- Try Get Transaction
    803                                                -- If Data is available, get it and return available TRUE,
    804                                                -- otherwise Return Available FALSE.
    805                                                -- Param, when present, is an extra parameter used by the verification component
    806                                                -- The UART verification component uses Param for received error status.
    807                                                -- ========================================================
    808                                              
    809                                                ------------------------------------------------------------
    810                                                procedure TryGet (
    811                                                ------------------------------------------------------------
    812                                                  signal    TransactionRec   : inout StreamRecType ;
    813                                                  variable  Data             : out   std_logic_vector ;
    814                                                  variable  Available        : out   boolean ;
    815                                                  constant  StatusMsgOn      : in    boolean := false 
    816                                                ) ; 
    817                                                
    818                                                ------------------------------------------------------------
    819                                                procedure TryGet (
    820                                                ------------------------------------------------------------
    821                                                  signal    TransactionRec   : inout StreamRecType ;
    822                                                  variable  Data             : out   std_logic_vector ;
    823                                                  variable  Param            : out   std_logic_vector ;
    824                                                  variable  Available        : out   boolean ;
    825                                                  constant  StatusMsgOn      : in    boolean := false 
    826                                                ) ;  
    827                                              
    828                                              
    829                                                -- ========================================================
    830                                                -- GetBurst
    831                                                -- Blocking Get Burst Transaction. 
    832                                                -- Param, when present, is an extra parameter from the verification component
    833                                                -- The UART verification component uses Param for received error status.
    834                                                -- ========================================================
    835                                              
    836                                                ------------------------------------------------------------
    837                                                procedure GetBurst (
    838                                                ------------------------------------------------------------
    839                                                  signal    TransactionRec   : inout StreamRecType ;
    840                                                  variable  NumFifoWords     : inout integer ;
    841                                                  constant  StatusMsgOn      : in    boolean := false 
    842                                                ) ; 
    843                                                
    844                                                ------------------------------------------------------------
    845                                                procedure GetBurst (
    846                                                ------------------------------------------------------------
    847                                                  signal    TransactionRec   : inout StreamRecType ;
    848                                                  variable  NumFifoWords     : inout integer ;
    849                                                  variable  Param            : out   std_logic_vector ;
    850                                                  constant  StatusMsgOn      : in    boolean := false 
    851                                                ) ;  
    852                                              
    853                                                -- ========================================================
    854                                                -- TryGetBurst
    855                                                -- Try Get Burst Transaction
    856                                                -- If Data is available, get it and return available TRUE,
    857                                                -- otherwise Return Available FALSE.
    858                                                -- Param, when present, is an extra parameter used by the verification component
    859                                                -- The UART verification component uses Param for received error status.
    860                                                -- ========================================================
    861                                              
    862                                                ------------------------------------------------------------
    863                                                procedure TryGetBurst (
    864                                                ------------------------------------------------------------
    865                                                  signal    TransactionRec   : inout StreamRecType ;
    866                                                  variable  NumFifoWords     : inout integer ;
    867                                                  variable  Available        : out   boolean ;
    868                                                  constant  StatusMsgOn      : in    boolean := false 
    869                                                ) ; 
    870                                                
    871                                                ------------------------------------------------------------
    872                                                procedure TryGetBurst (
    873                                                ------------------------------------------------------------
    874                                                  signal    TransactionRec   : inout StreamRecType ;
    875                                                  variable  NumFifoWords     : inout integer ;
    876                                                  variable  Param            : out   std_logic_vector ;
    877                                                  variable  Available        : out   boolean ;
    878                                                  constant  StatusMsgOn      : in    boolean := false 
    879                                                ) ;  
    880                                              
    881                                              
    882                                                -- ========================================================
    883                                                -- Check
    884                                                -- Blocking Check Transaction. 
    885                                                -- Data is the expected value to be received.
    886                                                -- Param, when present, is an extra parameter used by the verification component
    887                                                -- The UART verification component uses Param for received error status.
    888                                                -- ========================================================
    889                                              
    890                                                ------------------------------------------------------------
    891                                                procedure Check (
    892                                                ------------------------------------------------------------
    893                                                  signal    TransactionRec   : inout StreamRecType ;
    894                                                  constant  Data             : in    std_logic_vector ;
    895                                                  constant  Param            : in    std_logic_vector ;
    896                                                  constant  StatusMsgOn      : in    boolean := false 
    897                                                ) ; 
    898                                              
    899                                                ------------------------------------------------------------
    900                                                procedure Check (
    901                                                ------------------------------------------------------------
    902                                                  signal    TransactionRec   : inout StreamRecType ;
    903                                                  constant  Data             : in    std_logic_vector ;
    904                                                  constant  StatusMsgOn      : in    boolean := false 
    905                                                ) ; 
    906                                              
    907                                              
    908                                                -- ========================================================
    909                                                -- TryCheck
    910                                                -- Try Check Transaction
    911                                                -- If Data is available, check it and return available TRUE,
    912                                                -- otherwise Return Available FALSE.
    913                                                -- Param, when present, is an extra parameter used by the verification component
    914                                                -- The UART verification component uses Param for received error status.
    915                                                -- ========================================================
    916                                              
    917                                                ------------------------------------------------------------
    918                                                procedure TryCheck (
    919                                                ------------------------------------------------------------
    920                                                  signal    TransactionRec   : inout StreamRecType ;
    921                                                  constant  Data             : in    std_logic_vector ;
    922                                                  constant  Param            : in    std_logic_vector ;
    923                                                  variable  Available        : out   boolean ;
    924                                                  constant  StatusMsgOn      : in    boolean := false 
    925                                                ) ; 
    926                                              
    927                                                ------------------------------------------------------------
    928                                                procedure TryCheck (
    929                                                ------------------------------------------------------------
    930                                                  signal    TransactionRec   : inout StreamRecType ;
    931                                                  constant  Data             : in    std_logic_vector ;
    932                                                  variable  Available        : out   boolean ;
    933                                                  constant  StatusMsgOn      : in    boolean := false 
    934                                                ) ; 
    935                                              
    936                                                -- ========================================================
    937                                                -- CheckBurst
    938                                                -- Blocking Check Burst Transaction. 
    939                                                -- Param, when present, is an extra parameter used by the verification component
    940                                                -- The UART verification component uses Param for checking error injection.
    941                                                -- ========================================================
    942                                                ------------------------------------------------------------
    943                                                procedure CheckBurst (
    944                                                ------------------------------------------------------------
    945                                                  signal    TransactionRec   : inout StreamRecType ;
    946                                                  constant  NumFifoWords     : in    integer ;
    947                                                  constant  Param            : in    std_logic_vector ;
    948                                                  constant  StatusMsgOn      : in    boolean := false 
    949                                                ) ; 
    950                                              
    951                                                ------------------------------------------------------------
    952                                                procedure CheckBurst (
    953                                                ------------------------------------------------------------
    954                                                  signal    TransactionRec   : inout StreamRecType ;
    955                                                  constant  NumFifoWords     : in    integer ;
    956                                                  constant  StatusMsgOn      : in    boolean := false 
    957                                                ) ; 
    958                                              
    959                                                ------------------------------------------------------------
    960                                                procedure CheckBurstVector (
    961                                                ------------------------------------------------------------
    962                                                  signal    TransactionRec   : inout StreamRecType ;
    963                                                  constant  VectorOfWords    : in    slv_vector ;
    964                                                  constant  Param            : in    std_logic_vector ;
    965                                                  constant  StatusMsgOn      : in    boolean := false
    966                                                ) ;
    967                                                
    968                                                ------------------------------------------------------------
    969                                                procedure CheckBurstVector (
    970                                                ------------------------------------------------------------
    971                                                  signal    TransactionRec   : inout StreamRecType ;
    972                                                  constant  VectorOfWords    : in    slv_vector ;
    973                                                  constant  StatusMsgOn      : in    boolean := false
    974                                                ) ;
    975                                                
    976                                              --  alias CheckBurst is CheckBurstVector[StreamRecType, slv_vector, std_logic_vector, boolean] ; 
    977                                              --  alias CheckBurst is CheckBurstVector[StreamRecType, slv_vector, boolean] ; 
    978                                              
    979                                                ------------------------------------------------------------
    980                                                procedure CheckBurstVector (
    981                                                ------------------------------------------------------------
    982                                                  signal    TransactionRec   : inout StreamRecType ;
    983                                                  constant  VectorOfWords    : in    integer_vector ;
    984                                                  constant  Param            : in    std_logic_vector ;
    985                                                  constant  FifoWidth        : in    integer ; 
    986                                                  constant  StatusMsgOn      : in    boolean := false
    987                                                ) ;
    988                                                
    989                                                ------------------------------------------------------------
    990                                                procedure CheckBurstVector (
    991                                                ------------------------------------------------------------
    992                                                  signal    TransactionRec   : inout StreamRecType ;
    993                                                  constant  VectorOfWords    : in    integer_vector ;
    994                                                  constant  FifoWidth        : in    integer ; 
    995                                                  constant  StatusMsgOn      : in    boolean := false
    996                                                ) ;
    997                                                
    998                                                ------------------------------------------------------------
    999                                                procedure CheckBurstIncrement (
    1000                                               ------------------------------------------------------------
    1001                                                 signal    TransactionRec   : inout StreamRecType ;
    1002                                                 constant  FirstWord        : in    std_logic_vector ;
    1003                                                 constant  NumFifoWords     : in    integer ;
    1004                                                 constant  Param            : in    std_logic_vector ;
    1005                                                 constant  StatusMsgOn      : in    boolean := false
    1006                                               ) ;
    1007                                             
    1008                                               ------------------------------------------------------------
    1009                                               procedure CheckBurstIncrement (
    1010                                               ------------------------------------------------------------
    1011                                                 signal    TransactionRec   : inout StreamRecType ;
    1012                                                 constant  FirstWord        : in    std_logic_vector ;
    1013                                                 constant  NumFifoWords     : in    integer ;
    1014                                                 constant  StatusMsgOn      : in    boolean := false
    1015                                               ) ;
    1016                                             
    1017                                               ------------------------------------------------------------
    1018                                               procedure CheckBurstRandom (
    1019                                               ------------------------------------------------------------
    1020                                                 signal    TransactionRec   : inout StreamRecType ;
    1021                                                 constant  FirstWord        : in    std_logic_vector ;
    1022                                                 constant  NumFifoWords     : in    integer ;
    1023                                                 constant  Param            : in    std_logic_vector ;
    1024                                                 constant  StatusMsgOn      : in    boolean := false
    1025                                               ) ;
    1026                                             
    1027                                               ------------------------------------------------------------
    1028                                               procedure CheckBurstRandom (
    1029                                               ------------------------------------------------------------
    1030                                                 signal    TransactionRec   : inout StreamRecType ;
    1031                                                 constant  FirstWord        : in    std_logic_vector ;
    1032                                                 constant  NumFifoWords     : in    integer ;
    1033                                                 constant  StatusMsgOn      : in    boolean := false
    1034                                               ) ;
    1035                                             
    1036                                               ------------------------------------------------------------
    1037                                               procedure CheckBurstRandom (
    1038                                               ------------------------------------------------------------
    1039                                                 signal    TransactionRec   : inout StreamRecType ;
    1040                                                 constant  CoverID          : in    CoverageIDType ;
    1041                                                 constant  NumFifoWords     : in    integer ;
    1042                                                 constant  FifoWidth        : in    integer ;
    1043                                                 constant  Param            : in    std_logic_vector ;
    1044                                                 constant  StatusMsgOn      : in    boolean := false
    1045                                               ) ;  
    1046                                             
    1047                                               ------------------------------------------------------------
    1048                                               procedure CheckBurstRandom (
    1049                                               ------------------------------------------------------------
    1050                                                 signal    TransactionRec   : inout StreamRecType ;
    1051                                                 constant  CoverID          : in    CoverageIDType ;
    1052                                                 constant  NumFifoWords     : in    integer ;
    1053                                                 constant  FifoWidth        : in    integer ;
    1054                                                 constant  StatusMsgOn      : in    boolean := false
    1055                                               ) ;  
    1056                                             
    1057                                               -- ========================================================
    1058                                               -- TryCheckBurst
    1059                                               -- Try / Non-Blocking Check Burst Transaction
    1060                                               -- Param, when present, is an extra parameter used by the verification component
    1061                                               -- The UART verification component uses Param for error injection. 
    1062                                               -- ========================================================
    1063                                             
    1064                                               ------------------------------------------------------------
    1065                                               procedure TryCheckBurst (
    1066                                               ------------------------------------------------------------
    1067                                                 signal    TransactionRec   : inout StreamRecType ;
    1068                                                 constant  NumFifoWords     : in    integer ;
    1069                                                 constant  Param            : in    std_logic_vector ;
    1070                                                 variable  Available        : out   boolean ;
    1071                                                 constant  StatusMsgOn      : in    boolean := false 
    1072                                               ) ; 
    1073                                               
    1074                                               ------------------------------------------------------------
    1075                                               procedure TryCheckBurst (
    1076                                               ------------------------------------------------------------
    1077                                                 signal    TransactionRec   : inout StreamRecType ;
    1078                                                 constant  NumFifoWords     : in    integer ;
    1079                                                 variable  Available        : out   boolean ;
    1080                                                 constant  StatusMsgOn      : in    boolean := false 
    1081                                               ) ; 
    1082                                               
    1083                                               ------------------------------------------------------------
    1084                                               procedure TryCheckBurstVector (
    1085                                               ------------------------------------------------------------
    1086                                                 signal    TransactionRec   : inout StreamRecType ;
    1087                                                 constant  VectorOfWords    : in    slv_vector ;
    1088                                                 constant  Param            : in    std_logic_vector ;
    1089                                                 variable  Available        : out   boolean ;
    1090                                                 constant  StatusMsgOn      : in    boolean := false
    1091                                               )  ;
    1092                                               
    1093                                               ------------------------------------------------------------
    1094                                               procedure TryCheckBurstVector (
    1095                                               ------------------------------------------------------------
    1096                                                 signal    TransactionRec   : inout StreamRecType ;
    1097                                                 constant  VectorOfWords    : in    slv_vector ;
    1098                                                 variable  Available        : out   boolean ;
    1099                                                 constant  StatusMsgOn      : in    boolean := false
    1100                                               ) ;
    1101                                             
    1102                                             --  alias TryCheckBurst is TryCheckBurstVector[StreamRecType, slv_vector, std_logic_vector, boolean, boolean] ; 
    1103                                             --  alias TryCheckBurst is TryCheckBurstVector[StreamRecType, slv_vector, boolean, boolean] ; 
    1104                                               
    1105                                               ------------------------------------------------------------
    1106                                               procedure TryCheckBurstVector (
    1107                                               ------------------------------------------------------------
    1108                                                 signal    TransactionRec   : inout StreamRecType ;
    1109                                                 constant  VectorOfWords    : in    integer_vector ;
    1110                                                 constant  Param            : in    std_logic_vector ;
    1111                                                 variable  Available        : out   boolean ;
    1112                                                 constant  FifoWidth        : in    integer ; 
    1113                                                 constant  StatusMsgOn      : in    boolean := false
    1114                                               ) ;
    1115                                                 
    1116                                               ------------------------------------------------------------
    1117                                               procedure TryCheckBurstVector (
    1118                                               ------------------------------------------------------------
    1119                                                 signal    TransactionRec   : inout StreamRecType ;
    1120                                                 constant  VectorOfWords    : in    integer_vector ;
    1121                                                 variable  Available        : out   boolean ;
    1122                                                 constant  FifoWidth        : in    integer ; 
    1123                                                 constant  StatusMsgOn      : in    boolean := false
    1124                                               ) ;
    1125                                               
    1126                                               ------------------------------------------------------------
    1127                                               procedure TryCheckBurstIncrement (
    1128                                               ------------------------------------------------------------
    1129                                                 signal    TransactionRec   : inout StreamRecType ;
    1130                                                 constant  FirstWord        : in    std_logic_vector ;
    1131                                                 constant  NumFifoWords     : in    integer ;
    1132                                                 constant  Param            : in    std_logic_vector ;
    1133                                                 variable  Available        : out   boolean ;
    1134                                                 constant  StatusMsgOn      : in    boolean := false
    1135                                               ) ;
    1136                                             
    1137                                               ------------------------------------------------------------
    1138                                               procedure TryCheckBurstIncrement (
    1139                                               ------------------------------------------------------------
    1140                                                 signal    TransactionRec   : inout StreamRecType ;
    1141                                                 constant  FirstWord        : in    std_logic_vector ;
    1142                                                 constant  NumFifoWords     : in    integer ;
    1143                                                 variable  Available        : out   boolean ;
    1144                                                 constant  StatusMsgOn      : in    boolean := false
    1145                                               ) ;
    1146                                             
    1147                                               ------------------------------------------------------------
    1148                                               procedure TryCheckBurstRandom (
    1149                                               ------------------------------------------------------------
    1150                                                 signal    TransactionRec   : inout StreamRecType ;
    1151                                                 constant  FirstWord        : in    std_logic_vector ;
    1152                                                 constant  NumFifoWords     : in    integer ;
    1153                                                 constant  Param            : in    std_logic_vector ;
    1154                                                 variable  Available        : out   boolean ;
    1155                                                 constant  StatusMsgOn      : in    boolean := false
    1156                                               ) ;
    1157                                             
    1158                                               ------------------------------------------------------------
    1159                                               procedure TryCheckBurstRandom (
    1160                                               ------------------------------------------------------------
    1161                                                 signal    TransactionRec   : inout StreamRecType ;
    1162                                                 constant  FirstWord        : in    std_logic_vector ;
    1163                                                 constant  NumFifoWords     : in    integer ;
    1164                                                 variable  Available        : out   boolean ;
    1165                                                 constant  StatusMsgOn      : in    boolean := false
    1166                                               ) ;
    1167                                             
    1168                                               ------------------------------------------------------------
    1169                                               procedure TryCheckBurstRandom (
    1170                                               ------------------------------------------------------------
    1171                                                 signal    TransactionRec   : inout StreamRecType ;
    1172                                                 constant  CoverID          : in    CoverageIDType ;
    1173                                                 constant  NumFifoWords     : in    integer ;
    1174                                                 constant  FifoWidth        : in    integer ;
    1175                                                 constant  Param            : in    std_logic_vector ;
    1176                                                 variable  Available        : out   boolean ;
    1177                                                 constant  StatusMsgOn      : in    boolean := false
    1178                                               ) ;  
    1179                                             
    1180                                               ------------------------------------------------------------
    1181                                               procedure TryCheckBurstRandom (
    1182                                               ------------------------------------------------------------
    1183                                                 signal    TransactionRec   : inout StreamRecType ;
    1184                                                 constant  CoverID          : in    CoverageIDType ;
    1185                                                 constant  NumFifoWords     : in    integer ;
    1186                                                 constant  FifoWidth        : in    integer ;
    1187                                                 variable  Available        : out   boolean ;
    1188                                                 constant  StatusMsgOn      : in    boolean := false
    1189                                               ) ;  
    1190                                             
    1191                                               -- ========================================================
    1192                                               --  Send And Get Transactions
    1193                                               -- 
    1194                                               -- ========================================================
    1195                                               ------------------------------------------------------------
    1196                                               procedure SendAndGet (
    1197                                               ------------------------------------------------------------
    1198                                                 signal    TransactionRec   : inout StreamRecType ;
    1199                                                 constant  iData            : in    std_logic_vector ;
    1200                                                 constant  iParam           : in    std_logic_vector ;
    1201                                                 variable  oData            : out   std_logic_vector ;
    1202                                                 variable  oParam           : out   std_logic_vector ;
    1203                                                 constant  StatusMsgOn      : in    boolean := false 
    1204                                               ) ;  
    1205                                             
    1206                                               ------------------------------------------------------------
    1207                                               procedure SendAndGet (
    1208                                               ------------------------------------------------------------
    1209                                                 signal    TransactionRec   : inout StreamRecType ;
    1210                                                 constant  iData            : in    std_logic_vector ;
    1211                                                 variable  oData            : out   std_logic_vector ;
    1212                                                 constant  StatusMsgOn      : in    boolean := false 
    1213                                               ) ;  
    1214                                             
    1215                                               ------------------------------------------------------------
    1216                                               procedure SendAndGetBurst (
    1217                                               ------------------------------------------------------------
    1218                                                 signal    TransactionRec   : inout StreamRecType ;
    1219                                                 constant  iNumFifoWords    : in    integer ;
    1220                                                 constant  iParam           : in    std_logic_vector ;
    1221                                                 variable  oNumFifoWords    : out   integer ;
    1222                                                 variable  oParam           : out   std_logic_vector ;
    1223                                                 constant  StatusMsgOn      : in    boolean := false 
    1224                                               ) ; 
    1225                                             
    1226                                               ------------------------------------------------------------
    1227                                               procedure SendAndGetBurst (
    1228                                               ------------------------------------------------------------
    1229                                                 signal    TransactionRec   : inout StreamRecType ;
    1230                                                 constant  iNumFifoWords    : in    integer ;
    1231                                                 variable  oNumFifoWords    : out   integer ;
    1232                                                 constant  StatusMsgOn      : in    boolean := false 
    1233                                               ) ; 
    1234                                             
    1235                                               -- ========================================================
    1236                                               --  Pseudo Transactions
    1237                                               --  Interact with the record only.
    1238                                               -- ========================================================
    1239                                               ------------------------------------------------------------
    1240                                               procedure ReleaseTransactionRecord (
    1241                                               --  Must run on same delta cycle as AcquireTransactionRecord
    1242                                               ------------------------------------------------------------
    1243                                                 signal    TransactionRec   : inout StreamRecType 
    1244                                               ) ; 
    1245                                               
    1246                                               ------------------------------------------------------------
    1247                                               procedure AcquireTransactionRecord (
    1248                                               --  Must run on same delta cycle as ReleaseTransactionRecord
    1249                                               ------------------------------------------------------------
    1250                                                 signal    TransactionRec   : inout StreamRecType 
    1251                                               ) ; 
    1252                                             
    1253                                               -- ========================================================
    1254                                               --  Verification Component Support Functions
    1255                                               --  These help decode the operation value (StreamOperationType)  
    1256                                               --  to determine properties about the operation
    1257                                               -- ========================================================
    1258                                               ------------------------------------------------------------
    1259                                               function IsBlocking (
    1260                                               -----------------------------------------------------------
    1261                                                 constant  Operation        : in StreamOperationType
    1262                                               ) return boolean ;
    1263                                               
    1264                                               ------------------------------------------------------------
    1265                                               function IsTry (
    1266                                               -- True when this transaction is an asynchronous or try transaction.
    1267                                               -----------------------------------------------------------
    1268                                                 constant  Operation        : in StreamOperationType
    1269                                               ) return boolean ;
    1270                                             
    1271                                               ------------------------------------------------------------
    1272                                               function IsCheck (
    1273                                               -- True when this transaction is a check transaction.
    1274                                               -----------------------------------------------------------
    1275                                                 constant  Operation        : in StreamOperationType
    1276                                               ) return boolean ;
    1277                                             
    1278                                               ------------------------------------------------------------
    1279                                               function IsTransmitterOperation (
    1280                                               -----------------------------------------------------------
    1281                                                 constant  Operation        : in StreamOperationType
    1282                                               ) return boolean  ;
    1283                                             
    1284                                               ------------------------------------------------------------
    1285                                               function IsReceiverOperation (
    1286                                               -----------------------------------------------------------
    1287                                                 constant  Operation        : in StreamOperationType
    1288                                               ) return boolean ;
    1289                                             
    1290                                               ------------------------------------------------------------
    1291                                               function ClassifyUnimplementedOperation (
    1292                                               -----------------------------------------------------------
    1293                                                 constant  Operation        : in StreamOperationType;
    1294                                                 constant  TransactionCount : in natural
    1295                                               ) return string ;
    1296                                             
    1297                                               ------------------------------------------------------------
    1298                                               function ClassifyUnimplementedOperation (
    1299                                               -----------------------------------------------------------
    1300                                                 constant  TransactionRec   : in StreamRecType 
    1301                                               ) return string ;
    1302                                             
    1303                                               ------------------------------------------------------------
    1304                                               function ClassifyUnimplementedTransmitterOperation (
    1305                                               -----------------------------------------------------------
    1306                                                 constant  Operation        : in StreamOperationType;
    1307                                                 constant  TransactionCount : in natural
    1308                                               ) return string ;
    1309                                             
    1310                                               ------------------------------------------------------------
    1311                                               function ClassifyUnimplementedTransmitterOperation (
    1312                                               -----------------------------------------------------------
    1313                                                 constant  TransactionRec   : in StreamRecType 
    1314                                               ) return string ;
    1315                                               
    1316                                               ------------------------------------------------------------
    1317                                               function ClassifyUnimplementedReceiverOperation (
    1318                                               -----------------------------------------------------------
    1319                                                 constant  Operation        : in StreamOperationType ;
    1320                                                 constant  TransactionCount : in natural
    1321                                               ) return string ;
    1322                                             
    1323                                               ------------------------------------------------------------
    1324                                               function ClassifyUnimplementedReceiverOperation (
    1325                                               -----------------------------------------------------------
    1326                                                 constant  TransactionRec   : in StreamRecType 
    1327                                               ) return string ;
    1328                                             end StreamTransactionPkg ;
    1329                                             
    1330                                             package body StreamTransactionPkg is 
    1331                                             
    1332                                               ------------------------------------------------------------
    1333                                               function resolved_max ( s : StreamUnresolvedOperationVectorType) return StreamUnresolvedOperationType is
    1334                                               ------------------------------------------------------------
    1335                                                 variable Result : StreamUnresolvedOperationType := NOT_DRIVEN ;
    1336                                               begin
    1337            1                    ***0***         for i in s'range loop 
    1337            2                    ***0***     
    1338                                                   if s(i) /= NOT_DRIVEN then 
    1339                                                     if result = NOT_DRIVEN then 
    1340            1                    ***0***               result := s(i) ;
    1341                                                     else
    1342            1                    ***0***               result := MULTIPLE_DRIVER_DETECT ;
    1343                                                     end if ; 
    1344                                                   end if ; 
    1345            1                    ***0***         end loop ;
    1346            1                    ***0***         return result ; 
    1347                                             --    return maximum(s) ;
    1348                                               end function resolved_max ; 
    1349                                               
    1350                                             --    ------------------------------------------------------------
    1351                                             --    function FillParam (TransactionRec : StreamRecType; Param : std_logic_vector) return std_logic_vector is
    1352                                             --    ------------------------------------------------------------
    1353                                             --      variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;
    1354                                             --    begin
    1355                                             --      LocalParam(Param'length-1 downto 0) := Param ; 
    1356                                             --      return Param ;
    1357                                             --    end function FillParam ; 
    1358                                             
    1359                                               -- ========================================================
    1360                                               --  Directive Transactions  
    1361                                               --  Directive transactions interact with the verification component 
    1362                                               --  without generating any transactions or interface waveforms.
    1363                                               --  Supported by all verification components
    1364                                               -- ========================================================
    1365                                               ------------------------------------------------------------
    1366                                               procedure WaitForTransaction (
    1367                                               --  Wait until pending (transmit) or next (receive) transaction(s) complete
    1368                                               ------------------------------------------------------------
    1369                                                 signal    TransactionRec   : inout StreamRecType 
    1370                                               ) is
    1371                                               begin
    1372            1                    ***0***         TransactionRec.Operation   <= WAIT_FOR_TRANSACTION ;
    1373            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    1374                                               end procedure WaitForTransaction ; 
    1375                                             
    1376                                               ------------------------------------------------------------
    1377                                               procedure WaitForClock (
    1378                                               -- Wait for NumberOfClocks number of clocks 
    1379                                               -- relative to the verification component clock
    1380                                               ------------------------------------------------------------
    1381                                                 signal    TransactionRec   : inout StreamRecType ;
    1382                                                 constant  WaitCycles       : in    natural := 1
    1383                                               ) is
    1384                                               begin
    1385            1                    ***0***         TransactionRec.Operation   <= WAIT_FOR_CLOCK ;
    1386            1                    ***0***         TransactionRec.IntToModel  <= WaitCycles ; 
    1387            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    1388                                               end procedure WaitForClock ; 
    1389                                             
    1390                                               ------------------------------------------------------------
    1391                                               procedure GetTransactionCount (
    1392                                               -- Get the number of transactions handled by the model.  
    1393                                               ------------------------------------------------------------
    1394                                                 signal    TransactionRec   : inout StreamRecType ;
    1395                                                 variable  TransactionCount  : out   integer 
    1396                                               ) is
    1397                                               begin
    1398            1                    ***0***         TransactionRec.Operation   <= GET_TRANSACTION_COUNT ;
    1399            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    1400            1                    ***0***         TransactionCount := TransactionRec.IntFromModel ; 
    1401                                               end procedure GetTransactionCount ; 
    1402                                             
    1403                                               ------------------------------------------------------------
    1404                                               procedure GetAlertLogID (
    1405                                               -- Get the AlertLogID from the verification component.
    1406                                               ------------------------------------------------------------
    1407                                                 signal    TransactionRec   : inout StreamRecType ;
    1408                                                 variable  AlertLogID       : out   AlertLogIDType 
    1409                                               ) is
    1410                                               begin
    1411            1                    ***0***         TransactionRec.Operation   <= GET_ALERTLOG_ID ;
    1412            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    1413            1                    ***0***         AlertLogID := AlertLogIDType(TransactionRec.IntFromModel) ; 
    1414                                               end procedure GetAlertLogID ; 
    1415                                               
    1416                                               ------------------------------------------------------------
    1417                                               procedure GetErrorCount (
    1418                                               -- Error reporting for testbenches that do not use OSVVM AlertLogPkg
    1419                                               -- Returns error count.  If an error count /= 0, also print errors
    1420                                               ------------------------------------------------------------
    1421                                                 signal    TransactionRec   : inout StreamRecType ;
    1422                                                 variable  ErrorCount       : out   natural
    1423                                               ) is
    1424                                                 variable  AlertLogID : AlertLogIDType ;
    1425                                               begin
    1426            1                    ***0***         GetAlertLogID(TransactionRec, AlertLogID) ;
    1427                                             --    ReportNonZeroAlerts(AlertLogID => AlertLogID) ;
    1428            1                    ***0***         ErrorCount := GetAlertCount(AlertLogID => AlertLogID) ;
    1429                                               end procedure GetErrorCount ; 
    1430                                             
    1431                                               -- ========================================================
    1432                                               --  Delay Coverage Transactions   
    1433                                               --  Get Delay Coverage ID to change delay coverage parameters.
    1434                                               -- ========================================================
    1435                                               ------------------------------------------------------------
    1436                                               procedure SetUseRandomDelays (
    1437                                               ------------------------------------------------------------
    1438                                                 signal   TransactionRec : InOut StreamRecType ;
    1439                                                 constant OptVal         : In    boolean := TRUE
    1440                                               ) is
    1441                                               begin
    1442            1                    ***0***         TransactionRec.Operation     <= SET_USE_RANDOM_DELAYS ;
    1443            1                    ***0***         TransactionRec.BoolToModel   <= OptVal ;
    1444            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1445                                               end procedure SetUseRandomDelays ;
    1446                                             
    1447                                               ------------------------------------------------------------
    1448                                               procedure GetUseRandomDelays (
    1449                                               ------------------------------------------------------------
    1450                                                 signal   TransactionRec : InOut StreamRecType ;
    1451                                                 variable OptVal         : Out   boolean
    1452                                               ) is
    1453                                               begin
    1454            1                    ***0***         TransactionRec.Operation     <= GET_USE_RANDOM_DELAYS ;
    1455            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1456            1                    ***0***         OptVal := TransactionRec.BoolFromModel    ;
    1457                                               end procedure GetUseRandomDelays ;
    1458                                             
    1459                                               ------------------------------------------------------------
    1460                                               procedure SetDelayCoverageID (
    1461                                               ------------------------------------------------------------
    1462                                                 signal    TransactionRec   : inout StreamRecType ;
    1463                                                 constant  DelayCov         : in    DelayCoverageIdType 
    1464                                             --    constant  Index            : in    integer := 0 
    1465                                               ) is
    1466                                               begin
    1467            1                    ***0***         TransactionRec.Operation     <= SET_DELAYCOV_ID ;
    1468            1                    ***0***         TransactionRec.IntToModel    <= DelayCov.ID ;
    1469                                             --    TransactionRec.Options       <= Index ; 
    1470            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1471                                               end procedure SetDelayCoverageID ;
    1472                                             
    1473                                               ------------------------------------------------------------
    1474                                               procedure GetDelayCoverageID (
    1475                                               ------------------------------------------------------------
    1476                                                 signal    TransactionRec   : inout StreamRecType ;
    1477                                                 variable  DelayCov         : out   DelayCoverageIdType 
    1478                                             --    constant  Index            : in    integer := 0 
    1479                                               ) is
    1480                                               begin
    1481            1                    ***0***         TransactionRec.Operation     <= GET_DELAYCOV_ID ;
    1482                                             --    TransactionRec.Options       <= Index ; 
    1483            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1484            1                    ***0***         DelayCov := GetDelayCoverage(TransactionRec.IntFromModel) ; 
    1485                                               end procedure GetDelayCoverageID ;
    1486                                             
    1487                                               -- ========================================================
    1488                                               --  Set and Get Burst Mode   
    1489                                               --  Set Burst Mode for models that do bursting.
    1490                                               -- ========================================================
    1491                                               ------------------------------------------------------------
    1492                                               procedure SetBurstMode (
    1493                                               ------------------------------------------------------------
    1494                                                 signal    TransactionRec   : inout StreamRecType ;
    1495                                                 constant  OptVal           : in    StreamFifoBurstModeType
    1496                                               ) is
    1497                                               begin
    1498            1                    ***0***         TransactionRec.Operation     <= SET_BURST_MODE ;
    1499            1                    ***0***         TransactionRec.IntToModel    <= OptVal ;
    1500            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1501                                               end procedure SetBurstMode ;
    1502                                             
    1503                                               ------------------------------------------------------------
    1504                                               procedure GetBurstMode (
    1505                                               ------------------------------------------------------------
    1506                                                 signal    TransactionRec   : inout StreamRecType ;
    1507                                                 variable  OptVal           : out   StreamFifoBurstModeType
    1508                                               ) is
    1509                                               begin
    1510            1                    ***0***         TransactionRec.Operation     <= GET_BURST_MODE ;
    1511            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1512            1                    ***0***         OptVal := TransactionRec.IntFromModel ; 
    1513                                               end procedure GetBurstMode ;
    1514                                             
    1515                                               ------------------------------------------------------------
    1516                                               --  GotBurst   
    1517                                               --  Check to see if a Burst is available
    1518                                               ------------------------------------------------------------
    1519                                               ------------------------------------------------------------
    1520                                               procedure GotBurst (
    1521                                               --  Do not refactor. Required by Co-Sim interface 
    1522                                               ------------------------------------------------------------
    1523                                                 signal    TransactionRec   : inout StreamRecType ;
    1524                                                 constant  NumFifoWords     : in    integer ;
    1525                                                 variable  Available        : out   boolean
    1526                                               ) is
    1527                                               begin
    1528            1                    ***0***         TransactionRec.Operation   <= GOT_BURST ;
    1529                                                 -- NumFifoWords not used in all implementations - needed when interface has no burst capability
    1530            1                    ***0***         TransactionRec.IntToModel  <= NumFifoWords ; 
    1531            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1532            1                    ***0***         Available := TransactionRec.BoolFromModel ; 
    1533                                               end procedure GotBurst ;
    1534                                             
    1535                                               -- ========================================================
    1536                                               --  Set and Get Model Options  
    1537                                               --  Model operations are directive transactions that are  
    1538                                               --  used to configure the verification component.  
    1539                                               --  They can either be used directly or with a model specific
    1540                                               --  wrapper around them - see AXI models for examples.
    1541                                               -- ========================================================
    1542                                               ------------------------------------------------------------
    1543                                               procedure SetModelOptions (
    1544                                               ------------------------------------------------------------
    1545                                                 signal    TransactionRec   : inout StreamRecType ;
    1546                                                 constant  Option           : in    integer ;
    1547                                                 constant  OptVal           : in    boolean
    1548                                               ) is
    1549                                               begin
    1550            1                    ***0***         TransactionRec.Operation     <= SET_MODEL_OPTIONS ;
    1551            1                    ***0***         TransactionRec.Options       <= Option ;
    1552            1                    ***0***         TransactionRec.BoolToModel   <= OptVal ;
    1553            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1554                                               end procedure SetModelOptions ;
    1555                                             
    1556                                               ------------------------------------------------------------
    1557                                               procedure SetModelOptions (
    1558                                               ------------------------------------------------------------
    1559                                                 signal    TransactionRec   : inout StreamRecType ;
    1560                                                 constant  Option           : in    integer ;
    1561                                                 constant  OptVal           : in    integer
    1562                                               ) is
    1563                                               begin
    1564            1                    ***0***         TransactionRec.Operation     <= SET_MODEL_OPTIONS ;
    1565            1                    ***0***         TransactionRec.Options       <= Option ;
    1566            1                    ***0***         TransactionRec.IntToModel    <= OptVal ;
    1567            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1568                                               end procedure SetModelOptions ;
    1569                                             
    1570                                               ------------------------------------------------------------
    1571                                               procedure SetModelOptions (
    1572                                               ------------------------------------------------------------
    1573                                                 signal    TransactionRec   : inout StreamRecType ;
    1574                                                 constant  Option           : in    integer ;
    1575                                                 constant  OptVal           : in    std_logic_vector
    1576                                               ) is
    1577                                               begin
    1578            1                    ***0***         TransactionRec.Operation     <= SET_MODEL_OPTIONS ;
    1579            1                    ***0***         TransactionRec.Options       <= Option ;
    1580            1                    ***0***         TransactionRec.IntToModel    <= to_integer(OptVal) ;
    1581            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1582                                               end procedure SetModelOptions ;
    1583                                               
    1584                                               ------------------------------------------------------------
    1585                                               procedure SetModelOptions (
    1586                                               ------------------------------------------------------------
    1587                                                 signal    TransactionRec   : inout StreamRecType ;
    1588                                                 constant  Option           : in    integer ;
    1589                                                 constant  OptVal           : in    time
    1590                                               ) is
    1591                                               begin
    1592            1                    ***0***         TransactionRec.Operation     <= SET_MODEL_OPTIONS ;
    1593            1                    ***0***         TransactionRec.Options       <= Option ;
    1594            1                    ***0***         TransactionRec.TimeToModel   <= OptVal ;
    1595            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1596                                               end procedure SetModelOptions ;
    1597                                             
    1598                                               ------------------------------------------------------------
    1599                                               procedure SetModelOptions (
    1600                                               ------------------------------------------------------------
    1601                                                 signal    TransactionRec   : inout StreamRecType ;
    1602                                                 constant  Option           : in    integer 
    1603                                               ) is
    1604                                               begin
    1605            1                    ***0***         TransactionRec.Operation     <= SET_MODEL_OPTIONS ;
    1606            1                    ***0***         TransactionRec.Options       <= Option ;
    1607                                                 -- OptVal handled by Model Specific Package
    1608                                                 -- TransactionRec.IntToModel    <= to_integer(OptVal) ;
    1609            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1610                                               end procedure SetModelOptions ;
    1611                                             
    1612                                               ------------------------------------------------------------
    1613                                               procedure GetModelOptions (
    1614                                               ------------------------------------------------------------
    1615                                                 signal    TransactionRec   : inout StreamRecType ;
    1616                                                 constant  Option           : in    integer ;
    1617                                                 variable  OptVal           : out   boolean
    1618                                               ) is
    1619                                               begin
    1620            1                    ***0***         TransactionRec.Operation     <= GET_MODEL_OPTIONS ;
    1621            1                    ***0***         TransactionRec.Options       <= Option ;
    1622            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1623            1                    ***0***         OptVal := TransactionRec.BoolFromModel    ;
    1624                                               end procedure GetModelOptions ;
    1625                                             
    1626                                               ------------------------------------------------------------
    1627                                               procedure GetModelOptions (
    1628                                               ------------------------------------------------------------
    1629                                                 signal    TransactionRec   : inout StreamRecType ;
    1630                                                 constant  Option           : in    integer ;
    1631                                                 variable  OptVal           : out   integer
    1632                                               ) is
    1633                                               begin
    1634            1                    ***0***         TransactionRec.Operation     <= GET_MODEL_OPTIONS ;
    1635            1                    ***0***         TransactionRec.Options       <= Option ;
    1636            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1637            1                    ***0***         OptVal := TransactionRec.IntFromModel ; 
    1638                                               end procedure GetModelOptions ;
    1639                                             
    1640                                               ------------------------------------------------------------
    1641                                               procedure GetModelOptions (
    1642                                               ------------------------------------------------------------
    1643                                                 signal    TransactionRec   : inout StreamRecType ;
    1644                                                 constant  Option           : in    integer ;
    1645                                                 variable  OptVal           : out   std_logic_vector
    1646                                               ) is
    1647                                               begin
    1648            1                    ***0***         TransactionRec.Operation     <= GET_MODEL_OPTIONS ;
    1649            1                    ***0***         TransactionRec.Options       <= Option ;
    1650            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1651            1                    ***0***         OptVal := to_slv(TransactionRec.IntFromModel, OptVal'length) ; 
    1652                                               end procedure GetModelOptions ;
    1653                                               
    1654                                               ------------------------------------------------------------
    1655                                               procedure GetModelOptions (
    1656                                               ------------------------------------------------------------
    1657                                                 signal    TransactionRec   : inout StreamRecType ;
    1658                                                 constant  Option           : in    integer ;
    1659                                                 variable  OptVal           : out   time
    1660                                               ) is
    1661                                               begin
    1662            1                    ***0***         TransactionRec.Operation     <= GET_MODEL_OPTIONS ;
    1663            1                    ***0***         TransactionRec.Options       <= Option ;
    1664            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1665            1                    ***0***         OptVal := TransactionRec.TimeFromModel ; 
    1666                                               end procedure GetModelOptions ;
    1667                                             
    1668                                               ------------------------------------------------------------
    1669                                               procedure GetModelOptions (
    1670                                               ------------------------------------------------------------
    1671                                                 signal    TransactionRec   : inout StreamRecType ;
    1672                                                 constant  Option           : in    integer 
    1673                                               ) is
    1674                                               begin
    1675            1                    ***0***         TransactionRec.Operation     <= GET_MODEL_OPTIONS ;
    1676            1                    ***0***         TransactionRec.Options       <= Option ;
    1677            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;
    1678                                                 -- OptVal handled by Model Specific layer overloading
    1679                                                 -- OptVal := TransactionRec.TimeFromModel ; 
    1680                                               end procedure GetModelOptions ;
    1681                                             
    1682                                             
    1683                                               -- ========================================================
    1684                                               --  Transmitter Transactions
    1685                                               -- ========================================================
    1686                                               
    1687                                               -- ========================================================
    1688                                               -- Send
    1689                                               -- Blocking Send Transaction. 
    1690                                               -- Param, when present, is an extra parameter used by the verification component
    1691                                               -- The UART verification component uses Param for error injection.
    1692                                               -- ========================================================
    1693                                               ------------------------------------------------------------
    1694                                               procedure LocalSend (
    1695                                               -- Package Local - simplifies the other calls to Send
    1696                                               ------------------------------------------------------------
    1697                                                 signal    TransactionRec   : inout StreamRecType ;
    1698                                                 constant  Operation        : in    StreamOperationType ;
    1699                                                 constant  Data             : in    std_logic_vector ;
    1700                                                 constant  Param            : in    std_logic_vector ;
    1701                                                 constant  StatusMsgOn      : in    boolean := false 
    1702                                               ) is 
    1703                                                 variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;
    1704                                               begin
    1705            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    1706            1                    ***0***         TransactionRec.Operation     <= Operation ;
    1707            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(Data, TransactionRec.DataToModel'length) ; 
    1708            1                    ***0***         TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; 
    1709            1                    ***0***         TransactionRec.IntToModel    <= Data'length ;
    1710            1                    ***0***         TransactionRec.BoolToModel   <= StatusMsgOn ; 
    1711            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    1712                                               end procedure LocalSend ; 
    1713                                             
    1714                                               ------------------------------------------------------------
    1715                                               procedure Send (
    1716                                               ------------------------------------------------------------
    1717                                                 signal    TransactionRec   : inout StreamRecType ;
    1718                                                 constant  Data             : in    std_logic_vector ;
    1719                                                 constant  Param            : in    std_logic_vector ;
    1720                                                 constant  StatusMsgOn      : in    boolean := false 
    1721                                               ) is 
    1722                                               begin
    1723            1                    ***0***         LocalSend(TransactionRec, SEND, Data, Param, StatusMsgOn) ;
    1724                                               end procedure Send ; 
    1725                                             
    1726                                               ------------------------------------------------------------
    1727                                               procedure Send (
    1728                                               ------------------------------------------------------------
    1729                                                 signal    TransactionRec   : inout StreamRecType ;
    1730                                                 constant  Data             : in    std_logic_vector ;
    1731                                                 constant  StatusMsgOn      : in    boolean := false 
    1732                                               ) is 
    1733                                               begin
    1734            1                    ***0***         LocalSend(TransactionRec, SEND, Data, "", StatusMsgOn);
    1735                                               end procedure Send ; 
    1736                                             
    1737                                               -- ========================================================
    1738                                               -- SendAsync
    1739                                               -- Asynchronous / Non-Blocking Send Transaction
    1740                                               -- Param, when present, is an extra parameter used by the verification component
    1741                                               -- The UART verification component uses Param for error injection. 
    1742                                               -- ========================================================
    1743                                             
    1744                                               ------------------------------------------------------------
    1745                                               procedure SendAsync (
    1746                                               ------------------------------------------------------------
    1747                                                 signal    TransactionRec   : inout StreamRecType ;
    1748                                                 constant  Data             : in    std_logic_vector ;
    1749                                                 constant  Param            : in    std_logic_vector ;
    1750                                                 constant  StatusMsgOn      : in    boolean := false 
    1751                                               ) is 
    1752                                               begin
    1753            1                    ***0***         LocalSend(TransactionRec, SEND_ASYNC, Data, Param, StatusMsgOn) ;
    1754                                               end procedure SendAsync ; 
    1755                                             
    1756                                               ------------------------------------------------------------
    1757                                               procedure SendAsync (
    1758                                               ------------------------------------------------------------
    1759                                                 signal    TransactionRec   : inout StreamRecType ;
    1760                                                 constant  Data             : in    std_logic_vector ;
    1761                                                 constant  StatusMsgOn      : in    boolean := false 
    1762                                               ) is 
    1763                                               begin
    1764            1                    ***0***         LocalSend(TransactionRec, SEND_ASYNC, Data, "", StatusMsgOn);
    1765                                               end procedure SendAsync ; 
    1766                                             
    1767                                             
    1768                                               -- ========================================================
    1769                                               -- SendBurst
    1770                                               -- Blocking Send Burst Transaction. 
    1771                                               -- Param, when present, is an extra parameter used by the verification component
    1772                                               -- The UART verification component uses Param for error injection.
    1773                                               -- ========================================================
    1774                                               ------------------------------------------------------------
    1775                                               procedure LocalSendBurst (
    1776                                               -- Package Local - simplifies the other calls to Send
    1777                                               ------------------------------------------------------------
    1778                                                 signal    TransactionRec   : inout StreamRecType ;
    1779                                                 constant  Operation        : in    StreamOperationType ;
    1780                                                 constant  NumFifoWords     : in    integer ;
    1781                                                 constant  Param            : in    std_logic_vector ;
    1782                                                 constant  StatusMsgOn      : in    boolean := false 
    1783                                               ) is 
    1784                                                 variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;
    1785                                               begin
    1786            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    1787            1                    ***0***         TransactionRec.Operation     <= Operation ;
    1788            1                    ***0***         TransactionRec.IntToModel    <= NumFifoWords ; 
    1789            1                    ***0***         TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; 
    1790            1                    ***0***         TransactionRec.BoolToModel   <= StatusMsgOn ; 
    1791            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    1792                                               end procedure LocalSendBurst ; 
    1793                                             
    1794                                               ------------------------------------------------------------
    1795                                               procedure SendBurst (
    1796                                               ------------------------------------------------------------
    1797                                                 signal    TransactionRec   : inout StreamRecType ;
    1798                                                 constant  NumFifoWords     : in    integer ;
    1799                                                 constant  Param            : in    std_logic_vector ;
    1800                                                 constant  StatusMsgOn      : in    boolean := false 
    1801                                               ) is 
    1802                                               begin
    1803            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ;
    1804                                               end procedure SendBurst ; 
    1805                                             
    1806                                               ------------------------------------------------------------
    1807                                               procedure SendBurst (
    1808                                               ------------------------------------------------------------
    1809                                                 signal    TransactionRec   : inout StreamRecType ;
    1810                                                 constant  NumFifoWords     : in    integer ;
    1811                                                 constant  StatusMsgOn      : in    boolean := false 
    1812                                               ) is 
    1813                                               begin
    1814            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, "", StatusMsgOn) ;
    1815                                               end procedure SendBurst ; 
    1816                                             
    1817                                               ------------------------------------------------------------
    1818                                               procedure SendBurstVector (
    1819                                               ------------------------------------------------------------
    1820                                                 signal    TransactionRec   : inout StreamRecType ;
    1821                                                 constant  VectorOfWords    : in    slv_vector ;
    1822                                                 constant  Param            : in    std_logic_vector ;
    1823                                                 constant  StatusMsgOn      : in    boolean := false
    1824                                               ) is
    1825                                               begin
    1826            1                    ***0***         PushBurstVector(TransactionRec.BurstFifo, VectorOfWords) ;
    1827            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST, VectorOfWords'length, Param, StatusMsgOn) ; 
    1828                                               end procedure SendBurstVector ;
    1829                                               
    1830                                               ------------------------------------------------------------
    1831                                               procedure SendBurstVector (
    1832                                               ------------------------------------------------------------
    1833                                                 signal    TransactionRec   : inout StreamRecType ;
    1834                                                 constant  VectorOfWords    : in    slv_vector ;
    1835                                                 constant  StatusMsgOn      : in    boolean := false
    1836                                               ) is
    1837                                               begin
    1838            1                    ***0***         SendBurstVector(TransactionRec, VectorOfWords, "", StatusMsgOn) ; 
    1839                                               end procedure SendBurstVector ;
    1840                                               
    1841                                               ------------------------------------------------------------
    1842                                               procedure SendBurstVector (
    1843                                               ------------------------------------------------------------
    1844                                                 signal    TransactionRec   : inout StreamRecType ;
    1845                                                 constant  VectorOfWords    : in    integer_vector ;
    1846                                                 constant  Param            : in    std_logic_vector ;
    1847                                                 constant  FifoWidth        : in    integer ; 
    1848                                                 constant  StatusMsgOn      : in    boolean := false
    1849                                               ) is
    1850                                               begin
    1851            1                    ***0***         PushBurstVector(TransactionRec.BurstFifo, VectorOfWords, FifoWidth) ;
    1852            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST, VectorOfWords'length, Param, StatusMsgOn) ; 
    1853                                               end procedure SendBurstVector ;
    1854                                               
    1855                                               ------------------------------------------------------------
    1856                                               procedure SendBurstVector (
    1857                                               ------------------------------------------------------------
    1858                                                 signal    TransactionRec   : inout StreamRecType ;
    1859                                                 constant  VectorOfWords    : in    integer_vector ;
    1860                                                 constant  FifoWidth        : in    integer ; 
    1861                                                 constant  StatusMsgOn      : in    boolean := false
    1862                                               ) is
    1863                                               begin
    1864            1                    ***0***         SendBurstVector(TransactionRec, VectorOfWords, "", FifoWidth, StatusMsgOn) ; 
    1865                                               end procedure SendBurstVector ;
    1866                                               
    1867                                               ------------------------------------------------------------
    1868                                               procedure SendBurstIncrement (
    1869                                               ------------------------------------------------------------
    1870                                                 signal    TransactionRec   : inout StreamRecType ;
    1871                                                 constant  FirstWord        : in    std_logic_vector ;
    1872                                                 constant  NumFifoWords     : in    integer ;
    1873                                                 constant  Param            : in    std_logic_vector ;
    1874                                                 constant  StatusMsgOn      : in    boolean := false
    1875                                               ) is
    1876                                               begin
    1877            1                    ***0***         PushBurstIncrement(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;
    1878            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; 
    1879                                               end procedure SendBurstIncrement ;
    1880                                               
    1881                                               ------------------------------------------------------------
    1882                                               procedure SendBurstIncrement (
    1883                                               ------------------------------------------------------------
    1884                                                 signal    TransactionRec   : inout StreamRecType ;
    1885                                                 constant  FirstWord        : in    std_logic_vector ;
    1886                                                 constant  NumFifoWords     : in    integer ;
    1887                                                 constant  StatusMsgOn      : in    boolean := false
    1888                                               ) is
    1889                                               begin
    1890            1                    ***0***         SendBurstIncrement(TransactionRec, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    1891                                               end procedure SendBurstIncrement ;
    1892                                             
    1893                                               ------------------------------------------------------------
    1894                                               procedure SendBurstRandom (
    1895                                               ------------------------------------------------------------
    1896                                                 signal    TransactionRec   : inout StreamRecType ;
    1897                                                 constant  FirstWord        : in    std_logic_vector ;
    1898                                                 constant  NumFifoWords     : in    integer ;
    1899                                                 constant  Param            : in    std_logic_vector ;
    1900                                                 constant  StatusMsgOn      : in    boolean := false
    1901                                               ) is
    1902                                               begin
    1903            1                    ***0***         PushBurstRandom(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;
    1904            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; 
    1905                                               end procedure SendBurstRandom ;
    1906                                               
    1907                                               ------------------------------------------------------------
    1908                                               procedure SendBurstRandom (
    1909                                               ------------------------------------------------------------
    1910                                                 signal    TransactionRec   : inout StreamRecType ;
    1911                                                 constant  FirstWord        : in    std_logic_vector ;
    1912                                                 constant  NumFifoWords     : in    integer ;
    1913                                                 constant  StatusMsgOn      : in    boolean := false
    1914                                               ) is
    1915                                               begin
    1916            1                    ***0***         SendBurstRandom(TransactionRec, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    1917                                               end procedure SendBurstRandom ;
    1918                                             
    1919                                               ------------------------------------------------------------
    1920                                               procedure SendBurstRandom (
    1921                                               ------------------------------------------------------------
    1922                                                 signal    TransactionRec   : inout StreamRecType ;
    1923                                                 constant  CoverID          : in    CoverageIDType ;
    1924                                                 constant  NumFifoWords     : in    integer ;
    1925                                                 constant  FifoWidth        : in    integer ;
    1926                                                 constant  Param            : in    std_logic_vector ;
    1927                                                 constant  StatusMsgOn      : in    boolean := false
    1928                                               ) is
    1929                                               begin
    1930            1                    ***0***         PushBurstRandom(TransactionRec.BurstFifo, CoverID, NumFifoWords, FifoWidth) ;
    1931            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; 
    1932                                               end procedure SendBurstRandom ;  
    1933                                             
    1934                                               ------------------------------------------------------------
    1935                                               procedure SendBurstRandom (
    1936                                               ------------------------------------------------------------
    1937                                                 signal    TransactionRec   : inout StreamRecType ;
    1938                                                 constant  CoverID          : in    CoverageIDType ;
    1939                                                 constant  NumFifoWords     : in    integer ;
    1940                                                 constant  FifoWidth        : in    integer ;
    1941                                                 constant  StatusMsgOn      : in    boolean := false
    1942                                               ) is
    1943                                               begin
    1944            1                    ***0***         SendBurstRandom(TransactionRec, CoverID, NumFifoWords, FifoWidth, "", StatusMsgOn) ; 
    1945                                               end procedure SendBurstRandom ;  
    1946                                             
    1947                                             
    1948                                               -- ========================================================
    1949                                               -- SendBurstAsync
    1950                                               -- Asynchronous / Non-Blocking Send Transaction
    1951                                               -- Param, when present, is an extra parameter used by the verification component
    1952                                               -- The UART verification component uses Param for error injection. 
    1953                                               -- ========================================================
    1954                                             
    1955                                               ------------------------------------------------------------
    1956                                               procedure SendBurstAsync (
    1957                                               ------------------------------------------------------------
    1958                                                 signal    TransactionRec   : inout StreamRecType ;
    1959                                                 constant  NumFifoWords     : in    integer ;
    1960                                                 constant  Param            : in    std_logic_vector ;
    1961                                                 constant  StatusMsgOn      : in    boolean := false 
    1962                                               ) is 
    1963                                               begin
    1964            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ;
    1965                                               end procedure SendBurstAsync ; 
    1966                                             
    1967                                               ------------------------------------------------------------
    1968                                               procedure SendBurstAsync (
    1969                                               ------------------------------------------------------------
    1970                                                 signal    TransactionRec   : inout StreamRecType ;
    1971                                                 constant  NumFifoWords     : in    integer ;
    1972                                                 constant  StatusMsgOn      : in    boolean := false 
    1973                                               ) is 
    1974                                               begin
    1975            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, "", StatusMsgOn) ;
    1976                                               end procedure SendBurstAsync ; 
    1977                                             
    1978                                               ------------------------------------------------------------
    1979                                               procedure SendBurstVectorAsync (
    1980                                               ------------------------------------------------------------
    1981                                                 signal    TransactionRec   : inout StreamRecType ;
    1982                                                 constant  VectorOfWords    : in    slv_vector ;
    1983                                                 constant  Param            : in    std_logic_vector ;
    1984                                                 constant  StatusMsgOn      : in    boolean := false
    1985                                               ) is
    1986                                               begin
    1987            1                    ***0***         PushBurstVector(TransactionRec.BurstFifo, VectorOfWords) ;
    1988            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, VectorOfWords'length, Param, StatusMsgOn) ; 
    1989                                               end procedure SendBurstVectorAsync ;
    1990                                               
    1991                                               ------------------------------------------------------------
    1992                                               procedure SendBurstVectorAsync (
    1993                                               ------------------------------------------------------------
    1994                                                 signal    TransactionRec   : inout StreamRecType ;
    1995                                                 constant  VectorOfWords    : in    slv_vector ;
    1996                                                 constant  StatusMsgOn      : in    boolean := false
    1997                                               ) is
    1998                                               begin
    1999            1                    ***0***         SendBurstVectorAsync(TransactionRec, VectorOfWords, "", StatusMsgOn) ; 
    2000                                               end procedure SendBurstVectorAsync ;
    2001                                               
    2002                                               ------------------------------------------------------------
    2003                                               procedure SendBurstVectorAsync (
    2004                                               ------------------------------------------------------------
    2005                                                 signal    TransactionRec   : inout StreamRecType ;
    2006                                                 constant  VectorOfWords    : in    integer_vector ;
    2007                                                 constant  Param            : in    std_logic_vector ;
    2008                                                 constant  FifoWidth        : in    integer ; 
    2009                                                 constant  StatusMsgOn      : in    boolean := false
    2010                                               ) is
    2011                                               begin
    2012            1                    ***0***         PushBurstVector(TransactionRec.BurstFifo, VectorOfWords, FifoWidth) ;
    2013            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, VectorOfWords'length, Param, StatusMsgOn) ; 
    2014                                               end procedure SendBurstVectorAsync ;
    2015                                               
    2016                                               ------------------------------------------------------------
    2017                                               procedure SendBurstVectorAsync (
    2018                                               ------------------------------------------------------------
    2019                                                 signal    TransactionRec   : inout StreamRecType ;
    2020                                                 constant  VectorOfWords    : in    integer_vector ;
    2021                                                 constant  FifoWidth        : in    integer ; 
    2022                                                 constant  StatusMsgOn      : in    boolean := false
    2023                                               ) is
    2024                                               begin
    2025            1                    ***0***         SendBurstVectorAsync(TransactionRec, VectorOfWords, "", FifoWidth, StatusMsgOn) ; 
    2026                                               end procedure SendBurstVectorAsync ;
    2027                                               
    2028                                               ------------------------------------------------------------
    2029                                               procedure SendBurstIncrementAsync (
    2030                                               ------------------------------------------------------------
    2031                                                 signal    TransactionRec   : inout StreamRecType ;
    2032                                                 constant  FirstWord        : in    std_logic_vector ;
    2033                                                 constant  NumFifoWords     : in    integer ;
    2034                                                 constant  Param            : in    std_logic_vector ;
    2035                                                 constant  StatusMsgOn      : in    boolean := false
    2036                                               ) is
    2037                                               begin
    2038            1                    ***0***         PushBurstIncrement(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;
    2039            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; 
    2040                                               end procedure SendBurstIncrementAsync ;
    2041                                             
    2042                                               ------------------------------------------------------------
    2043                                               procedure SendBurstIncrementAsync (
    2044                                               ------------------------------------------------------------
    2045                                                 signal    TransactionRec   : inout StreamRecType ;
    2046                                                 constant  FirstWord        : in    std_logic_vector ;
    2047                                                 constant  NumFifoWords     : in    integer ;
    2048                                                 constant  StatusMsgOn      : in    boolean := false
    2049                                               ) is
    2050                                               begin
    2051            1                    ***0***         SendBurstIncrementAsync(TransactionRec, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    2052                                               end procedure SendBurstIncrementAsync ;
    2053                                             
    2054                                               ------------------------------------------------------------
    2055                                               procedure SendBurstRandomAsync (
    2056                                               ------------------------------------------------------------
    2057                                                 signal    TransactionRec   : inout StreamRecType ;
    2058                                                 constant  FirstWord        : in    std_logic_vector ;
    2059                                                 constant  NumFifoWords     : in    integer ;
    2060                                                 constant  Param            : in    std_logic_vector ;
    2061                                                 constant  StatusMsgOn      : in    boolean := false
    2062                                               ) is
    2063                                               begin
    2064            1                    ***0***         PushBurstRandom(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;
    2065            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; 
    2066                                               end procedure SendBurstRandomAsync ;
    2067                                             
    2068                                               ------------------------------------------------------------
    2069                                               procedure SendBurstRandomAsync (
    2070                                               ------------------------------------------------------------
    2071                                                 signal    TransactionRec   : inout StreamRecType ;
    2072                                                 constant  FirstWord        : in    std_logic_vector ;
    2073                                                 constant  NumFifoWords     : in    integer ;
    2074                                                 constant  StatusMsgOn      : in    boolean := false
    2075                                               ) is
    2076                                                 variable RV : RandomPType ; 
    2077                                               begin
    2078            1                    ***0***         SendBurstRandomAsync(TransactionRec, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    2079                                               end procedure SendBurstRandomAsync ;
    2080                                             
    2081                                               ------------------------------------------------------------
    2082                                               procedure SendBurstRandomAsync (
    2083                                               ------------------------------------------------------------
    2084                                                 signal    TransactionRec   : inout StreamRecType ;
    2085                                                 constant  CoverID          : in    CoverageIDType ;
    2086                                                 constant  NumFifoWords     : in    integer ;
    2087                                                 constant  FifoWidth        : in    integer ;
    2088                                                 constant  Param            : in    std_logic_vector ;
    2089                                                 constant  StatusMsgOn      : in    boolean := false
    2090                                               ) is
    2091                                               begin
    2092            1                    ***0***         PushBurstRandom(TransactionRec.BurstFifo, CoverID, NumFifoWords, FifoWidth) ;
    2093            1                    ***0***         LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; 
    2094                                               end procedure SendBurstRandomAsync ;  
    2095                                             
    2096                                               ------------------------------------------------------------
    2097                                               procedure SendBurstRandomAsync (
    2098                                               ------------------------------------------------------------
    2099                                                 signal    TransactionRec   : inout StreamRecType ;
    2100                                                 constant  CoverID          : in    CoverageIDType ;
    2101                                                 constant  NumFifoWords     : in    integer ;
    2102                                                 constant  FifoWidth        : in    integer ;
    2103                                                 constant  StatusMsgOn      : in    boolean := false
    2104                                               ) is
    2105                                               begin
    2106            1                    ***0***         SendBurstRandomAsync(TransactionRec, CoverID, NumFifoWords, FifoWidth, "", StatusMsgOn) ; 
    2107                                               end procedure SendBurstRandomAsync ;  
    2108                                             
    2109                                             
    2110                                               -- ========================================================
    2111                                               --  Receiver Transactions
    2112                                               -- ========================================================
    2113                                             
    2114                                               -- ========================================================
    2115                                               -- Get
    2116                                               -- Blocking Get Transaction. 
    2117                                               -- Param, when present, is an extra parameter used by the verification component
    2118                                               -- The UART verification component uses Param for received error status.
    2119                                               -- ========================================================
    2120                                             
    2121                                               ------------------------------------------------------------
    2122                                               procedure Get (
    2123                                               ------------------------------------------------------------
    2124                                                 signal    TransactionRec   : inout StreamRecType ;
    2125                                                 variable  Data             : out   std_logic_vector ;
    2126                                                 constant  StatusMsgOn      : in    boolean := false 
    2127                                               ) is 
    2128                                               begin
    2129            1                    ***0***         TransactionRec.Operation   <= GET ;
    2130            1                    ***0***         TransactionRec.IntToModel  <= Data'length ;
    2131            1                    ***0***         TransactionRec.BoolToModel <= StatusMsgOn ;     
    2132            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    2133            1                    ***0***         Data  := SafeResize(TransactionRec.DataFromModel, Data'length) ; 
    2134                                               end procedure Get ; 
    2135                                               
    2136                                               ------------------------------------------------------------
    2137                                               procedure Get (
    2138                                               ------------------------------------------------------------
    2139                                                 signal    TransactionRec   : inout StreamRecType ;
    2140                                                 variable  Data             : out   std_logic_vector ;
    2141                                                 variable  Param            : out   std_logic_vector ;
    2142                                                 constant  StatusMsgOn      : in    boolean := false 
    2143                                               ) is 
    2144                                               begin
    2145            1                    ***0***         Get(TransactionRec, Data, StatusMsgOn) ;
    2146            1                    ***0***         Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; 
    2147                                               end procedure Get ;  
    2148                                             
    2149                                               -- ========================================================
    2150                                               -- TryGet
    2151                                               -- Try Get Transaction
    2152                                               -- If Data is available, get it and return available TRUE,
    2153                                               -- otherwise Return Available FALSE.
    2154                                               -- Param, when present, is an extra parameter used by the verification component
    2155                                               -- The UART verification component uses Param for received error status.
    2156                                               -- ========================================================
    2157                                             
    2158                                               ------------------------------------------------------------
    2159                                               procedure TryGet (
    2160                                               ------------------------------------------------------------
    2161                                                 signal    TransactionRec   : inout StreamRecType ;
    2162                                                 variable  Data             : out   std_logic_vector ;
    2163                                                 variable  Available        : out   boolean ;
    2164                                                 constant  StatusMsgOn      : in    boolean := false 
    2165                                               ) is 
    2166                                               begin
    2167            1                    ***0***         TransactionRec.Operation   <= TRY_GET ;
    2168            1                    ***0***         TransactionRec.IntToModel  <= Data'length ;
    2169            1                    ***0***         TransactionRec.BoolToModel <= StatusMsgOn ;     
    2170            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    2171            1                    ***0***         Data      := SafeResize(TransactionRec.DataFromModel, Data'length) ; 
    2172            1                    ***0***         Available := TransactionRec.BoolFromModel ;
    2173                                               end procedure TryGet ; 
    2174                                               
    2175                                               ------------------------------------------------------------
    2176                                               procedure TryGet (
    2177                                               ------------------------------------------------------------
    2178                                                 signal    TransactionRec   : inout StreamRecType ;
    2179                                                 variable  Data             : out   std_logic_vector ;
    2180                                                 variable  Param            : out   std_logic_vector ;
    2181                                                 variable  Available        : out   boolean ;
    2182                                                 constant  StatusMsgOn      : in    boolean := false 
    2183                                               ) is 
    2184                                               begin
    2185            1                    ***0***         TryGet(TransactionRec, Data, Available, StatusMsgOn) ;
    2186            1                    ***0***         Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; 
    2187                                               end procedure TryGet ;  
    2188                                             
    2189                                             
    2190                                               -- ========================================================
    2191                                               -- GetBurst
    2192                                               -- Blocking Get Burst Transaction. 
    2193                                               -- Param, when present, is an extra parameter from the verification component
    2194                                               -- The UART verification component uses Param for received error status.
    2195                                               -- ========================================================
    2196                                             
    2197                                               ------------------------------------------------------------
    2198                                               procedure LocalGetBurst (
    2199                                               ------------------------------------------------------------
    2200                                                 signal    TransactionRec   : inout StreamRecType ;
    2201                                                 constant  NumFifoWords     : in    integer ;
    2202                                                 constant  StatusMsgOn      : in    boolean := false 
    2203                                               ) is 
    2204                                               begin
    2205            1                    ***0***         TransactionRec.Operation   <= GET_BURST ;
    2206            1                    ***0***         TransactionRec.IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)
    2207            1                    ***0***         TransactionRec.BoolToModel <= StatusMsgOn ;     
    2208            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    2209                                               end procedure LocalGetBurst ; 
    2210                                               
    2211                                               ------------------------------------------------------------
    2212                                               procedure GetBurst (
    2213                                               ------------------------------------------------------------
    2214                                                 signal    TransactionRec   : inout StreamRecType ;
    2215                                                 variable  NumFifoWords     : inout integer ;
    2216                                                 constant  StatusMsgOn      : in    boolean := false 
    2217                                               ) is 
    2218                                               begin
    2219            1                    ***0***         LocalGetBurst(TransactionRec, NumFifoWords, StatusMsgOn) ; 
    2220            1                    ***0***         NumFifoWords := TransactionRec.IntFromModel ;
    2221                                               end procedure GetBurst ; 
    2222                                               
    2223                                               ------------------------------------------------------------
    2224                                               procedure GetBurst (
    2225                                               ------------------------------------------------------------
    2226                                                 signal    TransactionRec   : inout StreamRecType ;
    2227                                                 variable  NumFifoWords     : inout integer ;
    2228                                                 variable  Param            : out   std_logic_vector ;
    2229                                                 constant  StatusMsgOn      : in    boolean := false 
    2230                                               ) is 
    2231                                               begin
    2232            1                    ***0***         LocalGetBurst(TransactionRec, NumFifoWords, StatusMsgOn) ; 
    2233            1                    ***0***         NumFifoWords := TransactionRec.IntFromModel ;
    2234            1                    ***0***         Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; 
    2235                                               end procedure GetBurst ;  
    2236                                             
    2237                                               -- ========================================================
    2238                                               -- TryGetBurst
    2239                                               -- Try Get Burst Transaction
    2240                                               -- If Data is available, get it and return available TRUE,
    2241                                               -- otherwise Return Available FALSE.
    2242                                               -- Param, when present, is an extra parameter used by the verification component
    2243                                               -- The UART verification component uses Param for received error status.
    2244                                               -- ========================================================
    2245                                             
    2246                                               ------------------------------------------------------------
    2247                                               procedure LocalTryGetBurst (
    2248                                               ------------------------------------------------------------
    2249                                                 signal    TransactionRec   : inout StreamRecType ;
    2250                                                 constant  NumFifoWords     : in    integer ;
    2251                                                 variable  Available        : out   boolean ;
    2252                                                 constant  StatusMsgOn      : in    boolean := false 
    2253                                               ) is 
    2254                                               begin
    2255            1                    ***0***         TransactionRec.Operation   <= TRY_GET_BURST ;
    2256            1                    ***0***         TransactionRec.IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)
    2257            1                    ***0***         TransactionRec.BoolToModel <= StatusMsgOn ;     
    2258            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    2259            1                    ***0***         Available := TransactionRec.BoolFromModel ;
    2260                                               end procedure LocalTryGetBurst ; 
    2261                                             
    2262                                               ------------------------------------------------------------
    2263                                               procedure TryGetBurst (
    2264                                               ------------------------------------------------------------
    2265                                                 signal    TransactionRec   : inout StreamRecType ;
    2266                                                 variable  NumFifoWords     : inout integer ;
    2267                                                 variable  Available        : out   boolean ;
    2268                                                 constant  StatusMsgOn      : in    boolean := false 
    2269                                               ) is 
    2270                                               begin
    2271            1                    ***0***         LocalTryGetBurst(TransactionRec, NumFifoWords, Available, StatusMsgOn) ;
    2272            1                    ***0***         NumFifoWords  := TransactionRec.IntFromModel ;
    2273                                               end procedure TryGetBurst ; 
    2274                                             
    2275                                               ------------------------------------------------------------
    2276                                               procedure TryGetBurst (
    2277                                               ------------------------------------------------------------
    2278                                                 signal    TransactionRec   : inout StreamRecType ;
    2279                                                 variable  NumFifoWords     : inout integer ;
    2280                                                 variable  Param            : out   std_logic_vector ;
    2281                                                 variable  Available        : out   boolean ;
    2282                                                 constant  StatusMsgOn      : in    boolean := false 
    2283                                               ) is 
    2284                                               begin
    2285            1                    ***0***         LocalTryGetBurst(TransactionRec, NumFifoWords, Available, StatusMsgOn) ;
    2286            1                    ***0***         NumFifoWords  := TransactionRec.IntFromModel ;
    2287            1                    ***0***         Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; 
    2288                                               end procedure TryGetBurst ;  
    2289                                             
    2290                                             
    2291                                               -- ========================================================
    2292                                               -- Check
    2293                                               -- Blocking Get Transaction. 
    2294                                               -- Data is the expected value to be received.
    2295                                               -- Param, when present, is an extra parameter used by the verification component
    2296                                               -- The UART verification component uses Param for received error status.
    2297                                               -- ========================================================
    2298                                             
    2299                                               ------------------------------------------------------------
    2300                                               procedure Check (
    2301                                               ------------------------------------------------------------
    2302                                                 signal    TransactionRec   : inout StreamRecType ;
    2303                                                 constant  Data             : in    std_logic_vector ;
    2304                                                 constant  Param            : in    std_logic_vector ;
    2305                                                 constant  StatusMsgOn      : in    boolean := false 
    2306                                               ) is 
    2307                                                 variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;
    2308                                               begin
    2309            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    2310            1                    ***0***         TransactionRec.Operation     <= CHECK ;
    2311            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(Data, TransactionRec.DataToModel'length) ; 
    2312            1                    ***0***         TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; 
    2313            1                    ***0***         TransactionRec.IntToModel    <= Data'length ;
    2314            1                    ***0***         TransactionRec.BoolToModel   <= StatusMsgOn ;     
    2315            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    2316                                               end procedure Check ; 
    2317                                             
    2318                                               ------------------------------------------------------------
    2319                                               procedure Check (
    2320                                               ------------------------------------------------------------
    2321                                                 signal    TransactionRec   : inout StreamRecType ;
    2322                                                 constant  Data             : in    std_logic_vector ;
    2323                                                 constant  StatusMsgOn      : in    boolean := false 
    2324                                               ) is 
    2325                                               begin
    2326            1                    ***0***         Check(TransactionRec, Data, "", StatusMsgOn) ;
    2327                                               end procedure Check ; 
    2328                                             
    2329                                             
    2330                                               -- ========================================================
    2331                                               -- TryCheck
    2332                                               -- Try Check Transaction
    2333                                               -- If Data is available, check it and return available TRUE,
    2334                                               -- otherwise Return Available FALSE.
    2335                                               -- Param, when present, is an extra parameter used by the verification component
    2336                                               -- The UART verification component uses Param for received error status.
    2337                                               -- ========================================================
    2338                                             
    2339                                               ------------------------------------------------------------
    2340                                               procedure TryCheck (
    2341                                               ------------------------------------------------------------
    2342                                                 signal    TransactionRec   : inout StreamRecType ;
    2343                                                 constant  Data             : in    std_logic_vector ;
    2344                                                 constant  Param            : in    std_logic_vector ;
    2345                                                 variable  Available        : out   boolean ;
    2346                                                 constant  StatusMsgOn      : in    boolean := false 
    2347                                               ) is 
    2348                                                 variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;
    2349                                               begin
    2350            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    2351            1                    ***0***         TransactionRec.Operation     <= TRY_CHECK ;
    2352            1                    ***0***         TransactionRec.DataToModel   <= SafeResize(Data, TransactionRec.DataToModel'length) ; 
    2353            1                    ***0***         TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; 
    2354            1                    ***0***         TransactionRec.IntToModel    <= Data'length ;
    2355            1                    ***0***         TransactionRec.BoolToModel   <= StatusMsgOn ;     
    2356            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    2357            1                    ***0***         Available := TransactionRec.BoolFromModel ;
    2358                                               end procedure TryCheck ; 
    2359                                             
    2360                                               ------------------------------------------------------------
    2361                                               procedure TryCheck (
    2362                                               ------------------------------------------------------------
    2363                                                 signal    TransactionRec   : inout StreamRecType ;
    2364                                                 constant  Data             : in    std_logic_vector ;
    2365                                                 variable  Available        : out   boolean ;
    2366                                                 constant  StatusMsgOn      : in    boolean := false 
    2367                                               ) is 
    2368                                               begin
    2369            1                    ***0***         TryCheck(TransactionRec, Data, "", Available, StatusMsgOn) ;
    2370                                               end procedure TryCheck ; 
    2371                                             
    2372                                             
    2373                                               -- ========================================================
    2374                                               -- CheckBurst
    2375                                               -- Blocking Check Burst Transaction. 
    2376                                               -- Param, when present, is an extra parameter used by the verification component
    2377                                               -- The UART verification component uses Param for checking error injection.
    2378                                               -- ========================================================
    2379                                               ------------------------------------------------------------
    2380                                               procedure LocalCheckBurst (
    2381                                               -- Package Local - simplifies the other calls to Check
    2382                                               ------------------------------------------------------------
    2383                                                 signal    TransactionRec   : inout StreamRecType ;
    2384                                                 constant  Operation        : in    StreamOperationType ;
    2385                                                 constant  NumFifoWords     : in    integer ;
    2386                                                 constant  Param            : in    std_logic_vector ;
    2387                                                 constant  StatusMsgOn      : in    boolean := false 
    2388                                               ) is 
    2389                                                 variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;
    2390                                               begin
    2391            1                    ***0***         LocalParam(Param'length-1 downto 0) := Param ; 
    2392            1                    ***0***         TransactionRec.Operation     <= Operation ;
    2393            1                    ***0***         TransactionRec.IntToModel    <= NumFifoWords ; 
    2394            1                    ***0***         TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; 
    2395            1                    ***0***         TransactionRec.BoolToModel   <= StatusMsgOn ; 
    2396            1                    ***0***         RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; 
    2397                                               end procedure LocalCheckBurst ; 
    2398                                             
    2399                                               ------------------------------------------------------------
    2400                                               procedure CheckBurst (
    2401                                               ------------------------------------------------------------
    2402                                                 signal    TransactionRec   : inout StreamRecType ;
    2403                                                 constant  NumFifoWords     : in    integer ;
    2404                                                 constant  Param            : in    std_logic_vector ;
    2405                                                 constant  StatusMsgOn      : in    boolean := false 
    2406                                               ) is 
    2407                                               begin
    2408            1                    ***0***         LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2409                                               end procedure CheckBurst ; 
    2410                                               
    2411                                               ------------------------------------------------------------
    2412                                               procedure CheckBurst (
    2413                                               ------------------------------------------------------------
    2414                                                 signal    TransactionRec   : inout StreamRecType ;
    2415                                                 constant  NumFifoWords     : in    integer ;
    2416                                                 constant  StatusMsgOn      : in    boolean := false 
    2417                                               ) is 
    2418                                               begin
    2419            1                    ***0***         LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, "", StatusMsgOn) ;
    2420                                               end procedure CheckBurst ; 
    2421                                             
    2422                                               ------------------------------------------------------------
    2423                                               procedure CheckBurstVector (
    2424                                               ------------------------------------------------------------
    2425                                                 signal    TransactionRec   : inout StreamRecType ;
    2426                                                 constant  VectorOfWords    : in    slv_vector ;
    2427                                                 constant  Param            : in    std_logic_vector ;
    2428                                                 constant  StatusMsgOn      : in    boolean := false
    2429                                               ) is
    2430                                               begin
    2431            1                    ***0***         PushBurstVector(TransactionRec.BurstFifo, VectorOfWords) ;
    2432            1                    ***0***         LocalCheckBurst(TransactionRec, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;
    2433                                               end procedure CheckBurstVector ;
    2434                                               
    2435                                               ------------------------------------------------------------
    2436                                               procedure CheckBurstVector (
    2437                                               ------------------------------------------------------------
    2438                                                 signal    TransactionRec   : inout StreamRecType ;
    2439                                                 constant  VectorOfWords    : in    slv_vector ;
    2440                                                 constant  StatusMsgOn      : in    boolean := false
    2441                                               ) is
    2442                                               begin
    2443            1                    ***0***         CheckBurstVector(TransactionRec, VectorOfWords, "", StatusMsgOn) ; 
    2444                                               end procedure CheckBurstVector ;
    2445                                               
    2446                                               ------------------------------------------------------------
    2447                                               procedure CheckBurstVector (
    2448                                               ------------------------------------------------------------
    2449                                                 signal    TransactionRec   : inout StreamRecType ;
    2450                                                 constant  VectorOfWords    : in    integer_vector ;
    2451                                                 constant  Param            : in    std_logic_vector ;
    2452                                                 constant  FifoWidth        : in    integer ; 
    2453                                                 constant  StatusMsgOn      : in    boolean := false
    2454                                               ) is
    2455                                               begin
    2456            1                    ***0***         PushBurstVector(TransactionRec.BurstFifo, VectorOfWords, FifoWidth) ;
    2457            1                    ***0***         LocalCheckBurst(TransactionRec, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;
    2458                                               end procedure CheckBurstVector ;
    2459                                               
    2460                                               ------------------------------------------------------------
    2461                                               procedure CheckBurstVector (
    2462                                               ------------------------------------------------------------
    2463                                                 signal    TransactionRec   : inout StreamRecType ;
    2464                                                 constant  VectorOfWords    : in    integer_vector ;
    2465                                                 constant  FifoWidth        : in    integer ; 
    2466                                                 constant  StatusMsgOn      : in    boolean := false
    2467                                               ) is
    2468                                               begin
    2469            1                    ***0***         CheckBurstVector(TransactionRec, VectorOfWords, "", FifoWidth, StatusMsgOn) ; 
    2470                                               end procedure CheckBurstVector ;
    2471                                               
    2472                                               ------------------------------------------------------------
    2473                                               procedure CheckBurstIncrement (
    2474                                               ------------------------------------------------------------
    2475                                                 signal    TransactionRec   : inout StreamRecType ;
    2476                                                 constant  FirstWord        : in    std_logic_vector ;
    2477                                                 constant  NumFifoWords     : in    integer ;
    2478                                                 constant  Param            : in    std_logic_vector ;
    2479                                                 constant  StatusMsgOn      : in    boolean := false
    2480                                               ) is
    2481                                               begin
    2482            1                    ***0***         PushBurstIncrement(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;
    2483            1                    ***0***         LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2484                                               end procedure CheckBurstIncrement ;
    2485                                             
    2486                                               ------------------------------------------------------------
    2487                                               procedure CheckBurstIncrement (
    2488                                               ------------------------------------------------------------
    2489                                                 signal    TransactionRec   : inout StreamRecType ;
    2490                                                 constant  FirstWord        : in    std_logic_vector ;
    2491                                                 constant  NumFifoWords     : in    integer ;
    2492                                                 constant  StatusMsgOn      : in    boolean := false
    2493                                               ) is
    2494                                               begin
    2495            1                    ***0***         CheckBurstIncrement(TransactionRec, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    2496                                               end procedure CheckBurstIncrement ;
    2497                                             
    2498                                               ------------------------------------------------------------
    2499                                               procedure CheckBurstRandom (
    2500                                               ------------------------------------------------------------
    2501                                                 signal    TransactionRec   : inout StreamRecType ;
    2502                                                 constant  FirstWord        : in    std_logic_vector ;
    2503                                                 constant  NumFifoWords     : in    integer ;
    2504                                                 constant  Param            : in    std_logic_vector ;
    2505                                                 constant  StatusMsgOn      : in    boolean := false
    2506                                               ) is
    2507                                               begin
    2508            1                    ***0***         PushBurstRandom(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;
    2509            1                    ***0***         LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2510                                               end procedure CheckBurstRandom ;
    2511                                               
    2512                                               ------------------------------------------------------------
    2513                                               procedure CheckBurstRandom (
    2514                                               ------------------------------------------------------------
    2515                                                 signal    TransactionRec   : inout StreamRecType ;
    2516                                                 constant  FirstWord        : in    std_logic_vector ;
    2517                                                 constant  NumFifoWords     : in    integer ;
    2518                                                 constant  StatusMsgOn      : in    boolean := false
    2519                                               ) is
    2520                                               begin
    2521            1                    ***0***         CheckBurstRandom(TransactionRec, FirstWord, NumFifoWords, "", StatusMsgOn) ; 
    2522                                               end procedure CheckBurstRandom ;
    2523                                             
    2524                                               ------------------------------------------------------------
    2525                                               procedure CheckBurstRandom (
    2526                                               ------------------------------------------------------------
    2527                                                 signal    TransactionRec   : inout StreamRecType ;
    2528                                                 constant  CoverID          : in    CoverageIDType ;
    2529                                                 constant  NumFifoWords     : in    integer ;
    2530                                                 constant  FifoWidth        : in    integer ;
    2531                                                 constant  Param            : in    std_logic_vector ;
    2532                                                 constant  StatusMsgOn      : in    boolean := false
    2533                                               ) is
    2534                                               begin
    2535            1                    ***0***         PushBurstRandom(TransactionRec.BurstFifo, CoverID, NumFifoWords, FifoWidth) ;
    2536            1                    ***0***         LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2537                                               end procedure CheckBurstRandom ;  
    2538                                             
    2539                                               ------------------------------------------------------------
    2540                                               procedure CheckBurstRandom (
    2541                                               ------------------------------------------------------------
    2542                                                 signal    TransactionRec   : inout StreamRecType ;
    2543                                                 constant  CoverID          : in    CoverageIDType ;
    2544                                                 constant  NumFifoWords     : in    integer ;
    2545                                                 constant  FifoWidth        : in    integer ;
    2546                                                 constant  StatusMsgOn      : in    boolean := false
    2547                                               ) is
    2548                                               begin
    2549            1                    ***0***         CheckBurstRandom(TransactionRec, CoverID, NumFifoWords, FifoWidth, "", StatusMsgOn) ;
    2550                                               end procedure CheckBurstRandom ;  
    2551                                             
    2552                                               -- ========================================================
    2553                                               -- TryCheckBurst
    2554                                               -- Try / Non-Blocking Check Burst Transaction
    2555                                               -- Param, when present, is an extra parameter used by the verification component
    2556                                               -- The UART verification component uses Param for error injection. 
    2557                                               -- ========================================================
    2558                                               ------------------------------------------------------------
    2559                                               procedure TryCheckBurst (
    2560                                               ------------------------------------------------------------
    2561                                                 signal    TransactionRec   : inout StreamRecType ;
    2562                                                 constant  NumFifoWords     : in    integer ;
    2563                                                 constant  Param            : in    std_logic_vector ;
    2564                                                 variable  Available        : out   boolean ;
    2565                                                 constant  StatusMsgOn      : in    boolean := false 
    2566                                               ) is 
    2567                                               begin
    2568            1                    ***0***         LocalCheckBurst(TransactionRec, TRY_CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2569            1                    ***0***         Available := TransactionRec.BoolFromModel ;
    2570                                               end procedure TryCheckBurst ; 
    2571                                             
    2572                                               ------------------------------------------------------------
    2573                                               procedure TryCheckBurst (
    2574                                               ------------------------------------------------------------
    2575                                                 signal    TransactionRec   : inout StreamRecType ;
    2576                                                 constant  NumFifoWords     : in    integer ;
    2577                                                 variable  Available        : out   boolean ;
    2578                                                 constant  StatusMsgOn      : in    boolean := false 
    2579                                               ) is 
    2580                                               begin
    2581            1                    ***0***         LocalCheckBurst(TransactionRec, TRY_CHECK_BURST, NumFifoWords, "", StatusMsgOn) ;
    2582            1                    ***0***         Available := TransactionRec.BoolFromModel ;
    2583                                               end procedure TryCheckBurst ; 
    2584                                             
    2585                                               ------------------------------------------------------------
    2586                                               procedure TryCheckBurstVector (
    2587                                               ------------------------------------------------------------
    2588                                                 signal    TransactionRec   : inout StreamRecType ;
    2589                                                 constant  VectorOfWords    : in    slv_vector ;
    2590                                                 constant  Param            : in    std_logic_vector ;
    2591                                                 variable  Available        : out   boolean ;
    2592                                                 constant  StatusMsgOn      : in    boolean := false
    2593                                               ) is
    2594                                               begin
    2595            1                    ***0***         GotBurst(TransactionRec, VectorOfWords'length, Available) ; 
    2596                                                 if Available then 
    2597            1                    ***0***           PushBurstVector(TransactionRec.BurstFifo, VectorOfWords) ;
    2598            1                    ***0***           LocalCheckBurst(TransactionRec, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;
    2599                                                 end if ; 
    2600                                               end procedure TryCheckBurstVector ;
    2601                                                 
    2602                                               ------------------------------------------------------------
    2603                                               procedure TryCheckBurstVector (
    2604                                               ------------------------------------------------------------
    2605                                                 signal    TransactionRec   : inout StreamRecType ;
    2606                                                 constant  VectorOfWords    : in    slv_vector ;
    2607                                                 variable  Available        : out   boolean ;
    2608                                                 constant  StatusMsgOn      : in    boolean := false
    2609                                               ) is
    2610                                               begin
    2611            1                    ***0***         TryCheckBurstVector(TransactionRec, VectorOfWords, "", Available, StatusMsgOn) ;
    2612                                               end procedure TryCheckBurstVector ;
    2613                                               
    2614                                               ------------------------------------------------------------
    2615                                               procedure TryCheckBurstVector (
    2616                                               ------------------------------------------------------------
    2617                                                 signal    TransactionRec   : inout StreamRecType ;
    2618                                                 constant  VectorOfWords    : in    integer_vector ;
    2619                                                 constant  Param            : in    std_logic_vector ;
    2620                                                 variable  Available        : out   boolean ;
    2621                                                 constant  FifoWidth        : in    integer ; 
    2622                                                 constant  StatusMsgOn      : in    boolean := false
    2623                                               ) is
    2624                                               begin
    2625            1                    ***0***         GotBurst(TransactionRec, VectorOfWords'length, Available) ; 
    2626                                                 if Available then 
    2627            1                    ***0***           PushBurstVector(TransactionRec.BurstFifo, VectorOfWords, FifoWidth) ;
    2628            1                    ***0***           LocalCheckBurst(TransactionRec, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;
    2629                                                 end if ; 
    2630                                               end procedure TryCheckBurstVector ;
    2631                                                 
    2632                                               ------------------------------------------------------------
    2633                                               procedure TryCheckBurstVector (
    2634                                               ------------------------------------------------------------
    2635                                                 signal    TransactionRec   : inout StreamRecType ;
    2636                                                 constant  VectorOfWords    : in    integer_vector ;
    2637                                                 variable  Available        : out   boolean ;
    2638                                                 constant  FifoWidth        : in    integer ; 
    2639                                                 constant  StatusMsgOn      : in    boolean := false
    2640                                               ) is
    2641                                               begin
    2642            1                    ***0***         TryCheckBurstVector(TransactionRec, VectorOfWords, "", Available, FifoWidth, StatusMsgOn) ;
    2643                                               end procedure TryCheckBurstVector ;
    2644                                               
    2645                                               ------------------------------------------------------------
    2646                                               procedure TryCheckBurstIncrement (
    2647                                               ------------------------------------------------------------
    2648                                                 signal    TransactionRec   : inout StreamRecType ;
    2649                                                 constant  FirstWord        : in    std_logic_vector ;
    2650                                                 constant  NumFifoWords     : in    integer ;
    2651                                                 constant  Param            : in    std_logic_vector ;
    2652                                                 variable  Available        : out   boolean ;
    2653                                                 constant  StatusMsgOn      : in    boolean := false
    2654                                               ) is
    2655                                               begin
    2656            1                    ***0***         GotBurst(TransactionRec, NumFifoWords, Available) ; 
    2657                                                 if Available then
    2658            1                    ***0***           PushBurstIncrement(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;
    2659            1                    ***0***           LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2660                                                 end if ; 
    2661                                               end procedure TryCheckBurstIncrement ;
    2662                                             
    2663                                               ------------------------------------------------------------
    2664                                               procedure TryCheckBurstIncrement (
    2665                                               ------------------------------------------------------------
    2666                                                 signal    TransactionRec   : inout StreamRecType ;
    2667                                                 constant  FirstWord        : in    std_logic_vector ;
    2668                                                 constant  NumFifoWords     : in    integer ;
    2669                                                 variable  Available        : out   boolean ;
    2670                                                 constant  StatusMsgOn      : in    boolean := false
    2671                                               ) is
    2672                                               begin
    2673            1                    ***0***         TryCheckBurstIncrement(TransactionRec, FirstWord, NumFifoWords, "", Available, StatusMsgOn) ; 
    2674                                               end procedure TryCheckBurstIncrement ;
    2675                                             
    2676                                               ------------------------------------------------------------
    2677                                               procedure TryCheckBurstRandom (
    2678                                               ------------------------------------------------------------
    2679                                                 signal    TransactionRec   : inout StreamRecType ;
    2680                                                 constant  FirstWord        : in    std_logic_vector ;
    2681                                                 constant  NumFifoWords     : in    integer ;
    2682                                                 constant  Param            : in    std_logic_vector ;
    2683                                                 variable  Available        : out   boolean ;
    2684                                                 constant  StatusMsgOn      : in    boolean := false
    2685                                               ) is
    2686                                               begin
    2687            1                    ***0***         GotBurst(TransactionRec, NumFifoWords, Available) ; 
    2688                                                 if Available then
    2689            1                    ***0***           PushBurstRandom(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;
    2690            1                    ***0***           LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2691                                                 end if ; 
    2692                                               end procedure TryCheckBurstRandom ;
    2693                                             
    2694                                               ------------------------------------------------------------
    2695                                               procedure TryCheckBurstRandom (
    2696                                               ------------------------------------------------------------
    2697                                                 signal    TransactionRec   : inout StreamRecType ;
    2698                                                 constant  FirstWord        : in    std_logic_vector ;
    2699                                                 constant  NumFifoWords     : in    integer ;
    2700                                                 variable  Available        : out   boolean ;
    2701                                                 constant  StatusMsgOn      : in    boolean := false
    2702                                               ) is
    2703                                               begin
    2704            1                    ***0***         TryCheckBurstRandom(TransactionRec, FirstWord, NumFifoWords, "", Available, StatusMsgOn) ; 
    2705                                               end procedure TryCheckBurstRandom ;
    2706                                             
    2707                                               ------------------------------------------------------------
    2708                                               procedure TryCheckBurstRandom (
    2709                                               ------------------------------------------------------------
    2710                                                 signal    TransactionRec   : inout StreamRecType ;
    2711                                                 constant  CoverID          : in    CoverageIDType ;
    2712                                                 constant  NumFifoWords     : in    integer ;
    2713                                                 constant  FifoWidth        : in    integer ;
    2714                                                 constant  Param            : in    std_logic_vector ;
    2715                                                 variable  Available        : out   boolean ;
    2716                                                 constant  StatusMsgOn      : in    boolean := false
    2717                                               ) is
    2718                                               begin
    2719            1                    ***0***         GotBurst(TransactionRec, NumFifoWords, Available) ; 
    2720                                                 if Available then
    2721            1                    ***0***           PushBurstRandom(TransactionRec.BurstFifo, CoverID, NumFifoWords, FifoWidth) ;
    2722            1                    ***0***           LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;
    2723                                                 end if ; 
    2724                                               end procedure TryCheckBurstRandom ;  
    2725                                             
    2726                                               ------------------------------------------------------------
    2727                                               procedure TryCheckBurstRandom (
    2728                                               ------------------------------------------------------------
    2729                                                 signal    TransactionRec   : inout StreamRecType ;
    2730                                                 constant  CoverID          : in    CoverageIDType ;
    2731                                                 constant  NumFifoWords     : in    integer ;
    2732                                                 constant  FifoWidth        : in    integer ;
    2733                                                 variable  Available        : out   boolean ;
    2734                                                 constant  StatusMsgOn      : in    boolean := false
    2735                                               ) is
    2736                                               begin
    2737            1                    ***0***         TryCheckBurstRandom(TransactionRec, CoverID, NumFifoWords, FifoWidth, "", Available, StatusMsgOn) ;
    2738                                               end procedure TryCheckBurstRandom ;  
    2739                                             
    2740                                             
    2741                                               -- ========================================================
    2742                                               --  Send And Get Transactions
    2743                                               -- 
    2744                                               -- ========================================================
    2745                                               ------------------------------------------------------------
    2746                                               procedure SendAndGet (
    2747                                               ------------------------------------------------------------
    2748                                                 signal    TransactionRec   : inout StreamRecType ;
    2749                                                 constant  iData            : in    std_logic_vector ;
    2750                                                 constant  iParam           : in    std_logic_vector ;
    2751                                                 variable  oData            : out   std_logic_vector ;
    2752                                                 variable  oParam           : out   std_logic_vector ;
    2753                                                 constant  StatusMsgOn      : in    boolean := false 
    2754                                               ) is 
    2755                                               begin
    2756            1                    ***0***         LocalSend(TransactionRec, SEND_AND_GET, iData, iParam, StatusMsgOn) ;
    2757            1                    ***0***         oData  := SafeResize(TransactionRec.DataFromModel,  oData'length) ; 
    2758            1                    ***0***         oParam := SafeResize(TransactionRec.ParamFromModel, oParam'length) ; 
    2759                                               end procedure SendAndGet ;  
    2760                                             
    2761                                               ------------------------------------------------------------
    2762                                               procedure SendAndGet (
    2763                                               ------------------------------------------------------------
    2764                                                 signal    TransactionRec   : inout StreamRecType ;
    2765                                                 constant  iData            : in    std_logic_vector ;
    2766                                                 variable  oData            : out   std_logic_vector ;
    2767                                                 constant  StatusMsgOn      : in    boolean := false 
    2768                                               ) is 
    2769                                               begin
    2770            1                    ***0***         LocalSend(TransactionRec, SEND_AND_GET, iData, "", StatusMsgOn) ;
    2771            1                    ***0***         oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ; 
    2772                                               end procedure SendAndGet ;  
    2773                                             
    2774                                               ------------------------------------------------------------
    2775                                               procedure SendAndGetBurst (
    2776                                               ------------------------------------------------------------
    2777                                                 signal    TransactionRec   : inout StreamRecType ;
    2778                                                 constant  iNumFifoWords    : in    integer ;
    2779                                                 constant  iParam           : in    std_logic_vector ;
    2780                                                 variable  oNumFifoWords    : out   integer ;
    2781                                                 variable  oParam           : out   std_logic_vector ;
    2782                                                 constant  StatusMsgOn      : in    boolean := false 
    2783                                               ) is 
    2784                                               begin
    2785            1                    ***0***         LocalSendBurst(TransactionRec, SEND_AND_GET_BURST, iNumFifoWords, iParam, StatusMsgOn) ;
    2786            1                    ***0***         oNumFifoWords := TransactionRec.IntFromModel ;
    2787            1                    ***0***         oParam        := SafeResize(TransactionRec.ParamFromModel, oParam'length) ; 
    2788                                               end procedure SendAndGetBurst ; 
    2789                                             
    2790                                               ------------------------------------------------------------
    2791                                               procedure SendAndGetBurst (
    2792                                               ------------------------------------------------------------
    2793                                                 signal    TransactionRec   : inout StreamRecType ;
    2794                                                 constant  iNumFifoWords    : in    integer ;
    2795                                                 variable  oNumFifoWords    : out   integer ;
    2796                                                 constant  StatusMsgOn      : in    boolean := false 
    2797                                               ) is 
    2798                                               begin
    2799            1                    ***0***         LocalSendBurst(TransactionRec, SEND_AND_GET_BURST, iNumFifoWords, "", StatusMsgOn) ;
    2800            1                    ***0***         oNumFifoWords := TransactionRec.IntFromModel ;
    2801                                               end procedure SendAndGetBurst ; 
    2802                                             
    2803                                             
    2804                                               -- ========================================================
    2805                                               --  Pseudo Transactions
    2806                                               --  Interact with the record only.
    2807                                               -- ========================================================
    2808                                               ------------------------------------------------------------
    2809                                               procedure ReleaseTransactionRecord (
    2810                                               --  Must run on same delta cycle as AcquireTransactionRecord
    2811                                               ------------------------------------------------------------
    2812                                                 signal    TransactionRec   : inout StreamRecType 
    2813                                               ) is
    2814                                               begin
    2815                                                 -- Set everything driven by TestCtrl to type'left (except Rdy)
    2816            1                    ***0***         TransactionRec.Rdy           <= RdyType'left ;   
    2817            1                    ***0***         TransactionRec.Operation     <= NOT_DRIVEN ;
    2818            1                    ***0***         TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'U') ;
    2819            1                    ***0***         TransactionRec.ParamToModel  <= (TransactionRec.ParamToModel'range => 'U') ;
    2820            1                    ***0***         TransactionRec.IntToModel    <= integer'left ; 
    2821            1                    ***0***         TransactionRec.BoolToModel   <= boolean'left ; 
    2822            1                    ***0***         TransactionRec.TimeToModel   <= time'left ; 
    2823            1                    ***0***         TransactionRec.Options       <= integer'left ;    
    2824                                               end procedure ReleaseTransactionRecord ; 
    2825                                               
    2826                                               ------------------------------------------------------------
    2827                                               procedure AcquireTransactionRecord (
    2828                                               --  Must run on same delta cycle as ReleaseTransactionRecord
    2829                                               ------------------------------------------------------------
    2830                                                 signal    TransactionRec   : inout StreamRecType 
    2831                                               ) is
    2832                                               begin
    2833                                                 -- Start Driving Rdy on next delta cycle with the current value.  
    2834            1                    ***0***         TransactionRec.Rdy           <= TransactionRec.Rdy ; 
    2835                                               end procedure AcquireTransactionRecord ; 
    2836                                             
    2837                                             
    2838                                               -- ========================================================
    2839                                               --  Verification Component Support Functions
    2840                                               --  These help decode the operation value (StreamOperationType)  
    2841                                               --  to determine properties about the operation
    2842                                               -- ========================================================
    2843                                               ------------------------------------------------------------
    2844                                               function IsBlocking (
    2845                                               -----------------------------------------------------------
    2846                                                 constant  Operation        : in StreamOperationType
    2847                                               ) return boolean is
    2848                                               begin
    2849                                                 return (Operation = SEND) or (Operation = GET) or (Operation = CHECK) or 
    2850            1                    ***0***                (Operation = SEND_BURST) or (Operation = GET_BURST) or (Operation = CHECK_BURST)  ;
    2851                                               end function IsBlocking ;
    2852                                             
    2853                                               ------------------------------------------------------------
    2854                                               function IsTry (
    2855                                               -----------------------------------------------------------
    2856                                                 constant  Operation        : in StreamOperationType
    2857                                               ) return boolean is
    2858                                               begin
    2859            1                    ***0***         return (Operation = TRY_GET) or (Operation = TRY_CHECK) or (Operation = TRY_GET_BURST) or (Operation = TRY_CHECK_BURST) ;
    2860                                               end function IsTry ;
    2861                                             
    2862                                               ------------------------------------------------------------
    2863                                               function IsCheck (
    2864                                               -----------------------------------------------------------
    2865                                                 constant  Operation        : in StreamOperationType
    2866                                               ) return boolean is
    2867                                               begin
    2868            1                    ***0***         return (Operation = CHECK) or (Operation = TRY_CHECK) or (Operation = CHECK_BURST) or (Operation = TRY_CHECK_BURST) ;
    2869                                               end function IsCheck ;
    2870                                               
    2871                                               ------------------------------------------------------------
    2872                                               function IsTransmitterOperation (
    2873                                               -----------------------------------------------------------
    2874                                                 constant  Operation        : in StreamOperationType
    2875                                               ) return boolean is
    2876                                               begin
    2877            1                    ***0***         return (Operation < START_OF_RX_OPS) ;
    2878                                               end function IsTransmitterOperation ;
    2879                                             
    2880                                               ------------------------------------------------------------
    2881                                               function IsReceiverOperation (
    2882                                               -----------------------------------------------------------
    2883                                                 constant  Operation        : in StreamOperationType
    2884                                               ) return boolean is
    2885                                               begin
    2886            1                    ***0***         return (Operation < START_OF_TX_OPS) or (Operation > START_OF_RX_OPS) ;
    2887                                               end function IsReceiverOperation ;
    2888                                             
    2889                                               ------------------------------------------------------------
    2890                                               function ClassifyUnimplementedOperation (
    2891                                               -----------------------------------------------------------
    2892                                                 constant  Operation        : in StreamOperationType;
    2893                                                 constant  TransactionCount : in natural
    2894                                               ) return string is
    2895                                               begin
    2896                                                 if Operation = MULTIPLE_DRIVER_DETECT then
    2897                                                   return "Multiple Drivers on Transaction Record." & 
    2898            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2899                                                 else
    2900                                                   return "Unimplemented Transaction: " & to_string(Operation) & 
    2901            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2902                                                 end if ; 
    2903                                               end function ClassifyUnimplementedOperation ;
    2904                                             
    2905                                               ------------------------------------------------------------
    2906                                               function ClassifyUnimplementedOperation (
    2907                                               -----------------------------------------------------------
    2908                                                 constant  TransactionRec   : in StreamRecType 
    2909                                               ) return string is
    2910                                               begin
    2911            1                    ***0***         return ClassifyUnimplementedOperation(TransactionRec.Operation, TransactionRec.Rdy) ; 
    2912                                               end function ClassifyUnimplementedOperation ;
    2913                                             
    2914                                               ------------------------------------------------------------
    2915                                               function ClassifyUnimplementedTransmitterOperation (
    2916                                               -----------------------------------------------------------
    2917                                                 constant  Operation        : in StreamOperationType;
    2918                                                 constant  TransactionCount : in natural
    2919                                               ) return string is
    2920                                               begin
    2921                                                 if Operation = MULTIPLE_DRIVER_DETECT then
    2922                                                   return "Multiple Drivers on Transaction Record." & 
    2923            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2924                                                 elsif IsReceiverOperation(Operation) then
    2925                                                   return "Not a Transmitter Transaction: " & to_string(Operation) & 
    2926            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2927                                                 else
    2928                                                   return "Unimplemented Transaction: " & to_string(Operation) & 
    2929            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2930                                                 end if ; 
    2931                                               end function ClassifyUnimplementedTransmitterOperation ;
    2932                                             
    2933                                               ------------------------------------------------------------
    2934                                               function ClassifyUnimplementedTransmitterOperation (
    2935                                               -----------------------------------------------------------
    2936                                                 constant  TransactionRec   : in StreamRecType 
    2937                                               ) return string is
    2938                                               begin
    2939            1                    ***0***         return ClassifyUnimplementedTransmitterOperation(TransactionRec.Operation, TransactionRec.Rdy) ; 
    2940                                               end function ClassifyUnimplementedTransmitterOperation ;
    2941                                               
    2942                                               ------------------------------------------------------------
    2943                                               function ClassifyUnimplementedReceiverOperation (
    2944                                               -----------------------------------------------------------
    2945                                                 constant  Operation        : in StreamOperationType ;
    2946                                                 constant  TransactionCount : in natural
    2947                                               ) return string is
    2948                                               begin
    2949                                                 if Operation = MULTIPLE_DRIVER_DETECT then
    2950                                                   return "Multiple Drivers on Transaction Record." & 
    2951            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2952                                                 elsif IsTransmitterOperation(Operation) then
    2953                                                   return "Not a Receiver Transaction: " & to_string(Operation) & 
    2954            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2955                                                 else
    2956                                                   return "Unimplemented Transaction: " & to_string(Operation) & 
    2957            1                    ***0***                  "  Transaction # " & to_string(TransactionCount) ;
    2958                                                 end if ; 
    2959                                               end function ClassifyUnimplementedReceiverOperation ;
    2960                                             
    2961                                               ------------------------------------------------------------
    2962                                               function ClassifyUnimplementedReceiverOperation (
    2963                                               -----------------------------------------------------------
    2964                                                 constant  TransactionRec   : in StreamRecType 
    2965                                               ) return string is
    2966                                               begin
    2967            1                    ***0***         return ClassifyUnimplementedReceiverOperation(TransactionRec.Operation, TransactionRec.Rdy) ; 
    2968                                               end function ClassifyUnimplementedReceiverOperation ;
    2969                                             
    2970                                             end StreamTransactionPkg ;


=================================================================================
=== File: ../osvvm/osvvm/MemoryGenericPkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        90         0        90     0.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/osvvm/MemoryGenericPkg.vhd --

------------------------------------IF Branch------------------------------------
    424                                  ***0***     Count coming in to IF
    424             1                    ***0***           if ModNumItems > 0 then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    449                                  ***0***     Count coming in to IF
    449             1                    ***0***           if NewNumItems > ItemArrayPtr'length then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    474                                  ***0***     Count coming in to IF
    474             1                    ***0***           if AddrWidth <= 0 then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    478                                  ***0***     Count coming in to IF
    478             1                    ***0***           if AddrWidth >= WARNING_AT_ADDRESS_WIDTH then  
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    485                                  ***0***     Count coming in to IF
    485             1                    ***0***             if AddrWidth > ADJ_ADDR_WDITH then
    488             1                    ***0***             else 
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    494                                  ***0***     Count coming in to IF
    494             1                    ***0***           if DataWidth <= 0 then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    503                                  ***0***     Count coming in to IF
    503             1                    ***0***           if ADJ_ARRAY_OF_POINTERS_WIDTH < 31 then 
    505             1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    532                                  ***0***     Count coming in to IF
    532             1                    ***0***           if NameID /= ID_NOT_FOUND.ID then
    546             1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    533                                  ***0***     Count coming in to IF
    533             1                    ***0***             if MemStructPtr(NameID).MemArrayPtr /= NULL then 
    540             1                    ***0***             else 
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    576                                  ***0***     Count coming in to IF
    576             1                    ***0***           if ID < MIN_INDEX or ID > MemStructPtr'High then 
    589             1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    577                                  ***0***     Count coming in to IF
    577             1                    ***0***             if ID = integer'left then 
    581             1                    ***0***             else 
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    622                                  ***0***     Count coming in to IF
    622             1                    ***0***           if IdOutOfRange(ID, "MemWrite") then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    630                                  ***0***     Count coming in to IF
    630             1                    ***0***           if Addr'length > AddrWidth then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    631                                  ***0***     Count coming in to IF
    631             1                    ***0***             if (MemArrayPtr = NULL) then -- ONLY PT since if ID in range, then MemInit called
    634             1                    ***0***             elsif aAddr(aAddr'left downto AddrWidth) /= 0 then
                                         ***0***     All False Count
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------IF Branch------------------------------------
    641                                  ***0***     Count coming in to IF
    641             1                    ***0***           if Data'length /= MemStructPtr(ID).DataWidth then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    646                                  ***0***     Count coming in to IF
    646             1                    ***0***           if is_X( Addr ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    654                                  ***0***     Count coming in to IF
    654             1                    ***0***           if aAddr'high >= BlockWidth then
    656             1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    663                                  ***0***     Count coming in to IF
    663             1                    ***0***           if (MemArrayPtr(BlockAddr) = NULL) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    696                                  ***0***     Count coming in to IF
    696             1                    ***0***           if IdOutOfRange(ID, "MemRead") then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    703                                  ***0***     Count coming in to IF
    703             1                    ***0***           if Addr'length > AddrWidth then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    704                                  ***0***     Count coming in to IF
    704             1                    ***0***             if (MemStructPtr(ID).MemArrayPtr = NULL) then  -- ONLY PT since if ID in range, then MemInit called
    707             1                    ***0***             elsif aAddr(aAddr'left downto AddrWidth) /= 0 then
                                         ***0***     All False Count
Branch totals: 0 hits of 3 branches = 0.00%

------------------------------------IF Branch------------------------------------
    714                                  ***0***     Count coming in to IF
    714             1                    ***0***           if Data'length /= MemStructPtr(ID).DataWidth then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    720                                  ***0***     Count coming in to IF
    720             1                    ***0***           if is_X( aAddr ) then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    728                                  ***0***     Count coming in to IF
    728             1                    ***0***           if aAddr'high >= BlockWidth then
    730             1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    735                                  ***0***     Count coming in to IF
    735             1                    ***0***           if (MemStructPtr(ID).MemArrayPtr(BlockAddr) = NULL) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    766                                  ***0***     Count coming in to IF
    766             1                    ***0***           if IdOutOfRange(ID, "MemErase") then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    771                                  ***0***     Count coming in to IF
    771             1                    ***0***             if (MemStructPtr(ID).MemArrayPtr(BlockAddr) /= NULL) then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    781                                  ***0***     Count coming in to IF
    781             1                    ***0***           if IdOutOfRange(ID, "MemErase") then 
    783             1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    823                                  ***0***     Count coming in to IF
    823             1                    ***0***           if StartAddr'length /= ADDR_WIDTH and EndAddr'length /= ADDR_WIDTH then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    824                                  ***0***     Count coming in to IF
    824             1                    ***0***             if (MemStructPtr(ID).MemArrayPtr = NULL) then 
    826             1                    ***0***             else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    835                                  ***0***     Count coming in to IF
    835             1                    ***0***           if StartAddr <= EndAddr then 
    839             1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    856                                  ***0***     Count coming in to IF
    856             1                    ***0***               if (NextChar = '@') then 
    868             1                    ***0***               elsif DataFormat = HEX and IsHexOrStdLogic(NextChar) then 
    878             1                    ***0***               elsif DataFormat = BINARY and isstd_logic(NextChar) then 
    890             1                    ***0***               else
Branch totals: 0 hits of 4 branches = 0.00%

------------------------------------IF Branch------------------------------------
    891                                  ***0***     Count coming in to IF
    891             1                    ***0***                 if NextChar = LF or NextChar = CR then 
    894             1                    ***0***                 else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1031                                 ***0***     Count coming in to IF
    1031            1                    ***0***           if StartAddr'length /= ADDR_WIDTH and EndAddr'length /= ADDR_WIDTH then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1033                                 ***0***     Count coming in to IF
    1033            1                    ***0***             if (MemStructPtr(ID).MemArrayPtr = NULL) then 
    1035            1                    ***0***             else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1046                                 ***0***     Count coming in to IF
    1046            1                    ***0***           if StartAddr > EndAddr then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1054                                 ***0***     Count coming in to IF
    1054            1                    ***0***           if ADDR_WIDTH >= BLOCK_WIDTH then
    1057            1                    ***0***           else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1064                                 ***0***     Count coming in to IF
    1064            1                    ***0***             if BlockAddr = StartBlockAddr then 
    1066            1                    ***0***             else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1069                                 ***0***     Count coming in to IF
    1069            1                    ***0***             if BlockAddr = EndBlockAddr then 
    1071            1                    ***0***             else 
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1077                                 ***0***     Count coming in to IF
    1077            1                    ***0***               if MetaMatch(Data, AllU) then 
    1079            1                    ***0***               else 
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1080                                 ***0***     Count coming in to IF
    1080            1                    ***0***                 if not FoundData then
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1088                                 ***0***     Count coming in to IF
    1088            1                    ***0***               if FoundData then  -- Write Data
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    1089                                 ***0***     Count coming in to IF
    1089            1                    ***0***                 if DataFormat = HEX then
    1092            1                    ***0***                 else
Branch totals: 0 hits of 2 branches = 0.00%


Condition Coverage:
    Enabled Coverage              Bins   Covered    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Conditions                      12         0        12     0.00%

================================Condition Details================================

Condition Coverage for file ../osvvm/osvvm/MemoryGenericPkg.vhd --

----------------Focused Condition View-------------------
Line       576 Item    1  ((ID < MIN_INDEX) or (ID > this__MemoryPType.MemStructPtr'HIGH))
Condition totals: 0 of 2 input terms covered = 0.00%

                                  Input Term   Covered  Reason for no coverage   Hint
                                 -----------  --------  -----------------------  --------------
                            (ID < MIN_INDEX)         N  No hits                  Hit '_0' and '_1'
  (ID > this__MemoryPType.MemStructPtr'HIGH)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                                    Non-masking condition(s)      
 ---------  ---------  --------------------                          -------------------------     
  Row   1:    ***0***  (ID < MIN_INDEX)_0                            not (ID > this__MemoryPType.MemStructPtr'HIGH)
  Row   2:    ***0***  (ID < MIN_INDEX)_1                            -                             
  Row   3:    ***0***  (ID > this__MemoryPType.MemStructPtr'HIGH)_0  not (ID < MIN_INDEX)          
  Row   4:    ***0***  (ID > this__MemoryPType.MemStructPtr'HIGH)_1  not (ID < MIN_INDEX)          

----------------Focused Condition View-------------------
Line       823 Item    1  ((StartAddr'LENGTH /= ADDR_WIDTH) and (EndAddr'LENGTH /= ADDR_WIDTH))
Condition totals: 0 of 2 input terms covered = 0.00%

                        Input Term   Covered  Reason for no coverage   Hint
                       -----------  --------  -----------------------  --------------
  (StartAddr'LENGTH /= ADDR_WIDTH)         N  No hits                  Hit '_0' and '_1'
    (EndAddr'LENGTH /= ADDR_WIDTH)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                          Non-masking condition(s)      
 ---------  ---------  --------------------                -------------------------     
  Row   1:    ***0***  (StartAddr'LENGTH /= ADDR_WIDTH)_0  -                             
  Row   2:    ***0***  (StartAddr'LENGTH /= ADDR_WIDTH)_1  (EndAddr'LENGTH /= ADDR_WIDTH)
  Row   3:    ***0***  (EndAddr'LENGTH /= ADDR_WIDTH)_0    (StartAddr'LENGTH /= ADDR_WIDTH)
  Row   4:    ***0***  (EndAddr'LENGTH /= ADDR_WIDTH)_1    (StartAddr'LENGTH /= ADDR_WIDTH)

----------------Focused Condition View-------------------
Line       868 Item    1  ((DataFormat = HEX) and IsHexOrStdLogic(NextChar))
Condition totals: 0 of 2 input terms covered = 0.00%

                 Input Term   Covered  Reason for no coverage   Hint
                -----------  --------  -----------------------  --------------
         (DataFormat = HEX)         N  No hits                  Hit '_0' and '_1'
  IsHexOrStdLogic(NextChar)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                   Non-masking condition(s)      
 ---------  ---------  --------------------         -------------------------     
  Row   1:    ***0***  (DataFormat = HEX)_0         -                             
  Row   2:    ***0***  (DataFormat = HEX)_1         IsHexOrStdLogic(NextChar)     
  Row   3:    ***0***  IsHexOrStdLogic(NextChar)_0  (DataFormat = HEX)            
  Row   4:    ***0***  IsHexOrStdLogic(NextChar)_1  (DataFormat = HEX)            

----------------Focused Condition View-------------------
Line       878 Item    1  ((DataFormat = BINARY) and isstd_logic(NextChar))
Condition totals: 0 of 2 input terms covered = 0.00%

             Input Term   Covered  Reason for no coverage   Hint
            -----------  --------  -----------------------  --------------
  (DataFormat = BINARY)         N  No hits                  Hit '_0' and '_1'
  isstd_logic(NextChar)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target               Non-masking condition(s)      
 ---------  ---------  --------------------     -------------------------     
  Row   1:    ***0***  (DataFormat = BINARY)_0  -                             
  Row   2:    ***0***  (DataFormat = BINARY)_1  isstd_logic(NextChar)         
  Row   3:    ***0***  isstd_logic(NextChar)_0  (DataFormat = BINARY)         
  Row   4:    ***0***  isstd_logic(NextChar)_1  (DataFormat = BINARY)         

----------------Focused Condition View-------------------
Line       891 Item    1  ((NextChar = LF) or (NextChar = CR))
Condition totals: 0 of 2 input terms covered = 0.00%

       Input Term   Covered  Reason for no coverage   Hint
      -----------  --------  -----------------------  --------------
  (NextChar = LF)         N  No hits                  Hit '_0' and '_1'
  (NextChar = CR)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target            Non-masking condition(s)      
 ---------  ---------  --------------------  -------------------------     
  Row   1:    ***0***  (NextChar = LF)_0     not (NextChar = CR)           
  Row   2:    ***0***  (NextChar = LF)_1     -                             
  Row   3:    ***0***  (NextChar = CR)_0     not (NextChar = LF)           
  Row   4:    ***0***  (NextChar = CR)_1     not (NextChar = LF)           

----------------Focused Condition View-------------------
Line       1031 Item    1  ((StartAddr'LENGTH /= ADDR_WIDTH) and (EndAddr'LENGTH /= ADDR_WIDTH))
Condition totals: 0 of 2 input terms covered = 0.00%

                        Input Term   Covered  Reason for no coverage   Hint
                       -----------  --------  -----------------------  --------------
  (StartAddr'LENGTH /= ADDR_WIDTH)         N  No hits                  Hit '_0' and '_1'
    (EndAddr'LENGTH /= ADDR_WIDTH)         N  No hits                  Hit '_0' and '_1'

     Rows:       Hits  FEC Target                          Non-masking condition(s)      
 ---------  ---------  --------------------                -------------------------     
  Row   1:    ***0***  (StartAddr'LENGTH /= ADDR_WIDTH)_0  -                             
  Row   2:    ***0***  (StartAddr'LENGTH /= ADDR_WIDTH)_1  (EndAddr'LENGTH /= ADDR_WIDTH)
  Row   3:    ***0***  (EndAddr'LENGTH /= ADDR_WIDTH)_0    (StartAddr'LENGTH /= ADDR_WIDTH)
  Row   4:    ***0***  (EndAddr'LENGTH /= ADDR_WIDTH)_1    (StartAddr'LENGTH /= ADDR_WIDTH)


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                     240         7       233     2.91%

================================Statement Details================================

Statement Coverage for file ../osvvm/osvvm/MemoryGenericPkg.vhd --

    1                                                --
    2                                                --  File Name:         MemoryGenericPkg.vhd
    3                                                --  Design Unit Name:  MemoryGenericPkg
    4                                                --  Revision:          STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com 
    7                                                --  Contributor(s):            
    8                                                --     Jim Lewis      email:  jim@synthworks.com   
    9                                                --
    10                                               --  Description
    11                                               --      Package defines a protected type, MemoryPType, and methods  
    12                                               --      for efficiently implementing memory data structures
    13                                               --    
    14                                               --  Developed for: 
    15                                               --        SynthWorks Design Inc. 
    16                                               --        VHDL Training Classes
    17                                               --        11898 SW 128th Ave.  Tigard, Or  97223
    18                                               --        http://www.SynthWorks.com
    19                                               --
    20                                               --  Revision History:
    21                                               --    Date      Version    Description
    22                                               --    09/2024   2024.09    Updated reporting for integer'high and integer'low
    23                                               --    07/2024   2024.07    Throw Errors on Address > 41 and warnings if Address > 38
    24                                               --                         Added IsInitialized
    25                                               --    01/2023   2023.01    Updated address checks in MemRead and MemWrite
    26                                               --    11/2022   2022.11    Updated default search to PRIVATE_NAME
    27                                               --    08/2022   2022.08    Refactored and added generics for base type
    28                                               --    02/2022   2022.02    Updated NewID with ReportMode, Search, PrintParent.   Supports searching for Memory models.
    29                                               --    06/2021   2021.06    Updated Data Structure, IDs for new use model, and Wrapper Subprograms
    30                                               --    01/2020   2020.01    Updated Licenses to Apache
    31                                               --    11/2016   2016.11    Refinement to MemRead to return value, X (if X), U (if not initialized)
    32                                               --    01/2016   2016.01    Update for buf.all(buf'left)
    33                                               --    06/2015   2015.06    Updated for Alerts, ...
    34                                               --    ...       ...        Numerous revisions for VHDL Testbenches and Verification
    35                                               --    05/2005   0.1        Initial revision
    36                                               --
    37                                               --
    38                                               --  This file is part of OSVVM.
    39                                               --  
    40                                               --  Copyright (c) 2005 - 2022 by SynthWorks Design Inc.  
    41                                               --  
    42                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    43                                               --  you may not use this file except in compliance with the License.
    44                                               --  You may obtain a copy of the License at
    45                                               --  
    46                                               --      https://www.apache.org/licenses/LICENSE-2.0
    47                                               --  
    48                                               --  Unless required by applicable law or agreed to in writing, software
    49                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    50                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    51                                               --  See the License for the specific language governing permissions and
    52                                               --  limitations under the License.
    53                                               --  
    54                                               
    55                                               use std.textio.all ;
    56                                               library IEEE ; 
    57                                                 use IEEE.std_logic_1164.all ; 
    58                                                 use IEEE.numeric_std.all ; 
    59                                                 use IEEE.numeric_std_unsigned.all ; 
    60                                                 use IEEE.math_real.all ;
    61                                                 
    62                                                 use work.TextUtilPkg.all ;
    63                                                 use work.TranscriptPkg.all ;  
    64                                                 use work.AlertLogPkg.all ;
    65                                                 use work.NameStorePkg.all ;
    66                                                 use work.ResolutionPkg.all ; 
    67                                                 
    68                                               -- Temporary workaround for MemoryBaseType 
    69                                                 use work.MemorySupportPkg.MemoryBaseType ;
    70                                               
    71                                               package MemoryGenericPkg is
    72                                                 generic (
    73                                               --    type MemoryBaseType ;
    74                                                   function SizeMemoryBaseType(Size : integer) return integer ; -- is <> ;
    75                                                   function ToMemoryBaseType  (A : std_logic_vector ; Size : integer) return MemoryBaseType ; -- is <> ;
    76                                                   function FromMemoryBaseType(A : MemoryBaseType   ; Size : integer) return std_logic_vector ; -- is <> ;
    77                                                   function InitMemoryBaseType(Size : integer) return MemoryBaseType -- is <> 
    78                                                 ) ;
    79                                                 
    80                                                 type MemoryIDType is record
    81                                                   ID : integer_max ;
    82                                                 end record MemoryIDType ; 
    83                                                 
    84                                                 constant MEMORY_ID_UNINITIALZED : MemoryIdType := (ID => integer'left) ; 
    85                                               
    86                                                 type MemoryIDArrayType is array (integer range <>) of MemoryIDType ;
    87                                               
    88                                                 constant OSVVM_MEMORY_ALERTLOG_ID : AlertLogIDType := OSVVM_ALERTLOG_ID ;
    89                                                 ------------------------------------------------------------
    90                                                 impure function NewID (
    91                                                   Name                : String ; 
    92                                                   AddrWidth           : integer ; 
    93                                                   DataWidth           : integer ; 
    94                                                   ParentID            : AlertLogIDType          := OSVVM_MEMORY_ALERTLOG_ID ;
    95                                                   ReportMode          : AlertLogReportModeType  := ENABLED ; 
    96                                                   Search              : NameSearchType          := PRIVATE_NAME ;
    97                                                   PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT
    98                                                 ) return MemoryIDType ;
    99                                               
    100                                                impure function IsInitialized (ID : MemoryIDType) return boolean ;
    101                                              
    102                                                ------------------------------------------------------------
    103                                                procedure MemWrite ( 
    104                                                  ID    : MemoryIDType ; 
    105                                                  Addr  : std_logic_vector ;
    106                                                  Data  : std_logic_vector 
    107                                                ) ; 
    108                                                alias Write is MemWrite [MemoryIDType, std_logic_vector, std_logic_vector ] ; 
    109                                                
    110                                                procedure MemRead (  
    111                                                  ID    : in MemoryIDType ;
    112                                                  Addr  : in  std_logic_vector ;
    113                                                  Data  : out std_logic_vector 
    114                                                ) ; 
    115                                                alias Read is MemRead [MemoryIDType, std_logic_vector, std_logic_vector ] ; 
    116                                                
    117                                                impure function MemRead ( 
    118                                                  ID    : MemoryIDType ; 
    119                                                  Addr  : std_logic_vector 
    120                                                ) return std_logic_vector ; 
    121                                                alias Read is MemRead [MemoryIDType, std_logic_vector return std_logic_vector ] ; 
    122                                              
    123                                                ------------------------------------------------------------
    124                                                procedure MemErase (ID : in MemoryIDType); 
    125                                                procedure deallocate (ID : in MemoryIDType) ;
    126                                                procedure MemoryPkgDeallocate ;
    127                                                
    128                                                ------------------------------------------------------------
    129                                                impure function GetAlertLogID (ID : in MemoryIDType) return AlertLogIDType ;
    130                                                
    131                                                ------------------------------------------------------------
    132                                                procedure FileReadH (    -- Hexadecimal File Read 
    133                                                  ID           : MemoryIDType ;
    134                                                  FileName     : string ; 
    135                                                  StartAddr    : std_logic_vector ; 
    136                                                  EndAddr      : std_logic_vector
    137                                                ) ;
    138                                                procedure FileReadH (
    139                                                  ID           : MemoryIDType ;
    140                                                  FileName     : string ;  
    141                                                  StartAddr    : std_logic_vector
    142                                                ) ;
    143                                                procedure FileReadH (
    144                                                  ID           : MemoryIDType ;
    145                                                  FileName     : string 
    146                                                ) ;
    147                                              
    148                                                ------------------------------------------------------------
    149                                                procedure FileReadB (    -- Binary File Read 
    150                                                  ID           : MemoryIDType ;
    151                                                  FileName     : string ; 
    152                                                  StartAddr    : std_logic_vector ; 
    153                                                  EndAddr      : std_logic_vector
    154                                                ) ;
    155                                                procedure FileReadB (
    156                                                  ID           : MemoryIDType ;
    157                                                  FileName     : string ;  
    158                                                  StartAddr    : std_logic_vector
    159                                                ) ;
    160                                                procedure FileReadB (
    161                                                  ID           : MemoryIDType ;
    162                                                  FileName     : string 
    163                                                ) ;
    164                                              
    165                                                ------------------------------------------------------------
    166                                                procedure FileWriteH (    -- Hexadecimal File Write 
    167                                                  ID           : MemoryIDType ;
    168                                                  FileName     : string ; 
    169                                                  StartAddr    : std_logic_vector ; 
    170                                                  EndAddr      : std_logic_vector
    171                                                ) ;
    172                                                procedure FileWriteH (
    173                                                  ID           : MemoryIDType ;
    174                                                  FileName     : string ;  
    175                                                  StartAddr    : std_logic_vector
    176                                                ) ;
    177                                                procedure FileWriteH (
    178                                                  ID           : MemoryIDType ;
    179                                                  FileName     : string 
    180                                                ) ;
    181                                              
    182                                                ------------------------------------------------------------
    183                                                procedure FileWriteB (    -- Binary File Write 
    184                                                  ID           : MemoryIDType ;
    185                                                  FileName     : string ; 
    186                                                  StartAddr    : std_logic_vector ; 
    187                                                  EndAddr      : std_logic_vector
    188                                                ) ;
    189                                                procedure FileWriteB (
    190                                                  ID           : MemoryIDType ;
    191                                                  FileName     : string ;  
    192                                                  StartAddr    : std_logic_vector
    193                                                ) ;
    194                                                procedure FileWriteB (
    195                                                  ID           : MemoryIDType ;
    196                                                  FileName     : string 
    197                                                ) ;
    198                                              
    199                                                type MemoryPType is protected 
    200                                                
    201                                                  ------------------------------------------------------------
    202                                                  impure function NewID (
    203                                                    Name                : String ; 
    204                                                    AddrWidth           : integer ; 
    205                                                    DataWidth           : integer ; 
    206                                                    ParentID            : AlertLogIDType          := OSVVM_MEMORY_ALERTLOG_ID ;
    207                                                    ReportMode          : AlertLogReportModeType  := ENABLED ; 
    208                                                    Search              : NameSearchType          := PRIVATE_NAME ;
    209                                                    PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT
    210                                                  ) return integer ;
    211                                              
    212                                                  impure function IsInitialized (ID : MemoryIDType) return boolean ;
    213                                              
    214                                                  ------------------------------------------------------------
    215                                                  procedure MemWrite ( 
    216                                                    ID    : integer ; 
    217                                                    Addr  : std_logic_vector ;
    218                                                    Data  : std_logic_vector 
    219                                                  ) ; 
    220                                                  procedure MemRead (  
    221                                                    ID    : in integer ;
    222                                                    Addr  : in  std_logic_vector ;
    223                                                    Data  : out std_logic_vector 
    224                                                  ) ; 
    225                                                  impure function MemRead ( 
    226                                                    ID    : integer ; 
    227                                                    Addr  : std_logic_vector 
    228                                                  ) return std_logic_vector ; 
    229                                              
    230                                                  ------------------------------------------------------------
    231                                                  procedure MemErase (ID : integer) ; 
    232                                                  
    233                                                  impure function GetAlertLogID (ID : integer) return AlertLogIDType ;
    234                                                  
    235                                                  ------------------------------------------------------------
    236                                                  procedure FileReadH (    -- Hexadecimal File Read 
    237                                                    ID           : integer ;
    238                                                    FileName     : string ; 
    239                                                    StartAddr    : std_logic_vector ; 
    240                                                    EndAddr      : std_logic_vector
    241                                                  ) ;
    242                                                  procedure FileReadH (
    243                                                    ID           : integer ;
    244                                                    FileName     : string ;  
    245                                                    StartAddr    : std_logic_vector
    246                                                  ) ;
    247                                                  procedure FileReadH (
    248                                                    ID           : integer ;
    249                                                    FileName     : string 
    250                                                  ) ;
    251                                              
    252                                                  ------------------------------------------------------------
    253                                                  procedure FileReadB (    -- Binary File Read 
    254                                                    ID           : integer ;
    255                                                    FileName     : string ; 
    256                                                    StartAddr    : std_logic_vector ; 
    257                                                    EndAddr      : std_logic_vector
    258                                                  ) ;
    259                                                  procedure FileReadB (
    260                                                    ID           : integer ;
    261                                                    FileName     : string ;  
    262                                                    StartAddr    : std_logic_vector
    263                                                  ) ;
    264                                                  procedure FileReadB (
    265                                                    ID           : integer ;
    266                                                    FileName     : string 
    267                                                  ) ;
    268                                              
    269                                                  ------------------------------------------------------------
    270                                                  procedure FileWriteH (    -- Hexadecimal File Write 
    271                                                    ID           : integer ;
    272                                                    FileName     : string ; 
    273                                                    StartAddr    : std_logic_vector ; 
    274                                                    EndAddr      : std_logic_vector
    275                                                  ) ;
    276                                                  procedure FileWriteH (
    277                                                    ID           : integer ;
    278                                                    FileName     : string ;  
    279                                                    StartAddr    : std_logic_vector
    280                                                  ) ;
    281                                                  procedure FileWriteH (
    282                                                    ID           : integer ;
    283                                                    FileName     : string 
    284                                                  ) ;
    285                                              
    286                                                  ------------------------------------------------------------
    287                                                  procedure FileWriteB (    -- Binary File Write 
    288                                                    ID           : integer ;
    289                                                    FileName     : string ; 
    290                                                    StartAddr    : std_logic_vector ; 
    291                                                    EndAddr      : std_logic_vector
    292                                                  ) ;
    293                                                  procedure FileWriteB (
    294                                                    ID           : integer ;
    295                                                    FileName     : string ;  
    296                                                    StartAddr    : std_logic_vector
    297                                                  ) ;
    298                                                  procedure FileWriteB (
    299                                                    ID           : integer ;
    300                                                    FileName     : string 
    301                                                  ) ;
    302                                              
    303                                                  ------------------------------------------------------------
    304                                                  -- Destroys the entire data structure
    305                                                  -- Usage:  At the end of the simulation to remove all 
    306                                                  -- memory used by data structure.  
    307                                                  -- Note, a normal simulator does this for you.  
    308                                                  -- You only need this if the simulator is broken.
    309                                                  procedure deallocate (ID : integer) ; 
    310                                                  procedure deallocate ; 
    311                                              
    312                                                  ------------------------------------------------------------
    313                                                  -- /////////////////////////////////////////
    314                                                  -- Historical Interface
    315                                                  --   In the new implementation, these use index 1. 
    316                                                  --   These are for backward compatibility support
    317                                                  -- 
    318                                                  -- /////////////////////////////////////////
    319                                                  ------------------------------------------------------------
    320                                                  procedure MemInit ( AddrWidth, DataWidth  : in  integer ) ;
    321                                                  
    322                                                  ------------------------------------------------------------
    323                                                  procedure MemWrite ( Addr, Data  : in  std_logic_vector ) ; 
    324                                              
    325                                                  ------------------------------------------------------------
    326                                                  procedure MemRead (  
    327                                                    Addr  : in  std_logic_vector ;
    328                                                    Data  : out std_logic_vector 
    329                                                  ) ; 
    330                                                  impure function MemRead ( Addr  : std_logic_vector ) return std_logic_vector ; 
    331                                              
    332                                                  ------------------------------------------------------------
    333                                                  procedure MemErase ; 
    334                                                  
    335                                                  ------------------------------------------------------------
    336                                                  procedure SetAlertLogID (A : AlertLogIDType) ;
    337                                                  procedure SetAlertLogID (Name : string ; ParentID : AlertLogIDType := OSVVM_MEMORY_ALERTLOG_ID ; CreateHierarchy : Boolean := TRUE) ;    
    338                                                  impure function GetAlertLogID return AlertLogIDType ;
    339                                                  
    340                                                  ------------------------------------------------------------
    341                                                  procedure FileReadH (    -- Hexadecimal File Read 
    342                                                    FileName     : string ; 
    343                                                    StartAddr    : std_logic_vector ; 
    344                                                    EndAddr      : std_logic_vector
    345                                                  ) ;
    346                                                  procedure FileReadH (FileName : string ;  StartAddr : std_logic_vector) ;
    347                                                  procedure FileReadH (FileName : string) ; 
    348                                              
    349                                                  ------------------------------------------------------------
    350                                                  procedure FileReadB (    -- Binary File Read 
    351                                                    FileName     : string ; 
    352                                                    StartAddr    : std_logic_vector ; 
    353                                                    EndAddr      : std_logic_vector
    354                                                  ) ;
    355                                                  procedure FileReadB (FileName : string ;  StartAddr : std_logic_vector) ;
    356                                                  procedure FileReadB (FileName : string) ; 
    357                                              
    358                                                  ------------------------------------------------------------
    359                                                  procedure FileWriteH (    -- Hexadecimal File Write 
    360                                                    FileName     : string ; 
    361                                                    StartAddr    : std_logic_vector ; 
    362                                                    EndAddr      : std_logic_vector
    363                                                  ) ;
    364                                                  procedure FileWriteH (FileName : string ;  StartAddr : std_logic_vector) ;
    365                                                  procedure FileWriteH (FileName : string) ; 
    366                                              
    367                                                  ------------------------------------------------------------
    368                                                  procedure FileWriteB (    -- Binary File Write 
    369                                                    FileName     : string ; 
    370                                                    StartAddr    : std_logic_vector ; 
    371                                                    EndAddr      : std_logic_vector
    372                                                  ) ;
    373                                                  procedure FileWriteB (FileName : string ;  StartAddr : std_logic_vector) ;
    374                                                  procedure FileWriteB (FileName : string) ;    
    375                                              
    376                                                end protected MemoryPType ;
    377                                              
    378                                              end MemoryGenericPkg ;
    379                                              
    380                                              package body MemoryGenericPkg is 
    381                                                constant BLOCK_WIDTH : integer := 10 ; 
    382                                                constant WARNING_AT_ADDRESS_WIDTH : integer := BLOCK_WIDTH + 24 ; -- 16 M Byte array of pointers
    383                                                constant MAXIMUM_ADDRESS_WIDTH    : integer := BLOCK_WIDTH + 30 ; -- 1 G Byte Array of pointers - Maximum size supported by type integer
    384                                              
    385                                                type MemoryPType is protected body
    386                                              
    387                                                  type MemBlockType      is array (integer range <>) of MemoryBaseType ;
    388                                                  type MemBlockPtrType   is access MemBlockType ;
    389                                                  type MemArrayType      is array (integer range <>) of MemBlockPtrType ;
    390                                                  type MemArrayPtrType   is access MemArrayType ; 
    391                                                  
    392                                                  type FileFormatType is (BINARY, HEX) ; 
    393                                                      
    394                                                  type MemStructType is record
    395                                                    MemArrayPtr         : MemArrayPtrType ; 
    396                                                    AddrWidth           : integer ;
    397                                                    DataWidth           : natural ;
    398                                                    BlockWidth          : natural ; 
    399                                                    MemoryBaseTypeWidth : natural ; 
    400                                                    AlertLogID          : AlertLogIDType ; 
    401                                                  end record MemStructType ; 
    402                                                  
    403                                                  -- New Structure
    404                                                  type     ItemArrayType    is array (integer range <>) of MemStructType ; 
    405                                                  type     ItemArrayPtrType is access ItemArrayType ;
    406                                                  
    407             1                          1         variable Template         : ItemArrayType(1 to 1) := (1 => (NULL, -1, 1, 0, 0, OSVVM_MEMORY_ALERTLOG_ID)) ;  -- Work around for QS 2020.04 and 2021.02
    408             1                          1         variable MemStructPtr     : ItemArrayPtrType := new ItemArrayType'(Template) ;   
    409             1                          1         constant MIN_INDEX        : integer := 1 ;
    410             1                          1         constant PT_ID            : integer := MIN_INDEX ; 
    411             1                          1         variable NumItems         : integer := 0 ; 
    412                                              --    constant NUM_ITEMS_TO_ALLOCATE    : integer := 4 ; -- Temporarily small for testing
    413             1                          1         constant NUM_ITEMS_TO_ALLOCATE    : integer := 32 ; -- Min amount to resize array
    414             1                          1         variable LocalNameStore   : NameStorePType ; 
    415                                                  
    416                                                  ------------------------------------------------------------
    417                                                  -- Package Local
    418                                                  function NormalizeArraySize( NewNumItems, MinNumItems : integer ) return integer is
    419                                                  ------------------------------------------------------------
    420                                                    variable NormNumItems : integer := NewNumItems ;
    421                                                    variable ModNumItems  : integer := 0;
    422                                                  begin
    423             1                    ***0***           ModNumItems := NewNumItems mod MinNumItems ; 
    424                                                    if ModNumItems > 0 then 
    425             1                    ***0***             NormNumItems := NormNumItems + (MinNumItems - ModNumItems) ; 
    426                                                    end if ; 
    427             1                    ***0***           return NormNumItems ; 
    428                                                  end function NormalizeArraySize ;
    429                                              
    430                                                  ------------------------------------------------------------
    431                                                  -- Package Local
    432                                                  procedure GrowNumberItems (
    433                                                  ------------------------------------------------------------
    434                                                    variable ItemArrayPtr     : InOut ItemArrayPtrType ;
    435                                                    variable NumItems         : InOut integer ;
    436                                                    constant GrowAmount       : in integer ;
    437                                              --      constant NewNumItems      : in integer ;
    438                                              --      constant CurNumItems      : in integer ;
    439                                                    constant MinNumItems      : in integer 
    440                                                  ) is
    441                                                    variable oldItemArrayPtr  : ItemArrayPtrType ;
    442                                                    variable NewNumItems : integer ;
    443                                                  begin
    444             1                    ***0***           NewNumItems := NumItems + GrowAmount ;
    445                                                    -- Array Allocated in declaration to have a single item, but no items (historical mode)
    446                                                    -- if ItemArrayPtr = NULL then
    447                                                    --  ItemArrayPtr := new ItemArrayType(1 to NormalizeArraySize(NewNumItems, MinNumItems)) ;
    448                                                    -- elsif NewNumItems > ItemArrayPtr'length then
    449                                                    if NewNumItems > ItemArrayPtr'length then
    450             1                    ***0***             oldItemArrayPtr := ItemArrayPtr ;
    451             1                    ***0***             ItemArrayPtr := new ItemArrayType(1 to NormalizeArraySize(NewNumItems, MinNumItems)) ;
    452             1                    ***0***             ItemArrayPtr.all(1 to NumItems) := ItemArrayType'(oldItemArrayPtr.all(1 to NumItems)) ;
    453             1                    ***0***             deallocate(oldItemArrayPtr) ;
    454                                                    end if ;
    455             1                    ***0***           NumItems := NewNumItems ; 
    456                                                  end procedure GrowNumberItems ;  
    457                                                  
    458                                                 ------------------------------------------------------------
    459                                                  -- PT Local 
    460                                                  function MaximumAddressWidth (AddrWidth : integer) return integer is
    461                                                  ------------------------------------------------------------
    462                                                  begin
    463             1                    ***0***           return minimum(AddrWidth, MAXIMUM_ADDRESS_WIDTH) ;
    464                                                  end function MaximumAddressWidth ; 
    465                                              
    466                                                 ------------------------------------------------------------
    467                                                  -- PT Local 
    468                                                  procedure MemInit (ID : integer ;  AddrWidth, DataWidth  : integer ) is
    469                                                  ------------------------------------------------------------
    470                                                    constant ADJ_BLOCK_WIDTH             : integer := minimum(BLOCK_WIDTH, AddrWidth) ;
    471                                                    constant ADJ_ADDR_WDITH              : integer := MaximumAddressWidth(AddrWidth) ; 
    472                                                    constant ADJ_ARRAY_OF_POINTERS_WIDTH : integer := ADJ_ADDR_WDITH - ADJ_BLOCK_WIDTH ; 
    473                                                  begin
    474                                                    if AddrWidth <= 0 then 
    475             1                    ***0***             Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemInit/NewID.  AddrWidth = " & to_string(AddrWidth) & " must be > 0.", FAILURE) ; 
    476             1                    ***0***             return ; 
    477                                                    end if ; 
    478                                                    if AddrWidth >= WARNING_AT_ADDRESS_WIDTH then  
    479                                                      -- Array of pointers > 64 M words
    480             1                    ***0***             log(MemStructPtr(ID).AlertLogID, "MemoryPkg.NewID(MemInit):  Requested AddrWidth = " & to_string(AddrWidth) & ".") ; 
    481             1                    ***0***             log(MemStructPtr(ID).AlertLogID, "MemoryPkg.NewID(MemInit):  Internally this creates an array sized 2**" & to_string(ADJ_ARRAY_OF_POINTERS_WIDTH) & ".") ; 
    482             1                    ***0***             log(MemStructPtr(ID).AlertLogID, "MemoryPkg.NewID(MemInit):  Memories this large may result in poor simulation performance.") ; 
    483             1                    ***0***             log(MemStructPtr(ID).AlertLogID, "MemoryPkg.NewID(MemInit):  If you need a memory this large, be sure to file an issue on GitHub/OSVVM/OsvvmLibraries or osvvm.org.") ; 
    484                                              
    485                                                      if AddrWidth > ADJ_ADDR_WDITH then
    486                                                        Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.NewID(MemInit):  Requested AddrWidth = " & to_string(AddrWidth) & 
    487             1                    ***0***                                                  " was truncated to " & to_string(ADJ_ADDR_WDITH) & ".", ERROR) ; 
    488                                                      else 
    489             1                    ***0***               Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.NewID(MemInit):  Requested AddrWidth = " & to_string(AddrWidth) & " is large and may slow simulation.", WARNING) ; 
    490                                                      end if ; 
    491                                                    end if ; 
    492                                              --      if DataWidth <= 0 or DataWidth > 31 then 
    493                                              --        Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemInit/NewID.  DataWidth = " & to_string(DataWidth) & " must be > 0 and <= 31.", FAILURE) ; 
    494                                                    if DataWidth <= 0 then 
    495             1                    ***0***             Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemInit/NewID.  DataWidth = " & to_string(DataWidth) & " must be > 0 ", FAILURE) ; 
    496             1                    ***0***             return ; 
    497                                                    end if ; 
    498                                              
    499             1                    ***0***           MemStructPtr(ID).AddrWidth           := ADJ_ADDR_WDITH ; 
    500             1                    ***0***           MemStructPtr(ID).DataWidth           := DataWidth ; 
    501             1                    ***0***           MemStructPtr(ID).MemoryBaseTypeWidth := SizeMemoryBaseType(DataWidth) ; 
    502             1                    ***0***           MemStructPtr(ID).BlockWidth          := ADJ_BLOCK_WIDTH ;
    503                                                    if ADJ_ARRAY_OF_POINTERS_WIDTH < 31 then 
    504             1                    ***0***             MemStructPtr(ID).MemArrayPtr         := new MemArrayType(0 to 2**(ADJ_ARRAY_OF_POINTERS_WIDTH)-1) ;  
    505                                                    else
    506                                                      -- with 32 bit signed numbers, formulating 2**31-1 can be interesting.
    507             1                    ***0***             MemStructPtr(ID).MemArrayPtr         := new MemArrayType(0 to (2**30-1) + 2**30) ; 
    508                                                    end if ; 
    509                                                  end procedure MemInit ;
    510                                                  
    511                                                  ------------------------------------------------------------
    512                                                  impure function NewID (
    513                                                  ------------------------------------------------------------
    514                                                    Name                : String ; 
    515                                                    AddrWidth           : integer ; 
    516                                                    DataWidth           : integer ; 
    517                                                    ParentID            : AlertLogIDType          := OSVVM_MEMORY_ALERTLOG_ID ;
    518                                                    ReportMode          : AlertLogReportModeType  := ENABLED ; 
    519                                                    Search              : NameSearchType          := PRIVATE_NAME ;
    520                                                    PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT
    521                                                  ) return integer is 
    522                                                    variable NameID              : integer ; 
    523                                                    variable ResolvedSearch      : NameSearchType ; 
    524                                                    variable ResolvedPrintParent : AlertLogPrintParentType ; 
    525                                                  begin
    526             1                    ***0***           ResolvedSearch      := ResolveSearch     (ParentID /= OSVVM_MEMORY_ALERTLOG_ID, Search) ; 
    527             1                    ***0***           ResolvedPrintParent := ResolvePrintParent(ParentID /= OSVVM_MEMORY_ALERTLOG_ID, PrintParent) ; 
    528                                                    
    529             1                    ***0***           NameID := LocalNameStore.find(Name, ParentID, ResolvedSearch) ; 
    530                                              
    531                                                    -- Share the memory if they match
    532                                                    if NameID /= ID_NOT_FOUND.ID then
    533                                                      if MemStructPtr(NameID).MemArrayPtr /= NULL then 
    534                                                        -- Found ID and structure exists, does structure match?
    535                                                        AlertIf(MemStructPtr(NameID).AlertLogID, MaximumAddressWidth(AddrWidth) /= MemStructPtr(NameID).AddrWidth,  
    536             1                    ***0***                 "NewID: AddrWidth: " & to_string(MaximumAddressWidth(AddrWidth)) & " /= Existing AddrWidth: "  & to_string(MemStructPtr(NameID).AddrWidth), FAILURE);
    537                                                        AlertIf(MemStructPtr(NameID).AlertLogID, DataWidth /= MemStructPtr(NameID).DataWidth,  
    538             1                    ***0***                 "NewID: DataWidth: " & to_string(DataWidth) & " /= Existing DataWidth: "  & to_string(MemStructPtr(NameID).DataWidth), FAILURE);
    539                                                        -- NameStore IDs are issued sequentially and match MemoryID
    540                                                      else 
    541                                                        -- Found ID and structure does not exist, Reconstruct Memory
    542             1                    ***0***               MemInit(NameID, AddrWidth, DataWidth) ;
    543                                                      end if ; 
    544             1                    ***0***             return NameID ; 
    545                                                      
    546                                                    else
    547                                                      -- Add New Memory to Structure 
    548             1                    ***0***             GrowNumberItems(MemStructPtr, NumItems, GrowAmount => 1, MinNumItems => NUM_ITEMS_TO_ALLOCATE) ;
    549                                                      -- Create AlertLogID
    550             1                    ***0***             MemStructPtr(NumItems).AlertLogID := NewID(Name, ParentID, ReportMode, ResolvedPrintParent, CreateHierarchy => FALSE) ;
    551                                                      -- Construct Memory, Reports agains AlertLogID
    552             1                    ***0***             MemInit(NumItems, AddrWidth, DataWidth) ;
    553                                                      -- Add item to NameStore
    554             1                    ***0***             NameID := LocalNameStore.NewID(Name, ParentID, ResolvedSearch) ;
    555                                                      -- Check NameStore Index vs MemoryIndex
    556             1                    ***0***             AlertIfNotEqual(MemStructPtr(NumItems).AlertLogID, NameID, NumItems, "MemoryStore, Check Index of LocalNameStore matches MemoryID") ;  
    557             1                    ***0***             return NumItems ; 
    558                                                    end if ;
    559                                                  end function NewID ;
    560                                                  
    561                                                  ------------------------------------------------------------
    562                                                  impure function IsInitialized (ID : MemoryIDType) return boolean is
    563                                                  ------------------------------------------------------------
    564                                                  begin
    565             1                    ***0***           return ID /= MEMORY_ID_UNINITIALZED ;
    566                                                  end function IsInitialized ;
    567                                              
    568                                                  ------------------------------------------------------------
    569                                                  -- PT Local 
    570                                                  impure function IdOutOfRange(
    571                                                  ------------------------------------------------------------
    572                                                    constant ID    : in integer ; 
    573                                                    constant Name  : in string
    574                                                  ) return boolean is 
    575                                                  begin
    576                                                    if ID < MIN_INDEX or ID > MemStructPtr'High then 
    577                                                      if ID = integer'left then 
    578                                                        Alert(OSVVM_MEMORY_ALERTLOG_ID, "MemoryPkg." & Name & " ID not initialized yet.  " &
    579                                                          "Either a call to NewID or wait for 0 ns (to allow for signal update) is needed. ",
    580             1                    ***0***                  FAILURE ) ;
    581                                                      else 
    582                                                        Alert(OSVVM_MEMORY_ALERTLOG_ID,  
    583                                                           "MemoryPkg." & Name & " ID: " & to_string_max(ID) & 
    584                                                                 " is not in the range (" & to_string(MIN_INDEX) &
    585                                                                 " to " & to_string(MemStructPtr'High) & ")",
    586             1                    ***0***                  FAILURE ) ;
    587                                                      end if ; 
    588             1                    ***0***             return TRUE ;
    589                                                    else
    590                                                      -- valid ID
    591             1                    ***0***             return FALSE ; 
    592                                                    end if; 
    593                                                  end function IdOutOfRange ; 
    594                                              
    595                                                  ------------------------------------------------------------
    596                                                  -- Local
    597                                                  -- This is a temporary solution that works around GHDL issues
    598                                                  function InitMemoryBlockType(BlockWidth, BaseWidth : integer) return MemBlockType is  
    599                                                  ------------------------------------------------------------
    600                                              -- This keeps MemoryBaseType from being a generic type
    601                                                    constant BaseU : MemoryBaseType(BaseWidth-1 downto 0) := InitMemoryBaseType(BaseWidth) ;
    602                                              --!! GHDL Bug     constant BaseU : MemoryBaseType := InitMemoryBaseType(BaseWidth) ;
    603                                                  begin
    604             1                    ***0***           return MemBlockType'(0 to 2**BlockWidth-1 => BaseU) ;
    605                                                  end function InitMemoryBlockType ; 
    606                                              
    607                                                  ------------------------------------------------------------
    608                                                  procedure MemWrite ( 
    609                                                  ------------------------------------------------------------
    610                                                    ID    : integer ; 
    611                                                    Addr  : std_logic_vector ;
    612                                                    Data  : std_logic_vector 
    613                                                  ) is 
    614                                                    variable BlockWidth, AddrWidth : integer ;
    615                                                    variable MemoryBaseWidth : integer ;
    616                                              --      constant BlockWidth : integer := MemStructPtr(ID).BlockWidth;
    617                                                    variable BlockAddr, WordAddr  : integer ;
    618                                                    alias aAddr : std_logic_vector (Addr'length-1 downto 0) is Addr ; 
    619                                              --      subtype MemBlockSubType is MemBlockType(0 to 2**BlockWidth-1) ;
    620                                                    variable MemArrayPtr : MemArrayPtrType ; 
    621                                                  begin
    622                                                    if IdOutOfRange(ID, "MemWrite") then 
    623             1                    ***0***             return ;
    624                                                    end if ; 
    625                                                    
    626             1                    ***0***           AddrWidth   := MemStructPtr(ID).AddrWidth  ;
    627             1                    ***0***           MemArrayPtr := MemStructPtr(ID).MemArrayPtr ;
    628                                                    
    629                                                    -- Check Bounds of Address and if memory is initialized
    630                                                    if Addr'length > AddrWidth then
    631                                                      if (MemArrayPtr = NULL) then -- ONLY PT since if ID in range, then MemInit called
    632             1                    ***0***               Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemWrite:  Memory not initialized, Write Ignored.", FAILURE) ; 
    633             1                    ***0***               return ; 
    634                                                      elsif aAddr(aAddr'left downto AddrWidth) /= 0 then
    635             1                    ***0***               Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemWrite:  Address value " & to_hxstring(Addr) & " goes beyond memory address width: " & to_string(MemStructPtr(ID).AddrWidth), FAILURE) ; 
    636             1                    ***0***               return ; 
    637                                                      end if ; 
    638                                                    end if ; 
    639                                              
    640                                                    -- Check Bounds on Data
    641                                                    if Data'length /= MemStructPtr(ID).DataWidth then
    642             1                    ***0***             Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemWrite:  Data'length: " & to_string(Data'length) & " /= Memory Data Width: " & to_string(MemStructPtr(ID).DataWidth), FAILURE) ; 
    643             1                    ***0***             return ; 
    644                                                    end if ; 
    645                                              
    646                                                    if is_X( Addr ) then
    647             1                    ***0***             Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemWrite:  Address X, Write Ignored.") ; 
    648             1                    ***0***             return ;
    649                                                    end if ; 
    650                                              
    651             1                    ***0***           BlockWidth := MemStructPtr(ID).BlockWidth ; 
    652                                              
    653                                                    -- Slice out upper address to form block address
    654                                                    if aAddr'high >= BlockWidth then
    655             1                    ***0***             BlockAddr := to_integer(aAddr(aAddr'high downto BlockWidth)) ;
    656                                                    else
    657             1                    ***0***             BlockAddr  := 0 ; 
    658                                                    end if ; 
    659                                              
    660             1                    ***0***           MemoryBaseWidth := MemStructPtr(ID).MemoryBaseTypeWidth ; 
    661                                              
    662                                                    -- If empty, allocate a memory block
    663                                                    if (MemArrayPtr(BlockAddr) = NULL) then 
    664                                                      MemArrayPtr(BlockAddr) := new 
    665             1                    ***0***                 MemBlockType'(InitMemoryBlockType(BlockWidth, MemoryBaseWidth)) ;
    666                                              
    667                                              -- Long term, we need the first one to allow transition of MemoryBaseType to a generic.
    668                                              --!! GHDL Bug        MemStructPtr(ID).MemArrayPtr(BlockAddr) := new 
    669                                              --!! GHDL Bug            MemBlockType'(0 to 2**BlockWidth-1 =>  InitMemoryBaseType(MemoryBaseWidth) ) ;
    670                                              --        MemStructPtr(ID).MemArrayPtr(BlockAddr) := new 
    671                                              --          MemBlockType(0 to 2**BlockWidth-1)(MemoryBaseWidth-1 downto 0) ;
    672                                              --!! GHDL Bug        MemStructPtr(ID).MemArrayPtr(BlockAddr).all := (0 to 2**BlockWidth-1 => InitMemoryBaseType(MemoryBaseWidth));
    673                                                    end if ; 
    674                                              
    675                                                    -- Address of a word within a block
    676             1                    ***0***           WordAddr  := to_integer(aAddr(BlockWidth -1 downto 0)) ;
    677                                              
    678                                                    -- Write to BlockAddr, WordAddr
    679             1                    ***0***           MemArrayPtr(BlockAddr)(WordAddr) := ToMemoryBaseType(Data, MemoryBaseWidth) ;
    680                                                  end procedure MemWrite ; 
    681                                              
    682                                                  ------------------------------------------------------------
    683                                                  procedure MemRead (  
    684                                                  ------------------------------------------------------------
    685                                                    ID    : in integer ;
    686                                                    Addr  : in  std_logic_vector ;
    687                                                    Data  : out std_logic_vector 
    688                                                  ) is
    689                                                    variable BlockWidth, AddrWidth : integer ;
    690                                                    variable BlockAddr, WordAddr  : integer ;
    691                                                    alias aAddr : std_logic_vector (Addr'length-1 downto 0) is Addr ; 
    692                                                  begin
    693                                                  
    694             1                    ***0***           Data := (Data'range => 'U') ;  -- Error return value
    695                                              
    696                                                    if IdOutOfRange(ID, "MemRead") then 
    697             1                    ***0***             return ;
    698                                                    end if ; 
    699                                                    
    700             1                    ***0***           AddrWidth := MemStructPtr(ID).AddrWidth ;
    701                                              
    702                                                    -- Check Bounds of Address and if memory is initialized
    703                                                    if Addr'length > AddrWidth then
    704                                                      if (MemStructPtr(ID).MemArrayPtr = NULL) then  -- ONLY PT since if ID in range, then MemInit called
    705             1                    ***0***               Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemRead:  Memory not initialized. Returning U", FAILURE) ; 
    706             1                    ***0***               return ; 
    707                                                      elsif aAddr(aAddr'left downto AddrWidth) /= 0 then
    708             1                    ***0***               Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemRead:  Address value " & to_hxstring(Addr) & " goes beyond memory address width: " & to_string(MemStructPtr(ID).AddrWidth), FAILURE) ; 
    709             1                    ***0***               return ; 
    710                                                      end if ; 
    711                                                    end if ; 
    712                                                    
    713                                                    -- Check Bounds on Data
    714                                                    if Data'length /= MemStructPtr(ID).DataWidth then
    715             1                    ***0***             Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.MemRead:  Data'length: " & to_string(Data'length) & " /= Memory Data Width: " & to_string(MemStructPtr(ID).DataWidth), FAILURE) ; 
    716             1                    ***0***             return ; 
    717                                                    end if ; 
    718                                              
    719                                                    -- If Addr X, data = X
    720                                                    if is_X( aAddr ) then
    721             1                    ***0***             Data := (Data'range => 'X') ; 
    722             1                    ***0***             return ; 
    723                                                    end if ; 
    724                                              
    725             1                    ***0***           BlockWidth := MemStructPtr(ID).BlockWidth ;
    726                                              
    727                                                    -- Slice out upper address to form block address
    728                                                    if aAddr'high >= BlockWidth then
    729             1                    ***0***             BlockAddr := to_integer(aAddr(aAddr'high downto BlockWidth)) ;
    730                                                    else
    731             1                    ***0***             BlockAddr  := 0 ; 
    732                                                    end if ; 
    733                                                    
    734                                                    -- Empty Block, return all U
    735                                                    if (MemStructPtr(ID).MemArrayPtr(BlockAddr) = NULL) then 
    736             1                    ***0***             Data := (Data'range => 'U') ; 
    737             1                    ***0***             return ; 
    738                                                    end if ; 
    739                                              
    740                                                    -- Address of a word within a block
    741             1                    ***0***           WordAddr := to_integer(aAddr(BlockWidth -1 downto 0)) ;
    742                                                    
    743             1                    ***0***           Data := FromMemoryBaseType(MemStructPtr(ID).MemArrayPtr(BlockAddr)(WordAddr), Data'length) ; 
    744                                              
    745                                                  end procedure MemRead ; 
    746                                              
    747                                                  ------------------------------------------------------------
    748                                                  impure function MemRead ( 
    749                                                    ID    : integer ; 
    750                                                    Addr  : std_logic_vector 
    751                                                  ) return std_logic_vector is
    752                                                  ------------------------------------------------------------
    753                                                    constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "MemRead function") ;
    754                                                    constant DATA_WIDTH : integer := MemStructPtr(ID).DataWidth ; 
    755                                                    variable Data  : std_logic_vector(DATA_WIDTH-1 downto 0) ; 
    756                                                  begin
    757             1                    ***0***           MemRead(ID, Addr, Data) ; 
    758             1                    ***0***           return Data ; 
    759                                                  end function MemRead ; 
    760                                              
    761                                                  ------------------------------------------------------------
    762                                                  procedure MemErase(ID : integer) is 
    763                                                  -- Erase the memory, but not the array of pointers
    764                                                  ------------------------------------------------------------
    765                                                  begin
    766                                                    if IdOutOfRange(ID, "MemErase") then 
    767             1                    ***0***             return ;
    768                                                    end if ; 
    769                                              
    770             1                    ***0***           for BlockAddr in MemStructPtr(ID).MemArrayPtr'range loop 
    770             2                    ***0***     
    771                                                      if (MemStructPtr(ID).MemArrayPtr(BlockAddr) /= NULL) then 
    772             1                    ***0***               deallocate (MemStructPtr(ID).MemArrayPtr(BlockAddr)) ; 
    773                                                      end if ; 
    774             1                    ***0***           end loop ; 
    775                                                  end procedure ; 
    776                                                  
    777                                                  ------------------------------------------------------------
    778                                                  impure function GetAlertLogID (ID : integer) return AlertLogIDType is
    779                                                  ------------------------------------------------------------
    780                                                  begin
    781                                                    if IdOutOfRange(ID, "MemErase") then 
    782             1                    ***0***             return ALERTLOG_ID_NOT_FOUND ;
    783                                                    else
    784             1                    ***0***             return MemStructPtr(ID).AlertLogID ; 
    785                                                    end if ; 
    786                                                  end function GetAlertLogID ;
    787                                              
    788                                                  ------------------------------------------------------------
    789                                                  -- PT Local
    790                                                  procedure FileReadX (
    791                                                  -- Hexadecimal or Binary File Read 
    792                                                  ------------------------------------------------------------
    793                                                    ID           : integer ;
    794                                                    FileName     : string ;
    795                                                    DataFormat   : FileFormatType ; 
    796                                                    StartAddr    : std_logic_vector ; 
    797                                                    EndAddr      : std_logic_vector
    798                                                  ) is
    799                                                    constant ADDR_WIDTH : integer := MemStructPtr(ID).AddrWidth ;
    800                                                    constant DATA_WIDTH : integer := MemStructPtr(ID).DataWidth ; 
    801                                              --      constant TemplateRange : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '0') ;
    802                                                    -- Format:  
    803                                                    --  @hh..h     -- Address in hex
    804                                                    --  hhh_XX_ZZ  -- data values in hex - space delimited 
    805                                                    --  "--" or "//" -- comments
    806                                                    file MemFile : text open READ_MODE is FileName ;
    807                                                   
    808                                                    variable Addr             : std_logic_vector(ADDR_WIDTH - 1 downto 0) ;
    809                                                    variable SmallAddr        : std_logic_vector(ADDR_WIDTH - 1 downto 0) ;
    810                                                    variable BigAddr          : std_logic_vector(ADDR_WIDTH - 1 downto 0) ;
    811                                                    variable Data             : std_logic_vector(DATA_WIDTH - 1 downto 0) ;
    812                                                    variable LineNum          : natural ; 
    813                                                    variable ItemNum          : natural ; 
    814                                                    variable AddrInc          : std_logic_vector(ADDR_WIDTH - 1 downto 0) ; 
    815                                                    variable buf              : line ;
    816                                                    variable ReadValid        : boolean ;
    817                                                    variable Empty            : boolean ; 
    818                                                    variable MultiLineComment : boolean ; 
    819                                                    variable NextChar         : character ; 
    820                                                    variable StrLen           : integer ;       
    821                                                  begin
    822             1                    ***0***           MultiLineComment := FALSE ; 
    823                                                    if StartAddr'length /= ADDR_WIDTH and EndAddr'length /= ADDR_WIDTH then
    824                                                      if (MemStructPtr(ID).MemArrayPtr = NULL) then 
    825             1                    ***0***               Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.FileReadX:  Memory not initialized, FileRead Ignored.", FAILURE) ; 
    826                                                      else
    827             1                    ***0***               Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.FileReadX:  Addr'length: " & to_string(Addr'length) & " /= Memory Address Width: " & to_string(ADDR_WIDTH), FAILURE) ; 
    828                                                      end if ; 
    829             1                    ***0***             return ; 
    830                                                    end if ; 
    831                                              
    832             1                    ***0***           Addr    := StartAddr ; 
    833             1                    ***0***           LineNum := 0 ; 
    834                                                    
    835                                                    if StartAddr <= EndAddr then 
    836             1                    ***0***             SmallAddr := StartAddr ; 
    837             1                    ***0***             BigAddr   := EndAddr ; 
    838             1                    ***0***             AddrInc   := (ADDR_WIDTH -1 downto 0 => '0') + 1 ;  
    839                                                    else
    840             1                    ***0***             SmallAddr := EndAddr ; 
    841             1                    ***0***             BigAddr   := StartAddr ; 
    842             1                    ***0***             AddrInc   := (others => '1') ;  -- -1
    843                                                    end if; 
    844                                                    
    845             1                    ***0***           ReadLineLoop : while not EndFile(MemFile) loop
    846             1                    ***0***             ReadLine(MemFile, buf) ;
    847             1                    ***0***             LineNum := LineNum + 1 ; 
    848             1                    ***0***             ItemNum := 0 ; 
    849                                                      
    850             1                    ***0***             ItemLoop : loop 
    851             1                    ***0***               EmptyOrCommentLine(buf, Empty, MultiLineComment) ; 
    852             1                    ***0***               exit ItemLoop when Empty ; 
    853             1                    ***0***               ItemNum := ItemNum + 1 ; 
    854             1                    ***0***               NextChar := buf.all(buf'left) ;
    855                                                        
    856                                                        if (NextChar = '@') then 
    857                                                        -- Get Address
    858             1                    ***0***                 read(buf, NextChar) ; 
    859             1                    ***0***                 ReadHexToken(buf, Addr, StrLen) ; 
    860             1                    ***0***                 exit ReadLineLoop when AlertIf(MemStructPtr(ID).AlertLogID, StrLen = 0, "MemoryPkg.FileReadX: Address length 0 on line: " & to_string(LineNum), FAILURE) ;
    861                                                          exit ItemLoop when AlertIf(MemStructPtr(ID).AlertLogID, Addr < SmallAddr, 
    862                                                                                         "MemoryPkg.FileReadX: Address in file: " & to_hxstring(Addr) & 
    863             1                    ***0***                                                " < StartAddr: " & to_hxstring(StartAddr) & " on line: " & to_string(LineNum)) ; 
    864                                                          exit ItemLoop when AlertIf(MemStructPtr(ID).AlertLogID, Addr > BigAddr, 
    865                                                                                         "MemoryPkg.FileReadX: Address in file: " & to_hxstring(Addr) & 
    866             1                    ***0***                                                " > EndAddr: " & to_hxstring(BigAddr) & " on line: " & to_string(LineNum)) ; 
    867                                                        
    868                                                        elsif DataFormat = HEX and IsHexOrStdLogic(NextChar) then 
    869                                                        -- Get Hex Data
    870             1                    ***0***                 ReadHexToken(buf, data, StrLen) ;
    871                                                          exit ReadLineLoop when AlertIfNot(MemStructPtr(ID).AlertLogID, StrLen > 0, 
    872                                                            "MemoryPkg.FileReadH: Error while reading data on line: " & to_string(LineNum) &
    873             1                    ***0***                   "  Item number: " & to_string(ItemNum), FAILURE) ;
    874             1                    ***0***                 log(MemStructPtr(ID).AlertLogID, "MemoryPkg.FileReadX:  MemWrite(Addr => " & to_hxstring(Addr) & ", Data => " & to_hxstring(Data) & ")", DEBUG) ; 
    875             1                    ***0***                 MemWrite(ID, Addr, data) ; 
    876             1                    ***0***                 Addr := Addr + AddrInc ; 
    877                                                          
    878                                                        elsif DataFormat = BINARY and isstd_logic(NextChar) then 
    879                                                        -- Get Binary Data
    880                                                          -- read(buf, data, ReadValid) ;
    881             1                    ***0***                 ReadBinaryToken(buf, data, StrLen) ;
    882                                                          -- exit ReadLineLoop when AlertIfNot(MemStructPtr(ID).AlertLogID, ReadValid, 
    883                                                          exit ReadLineLoop when AlertIfNot(MemStructPtr(ID).AlertLogID, StrLen > 0, 
    884                                                            "MemoryPkg.FileReadB: Error while reading data on line: " & to_string(LineNum) &
    885             1                    ***0***                   "  Item number: " & to_string(ItemNum), FAILURE) ;
    886             1                    ***0***                 log(MemStructPtr(ID).AlertLogID, "MemoryPkg.FileReadX:  MemWrite(Addr => " & to_hxstring(Addr) & ", Data => " & to_string(Data) & ")", DEBUG) ; 
    887             1                    ***0***                 MemWrite(ID, Addr, data) ; 
    888             1                    ***0***                 Addr := Addr + AddrInc ; 
    889                                                        
    890                                                        else
    891                                                          if NextChar = LF or NextChar = CR then 
    892                                                            -- If LF or CR, silently skip the character (DOS file in Unix)
    893             1                    ***0***                   read(buf, NextChar) ; 
    894                                                          else
    895                                                            -- invalid Text, issue warning and skip rest of line
    896                                                            Alert(MemStructPtr(ID).AlertLogID,  
    897                                                              "MemoryPkg.FileReadX: Invalid text on line: " & to_string(LineNum) &
    898             1                    ***0***                     "  Item: " & to_string(ItemNum) & ".  Skipping text: " & StripCrLf(buf.all)) ;
    899             1                    ***0***                   exit ItemLoop ; 
    900                                                          end if ; 
    901                                                        end if ; 
    902                                                        
    903             1                    ***0***             end loop ItemLoop ; 
    904             1                    ***0***           end loop ReadLineLoop ; 
    905                                                    
    906                                              --      -- must read EndAddr-StartAddr number of words if both start and end specified
    907                                              --      if (StartAddr /= 0 or (not EndAddr) /= 0) and (Addr /= EndAddr) then 
    908                                              --        Alert("MemoryPkg.FileReadH: insufficient data values", WARNING) ; 
    909                                              --      end if ;       
    910             1                    ***0***           file_close(MemFile) ; 
    911                                                  end FileReadX ;
    912                                                  
    913                                                  ------------------------------------------------------------
    914                                                  procedure FileReadH (
    915                                                  -- Hexadecimal File Read 
    916                                                  ------------------------------------------------------------
    917                                                    ID           : integer ;
    918                                                    FileName     : string ; 
    919                                                    StartAddr    : std_logic_vector ; 
    920                                                    EndAddr      : std_logic_vector
    921                                                  ) is
    922                                                    constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileReadH") ;
    923                                                  begin
    924             1                    ***0***           FileReadX(ID, FileName, HEX, StartAddr, EndAddr) ; 
    925                                                  end FileReadH ;
    926                                                  
    927                                                  ------------------------------------------------------------
    928                                                  -- Hexadecimal File Read 
    929                                                  procedure FileReadH (
    930                                                  ------------------------------------------------------------
    931                                                    ID           : integer ;
    932                                                    FileName     : string ;  
    933                                                    StartAddr    : std_logic_vector
    934                                                  ) is
    935                                                    constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileReadH") ;
    936                                                    constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;
    937                                                    constant EndAddr     : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '1') ;
    938                                                  begin
    939             1                    ***0***           FileReadX(ID, FileName, HEX, StartAddr, EndAddr) ; 
    940                                                  end FileReadH ;
    941                                              
    942                                                  ------------------------------------------------------------
    943                                                  -- Hexadecimal File Read 
    944                                                  procedure FileReadH (
    945                                                  ------------------------------------------------------------
    946                                                    ID           : integer ;
    947                                                    FileName     : string 
    948                                                  ) is 
    949                                                    constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileReadH") ;
    950                                                    constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;
    951                                                    constant StartAddr   : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '0') ;
    952                                                    constant EndAddr     : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '1') ;
    953                                                  begin
    954             1                    ***0***           FileReadX(ID, FileName, HEX, StartAddr, EndAddr) ; 
    955                                                  end FileReadH ;    
    956                                                  
    957                                                  ------------------------------------------------------------
    958                                                  -- Binary File Read 
    959                                                  procedure FileReadB (
    960                                                  ------------------------------------------------------------
    961                                                    ID           : integer ;
    962                                                    FileName     : string ; 
    963                                                    StartAddr    : std_logic_vector ; 
    964                                                    EndAddr      : std_logic_vector
    965                                                  ) is
    966                                                    constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileReadB") ;
    967                                                  begin
    968             1                    ***0***           FileReadX(ID, FileName, BINARY, StartAddr, EndAddr) ; 
    969                                                  end FileReadB ;
    970                                                  
    971                                                  ------------------------------------------------------------
    972                                                  -- Binary File Read 
    973                                                  procedure FileReadB (
    974                                                  ------------------------------------------------------------
    975                                                    ID           : integer ;
    976                                                    FileName     : string ;  
    977                                                    StartAddr    : std_logic_vector
    978                                                  ) is
    979                                                    constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileReadB") ;
    980                                                    constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;
    981                                                    constant EndAddr     : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '1') ;
    982                                                  begin 
    983             1                    ***0***           FileReadX(ID, FileName, BINARY, StartAddr, EndAddr) ; 
    984                                                  end FileReadB ;
    985                                              
    986                                                  ------------------------------------------------------------
    987                                                  -- Binary File Read 
    988                                                  procedure FileReadB (
    989                                                  ------------------------------------------------------------
    990                                                    ID           : integer ;
    991                                                    FileName     : string 
    992                                                  ) is 
    993                                                    constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileReadB") ;
    994                                                    constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;
    995                                                    constant StartAddr   : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '0') ;
    996                                                    constant EndAddr     : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '1') ;
    997                                                  begin
    998             1                    ***0***           FileReadX(ID, FileName, BINARY, StartAddr, EndAddr) ; 
    999                                                  end FileReadB ;    
    1000                                             
    1001                                                 ------------------------------------------------------------
    1002                                                 -- PT Local
    1003                                                 -- Hexadecimal or Binary File Write 
    1004                                                 procedure FileWriteX (
    1005                                                 ------------------------------------------------------------
    1006                                                   ID           : integer ;
    1007                                                   FileName     : string ; 
    1008                                                   DataFormat   : FileFormatType ; 
    1009                                                   StartAddr    : std_logic_vector ; 
    1010                                                   EndAddr      : std_logic_vector
    1011                                                 ) is
    1012                                                   constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;
    1013                                                   constant DATA_WIDTH  : integer := MemStructPtr(ID).DataWidth ; 
    1014                                                   constant BLOCK_WIDTH : integer := MemStructPtr(ID).BlockWidth ;
    1015                                                   -- Format:  
    1016                                                   --  @hh..h     -- Address in hex
    1017                                                   --  hhhhh      -- data one per line in either hex or binary as specified 
    1018                                                   file MemFile : text open WRITE_MODE is FileName ;
    1019                                                   alias normStartAddr     : std_logic_vector(StartAddr'length-1 downto 0) is StartAddr ; 
    1020                                                   alias normEndAddr       : std_logic_vector(EndAddr'length-1 downto 0) is EndAddr ; 
    1021                                                   variable StartBlockAddr : natural ;
    1022                                                   variable EndBlockAddr   : natural ;
    1023                                                   variable StartWordAddr  : natural ; 
    1024                                                   variable EndWordAddr    : natural ; 
    1025                                                   variable FoundData      : boolean ; 
    1026                                                   variable buf            : line ;
    1027                                                   variable Data           : std_logic_vector(DATA_WIDTH-1 downto 0) ;
    1028                                                   constant AllU           : std_logic_vector := (DATA_WIDTH-1 downto 0 => 'U');
    1029                                                   
    1030                                                 begin
    1031                                                   if StartAddr'length /= ADDR_WIDTH and EndAddr'length /= ADDR_WIDTH then
    1032                                                   -- Check StartAddr and EndAddr Widths and Memory not initialized
    1033                                                     if (MemStructPtr(ID).MemArrayPtr = NULL) then 
    1034            1                    ***0***               Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.FileWriteX:  Memory not initialized, FileRead Ignored.", FAILURE) ; 
    1035                                                     else
    1036                                                       AlertIf(MemStructPtr(ID).AlertLogID, StartAddr'length /= ADDR_WIDTH, "MemoryPkg.FileWriteX:  StartAddr'length: " 
    1037                                                                            & to_string(StartAddr'length) & 
    1038            1                    ***0***                                    " /= Memory Address Width: " & to_string(ADDR_WIDTH), FAILURE) ; 
    1039                                                       AlertIf(MemStructPtr(ID).AlertLogID, EndAddr'length /= ADDR_WIDTH, "MemoryPkg.FileWriteX:  EndAddr'length: " 
    1040                                                                            & to_string(EndAddr'length) & 
    1041            1                    ***0***                                    " /= Memory Address Width: " & to_string(ADDR_WIDTH), FAILURE) ; 
    1042                                                     end if ; 
    1043            1                    ***0***             return ; 
    1044                                                   end if ; 
    1045                                             
    1046                                                   if StartAddr > EndAddr then 
    1047                                                   -- Only support ascending addresses
    1048                                                     Alert(MemStructPtr(ID).AlertLogID, "MemoryPkg.FileWriteX:  StartAddr: " & to_hxstring(StartAddr) & 
    1049            1                    ***0***                                  " > EndAddr: " & to_hxstring(EndAddr), FAILURE) ;
    1050            1                    ***0***             return ; 
    1051                                                   end if ; 
    1052                                                         
    1053                                                   -- Slice out upper address to form block address
    1054                                                   if ADDR_WIDTH >= BLOCK_WIDTH then
    1055            1                    ***0***             StartBlockAddr := to_integer(normStartAddr(ADDR_WIDTH-1 downto BLOCK_WIDTH)) ;
    1056            1                    ***0***             EndBlockAddr   := to_integer(  normEndAddr(ADDR_WIDTH-1 downto BLOCK_WIDTH)) ;
    1057                                                   else
    1058            1                    ***0***             StartBlockAddr  := 0 ; 
    1059            1                    ***0***             EndBlockAddr  := 0 ; 
    1060                                                   end if ; 
    1061                                                         
    1062            1                    ***0***           BlockAddrLoop : for BlockAddr in StartBlockAddr to EndBlockAddr loop 
    1062            2                    ***0***     
    1063            1                    ***0***             next BlockAddrLoop when MemStructPtr(ID).MemArrayPtr(BlockAddr) = NULL ;  
    1064                                                     if BlockAddr = StartBlockAddr then 
    1065            1                    ***0***               StartWordAddr := to_integer(normStartAddr(BLOCK_WIDTH-1 downto 0)) ; 
    1066                                                     else
    1067            1                    ***0***               StartWordAddr := 0 ;
    1068                                                     end if ; 
    1069                                                     if BlockAddr = EndBlockAddr then 
    1070            1                    ***0***               EndWordAddr := to_integer(normEndAddr(BLOCK_WIDTH-1 downto 0)) ; 
    1071                                                     else 
    1072            1                    ***0***               EndWordAddr := 2**BLOCK_WIDTH-1 ;
    1073                                                     end if ; 
    1074            1                    ***0***             FoundData := FALSE ; 
    1075            1                    ***0***             WordAddrLoop : for WordAddr in StartWordAddr to EndWordAddr loop 
    1075            2                    ***0***     
    1076            1                    ***0***               Data := FromMemoryBaseType(MemStructPtr(ID).MemArrayPtr(BlockAddr)(WordAddr), Data'length) ;
    1077                                                       if MetaMatch(Data, AllU) then 
    1078            1                    ***0***                 FoundData := FALSE ;
    1079                                                       else 
    1080                                                         if not FoundData then
    1081                                                           -- Write Address
    1082            1                    ***0***                   write(buf, '@') ; 
    1083            1                    ***0***                   hwrite(buf, to_slv(BlockAddr, ADDR_WIDTH-BLOCK_WIDTH) & to_slv(WordAddr, BLOCK_WIDTH)) ; 
    1084            1                    ***0***                   writeline(MemFile, buf) ; 
    1085                                                         end if ; 
    1086            1                    ***0***                 FoundData := TRUE ; 
    1087                                                       end if ;
    1088                                                       if FoundData then  -- Write Data
    1089                                                         if DataFormat = HEX then
    1090            1                    ***0***                   hwrite(buf, Data) ; 
    1091            1                    ***0***                   writeline(MemFile, buf) ; 
    1092                                                         else
    1093            1                    ***0***                   write(buf, Data) ; 
    1094            1                    ***0***                   writeline(MemFile, buf) ; 
    1095                                                         end if; 
    1096                                                       end if ;                
    1097            1                    ***0***             end loop WordAddrLoop ; 
    1098            1                    ***0***           end loop BlockAddrLoop ;       
    1099            1                    ***0***           file_close(MemFile) ; 
    1100                                                 end FileWriteX ;
    1101                                                 
    1102                                                 ------------------------------------------------------------
    1103                                                 -- Hexadecimal File Write 
    1104                                                 procedure FileWriteH (
    1105                                                 ------------------------------------------------------------
    1106                                                   ID           : integer ;
    1107                                                   FileName     : string ; 
    1108                                                   StartAddr    : std_logic_vector ; 
    1109                                                   EndAddr      : std_logic_vector
    1110                                                 ) is
    1111                                                   constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileWriteH") ;
    1112                                                 begin
    1113            1                    ***0***           FileWriteX(ID, FileName, HEX, StartAddr, EndAddr) ; 
    1114                                                 end FileWriteH ;
    1115                                             
    1116                                                 ------------------------------------------------------------
    1117                                                 -- Hexadecimal File Write 
    1118                                                 procedure FileWriteH (
    1119                                                 ------------------------------------------------------------
    1120                                                   ID           : integer ;
    1121                                                   FileName     : string ;  
    1122                                                   StartAddr    : std_logic_vector
    1123                                                 ) is
    1124                                                   constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileWriteH") ;
    1125                                                   constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;
    1126                                                   constant EndAddr     : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '1') ;
    1127                                                 begin
    1128            1                    ***0***           FileWriteX(ID, FileName, HEX, StartAddr, EndAddr) ; 
    1129                                                 end FileWriteH ;
    1130                                             
    1131                                                 ------------------------------------------------------------
    1132                                                 -- Hexadecimal File Write 
    1133                                                 procedure FileWriteH (
    1134                                                 ------------------------------------------------------------
    1135                                                   ID           : integer ;
    1136                                                   FileName     : string 
    1137                                                 ) is 
    1138                                                   constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileWriteH") ;
    1139                                                   constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;
    1140                                                   constant StartAddr   : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '0') ;
    1141                                                   constant EndAddr     : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '1') ;
    1142                                                 begin
    1143            1                    ***0***           FileWriteX(ID, FileName, HEX, StartAddr, EndAddr) ; 
    1144                                                 end FileWriteH ;    
    1145                                                 
    1146                                                 ------------------------------------------------------------
    1147                                                 -- Binary File Write 
    1148                                                 procedure FileWriteB (
    1149                                                 ------------------------------------------------------------
    1150                                                   ID           : integer ;
    1151                                                   FileName     : string ; 
    1152                                                   StartAddr    : std_logic_vector ; 
    1153                                                   EndAddr      : std_logic_vector
    1154                                                 ) is
    1155                                                   constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileWriteB") ;
    1156                                                 begin
    1157            1                    ***0***           FileWriteX(ID, FileName, BINARY, StartAddr, EndAddr) ; 
    1158                                                 end FileWriteB ;
    1159                                                 
    1160                                                 ------------------------------------------------------------
    1161                                                 -- Binary File Write 
    1162                                                 procedure FileWriteB (
    1163                                                 ------------------------------------------------------------
    1164                                                   ID           : integer ;
    1165                                                   FileName     : string ;  
    1166                                                   StartAddr    : std_logic_vector
    1167                                                 ) is
    1168                                                   constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileWriteB") ;
    1169                                                   constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;
    1170                                                   constant EndAddr     : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '1') ;
    1171                                                 begin
    1172            1                    ***0***           FileWriteX(ID, FileName, BINARY, StartAddr, EndAddr) ; 
    1173                                                 end FileWriteB ;
    1174                                             
    1175                                                 ------------------------------------------------------------
    1176                                                 -- Binary File Write 
    1177                                                 procedure FileWriteB (
    1178                                                 ------------------------------------------------------------
    1179                                                   ID           : integer ;
    1180                                                   FileName     : string 
    1181                                                 ) is 
    1182                                                   constant ID_CHECK_OK : boolean := IdOutOfRange(ID, "FileWriteB") ;
    1183                                                   constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;
    1184                                                   constant StartAddr   : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '0') ;
    1185                                                   constant EndAddr     : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '1') ;
    1186                                                 begin
    1187            1                    ***0***           FileWriteX(ID, FileName, BINARY, StartAddr, EndAddr) ; 
    1188                                                 end FileWriteB ;  
    1189                                             
    1190                                             -- /////////////////////////////////////////
    1191                                             -- /////////////////////////////////////////
    1192                                             -- Structure Wide Methods
    1193                                             -- /////////////////////////////////////////
    1194                                             -- /////////////////////////////////////////
    1195                                                 ------------------------------------------------------------
    1196                                                 -- Erase the memory
    1197                                                 -- Used between independent pieces of a test
    1198                                                 -- to erase the all memory model contents, but
    1199                                                 -- keeps the memory size and infrastructure
    1200                                                 procedure MemErase is 
    1201                                                 ------------------------------------------------------------
    1202                                                 begin
    1203            1                    ***0***           for ID in MemStructPtr'range loop 
    1203            2                    ***0***     
    1204            1                    ***0***             MemErase(ID) ;
    1205            1                    ***0***           end loop ;
    1206                                                 end procedure ; 
    1207                                             
    1208                                                 ------------------------------------------------------------
    1209                                                 -- Destroys the entire data structure
    1210                                                 -- Usage:  At the end of the simulation to remove all 
    1211                                                 -- memory used by data structure.  
    1212                                                 -- Note, a normal simulator does this for you.  
    1213                                                 -- You only need this if the simulator is broken.
    1214                                                 ------------------------------------------------------------
    1215                                                 procedure deallocate (ID : integer) is 
    1216                                                 ------------------------------------------------------------
    1217                                                 begin
    1218            1                    ***0***           MemErase(ID) ; 
    1219            1                    ***0***           deallocate(MemStructPtr(ID).MemArrayPtr) ; 
    1220            1                    ***0***           MemStructPtr(ID).AddrWidth   := -1 ;
    1221            1                    ***0***           MemStructPtr(ID).DataWidth   := 1 ;
    1222            1                    ***0***           MemStructPtr(ID).BlockWidth  := 0 ;
    1223                                                 end procedure ; 
    1224                                             
    1225                                                 procedure deallocate is
    1226                                                 begin
    1227            1                    ***0***           for ID in MemStructPtr'range loop 
    1227            2                    ***0***     
    1228            1                    ***0***             deallocate(ID) ;
    1229            1                    ***0***           end loop ;
    1230                                             -- If this is done, nothing will work after
    1231                                             --      deallocate(MemStructPtr) ;   
    1232            1                    ***0***           NumItems := 0 ; 
    1233                                             --      MemStructPtr := new ItemArrayType'(Template) ;   -- I--
    1234                                                 end procedure deallocate ; 
    1235                                             
    1236                                             -- /////////////////////////////////////////
    1237                                             -- /////////////////////////////////////////
    1238                                             -- Compatibility Methods
    1239                                             -- /////////////////////////////////////////
    1240                                             -- /////////////////////////////////////////
    1241                                                ------------------------------------------------------------
    1242                                                 procedure MemInit ( AddrWidth, DataWidth  : in  integer ) is
    1243                                                 ------------------------------------------------------------
    1244                                                 begin
    1245            1                    ***0***           MemInit(PT_ID, AddrWidth, DataWidth) ;
    1246                                                 end procedure MemInit ;
    1247                                             
    1248                                                 ------------------------------------------------------------
    1249                                                 procedure MemWrite (  Addr, Data  : in  std_logic_vector ) is 
    1250                                                 ------------------------------------------------------------
    1251                                                 begin
    1252            1                    ***0***           MemWrite(PT_ID, Addr, Data) ; 
    1253                                                 end procedure MemWrite ; 
    1254                                             
    1255                                                 ------------------------------------------------------------
    1256                                                 procedure MemRead (  
    1257                                                 ------------------------------------------------------------
    1258                                                   Addr  : In   std_logic_vector ;
    1259                                                   Data  : Out  std_logic_vector 
    1260                                                 ) is
    1261                                                 begin
    1262            1                    ***0***           MemRead(PT_ID, Addr, Data) ; 
    1263                                                 end procedure MemRead ; 
    1264                                             
    1265                                                 ------------------------------------------------------------
    1266                                                 impure function MemRead ( Addr  : std_logic_vector ) return std_logic_vector is
    1267                                                 ------------------------------------------------------------
    1268                                                   constant DATA_WIDTH : integer := MemStructPtr(PT_ID).DataWidth ; 
    1269                                                   variable Data  : std_logic_vector(DATA_WIDTH-1 downto 0) ; 
    1270                                                 begin
    1271            1                    ***0***           MemRead(PT_ID, Addr, Data) ; 
    1272            1                    ***0***           return Data ; 
    1273                                                 end function MemRead ; 
    1274                                             
    1275                                                 ------------------------------------------------------------
    1276                                                 procedure SetAlertLogID (A : AlertLogIDType) is
    1277                                                 ------------------------------------------------------------
    1278                                                 begin
    1279            1                    ***0***           MemStructPtr(PT_ID).AlertLogID  := A ;
    1280                                                 end procedure SetAlertLogID ;
    1281                                             
    1282                                                 ------------------------------------------------------------
    1283                                                 procedure SetAlertLogID(Name : string ; ParentID : AlertLogIDType := OSVVM_MEMORY_ALERTLOG_ID ; CreateHierarchy : Boolean := TRUE) is
    1284                                                 ------------------------------------------------------------
    1285                                                 begin
    1286            1                    ***0***           MemStructPtr(PT_ID).AlertLogID := GetAlertLogID(Name, ParentID, CreateHierarchy) ;
    1287                                                 end procedure SetAlertLogID ;
    1288                                                 
    1289                                                 ------------------------------------------------------------
    1290                                                 impure function GetAlertLogID return AlertLogIDType is
    1291                                                 ------------------------------------------------------------
    1292                                                 begin
    1293            1                    ***0***           return MemStructPtr(PT_ID).AlertLogID ; 
    1294                                                 end function GetAlertLogID ;
    1295                                                   
    1296                                                 ------------------------------------------------------------
    1297                                                 procedure FileReadH (
    1298                                                 -- Hexadecimal File Read 
    1299                                                 ------------------------------------------------------------
    1300                                                   FileName     : string ; 
    1301                                                   StartAddr    : std_logic_vector ; 
    1302                                                   EndAddr      : std_logic_vector
    1303                                                 ) is
    1304                                                 begin
    1305            1                    ***0***           FileReadH(PT_ID, FileName, StartAddr, EndAddr) ; 
    1306                                                 end FileReadH ;
    1307                                                 
    1308                                                 ------------------------------------------------------------
    1309                                                 procedure FileReadH (FileName : string ;  StartAddr : std_logic_vector) is
    1310                                                 -- Hexadecimal File Read 
    1311                                                 ------------------------------------------------------------
    1312                                                 begin
    1313            1                    ***0***           FileReadH(PT_ID, FileName, StartAddr) ; 
    1314                                                 end FileReadH ;
    1315                                             
    1316                                                 ------------------------------------------------------------
    1317                                                 procedure FileReadH (FileName : string) is 
    1318                                                 -- Hexadecimal File Read 
    1319                                                 ------------------------------------------------------------
    1320                                                 begin
    1321            1                    ***0***           FileReadH(PT_ID, FileName) ; 
    1322                                                 end FileReadH ;    
    1323                                                 
    1324                                                  ------------------------------------------------------------
    1325                                                 procedure FileReadB (
    1326                                                 -- Binary File Read 
    1327                                                 ------------------------------------------------------------
    1328                                                   FileName     : string ; 
    1329                                                   StartAddr    : std_logic_vector ; 
    1330                                                   EndAddr      : std_logic_vector
    1331                                                 ) is
    1332                                                 begin
    1333            1                    ***0***           FileReadB(PT_ID, FileName, StartAddr, EndAddr) ; 
    1334                                                 end FileReadB ;
    1335                                                 
    1336                                                 ------------------------------------------------------------
    1337                                                 procedure FileReadB (FileName : string ;  StartAddr : std_logic_vector) is
    1338                                                 -- Binary File Read 
    1339                                                 ------------------------------------------------------------
    1340                                                 begin
    1341            1                    ***0***           FileReadB(PT_ID, FileName, StartAddr) ; 
    1342                                                 end FileReadB ;
    1343                                             
    1344                                                 ------------------------------------------------------------
    1345                                                 procedure FileReadB (FileName : string) is 
    1346                                                 -- Binary File Read 
    1347                                                 ------------------------------------------------------------
    1348                                                 begin
    1349            1                    ***0***           FileReadB(PT_ID, FileName) ; 
    1350                                                 end FileReadB ;    
    1351                                             
    1352                                                 ------------------------------------------------------------
    1353                                                 procedure FileWriteH (
    1354                                                 -- Hexadecimal File Write 
    1355                                                 ------------------------------------------------------------
    1356                                                   FileName     : string ; 
    1357                                                   StartAddr    : std_logic_vector ; 
    1358                                                   EndAddr      : std_logic_vector
    1359                                                 ) is
    1360                                                 begin
    1361            1                    ***0***           FileWriteH(PT_ID, FileName, StartAddr, EndAddr) ; 
    1362                                                 end FileWriteH ;
    1363                                                 
    1364                                                 ------------------------------------------------------------
    1365                                                 procedure FileWriteH (FileName : string ;  StartAddr : std_logic_vector) is
    1366                                                 -- Hexadecimal File Write 
    1367                                                 ------------------------------------------------------------
    1368                                                 begin
    1369            1                    ***0***           FileWriteH(PT_ID, FileName, StartAddr) ; 
    1370                                                 end FileWriteH ;
    1371                                             
    1372                                                 ------------------------------------------------------------
    1373                                                 procedure FileWriteH (FileName : string) is 
    1374                                                 -- Hexadecimal File Write 
    1375                                                 ------------------------------------------------------------
    1376                                                 begin
    1377            1                    ***0***           FileWriteH(PT_ID, FileName) ; 
    1378                                                 end FileWriteH ;    
    1379                                                 
    1380                                                  ------------------------------------------------------------
    1381                                                 procedure FileWriteB (
    1382                                                 -- Binary File Write 
    1383                                                 ------------------------------------------------------------
    1384                                                   FileName     : string ; 
    1385                                                   StartAddr    : std_logic_vector ; 
    1386                                                   EndAddr      : std_logic_vector
    1387                                                 ) is
    1388                                                 begin
    1389            1                    ***0***           FileWriteB(PT_ID, FileName, StartAddr, EndAddr) ; 
    1390                                                 end FileWriteB ;
    1391                                                 
    1392                                                 ------------------------------------------------------------
    1393                                                 procedure FileWriteB (FileName : string ;  StartAddr : std_logic_vector) is
    1394                                                 -- Binary File Write 
    1395                                                 ------------------------------------------------------------
    1396                                                 begin
    1397            1                    ***0***           FileWriteB(PT_ID, FileName, StartAddr) ; 
    1398                                                 end FileWriteB ;
    1399                                             
    1400                                                 ------------------------------------------------------------
    1401                                                 procedure FileWriteB (FileName : string) is 
    1402                                                 -- Binary File Write 
    1403                                                 ------------------------------------------------------------
    1404                                                 begin
    1405            1                    ***0***           FileWriteB(PT_ID, FileName) ; 
    1406                                                 end FileWriteB ;        
    1407                                               end protected body MemoryPType ;
    1408                                              
    1409                                             -- /////////////////////////////////////////
    1410                                             -- /////////////////////////////////////////
    1411                                             -- Singleton Data Structure
    1412                                             -- /////////////////////////////////////////
    1413                                             -- /////////////////////////////////////////
    1414                                               shared variable MemoryStore : MemoryPType ;
    1415                                              
    1416                                                ------------------------------------------------------------
    1417                                               impure function NewID (
    1418                                                 Name                : String ; 
    1419                                                 AddrWidth           : integer ; 
    1420                                                 DataWidth           : integer ; 
    1421                                                 ParentID            : AlertLogIDType          := OSVVM_MEMORY_ALERTLOG_ID ;
    1422                                                 ReportMode          : AlertLogReportModeType  := ENABLED ; 
    1423                                                 Search              : NameSearchType          := PRIVATE_NAME ;
    1424                                                 PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT
    1425                                               ) return MemoryIDType is
    1426                                                 variable Result : MemoryIDType ; 
    1427                                               begin
    1428            1                    ***0***         Result.ID := MemoryStore.NewID(Name, AddrWidth, DataWidth, ParentID, ReportMode, Search, PrintParent) ; 
    1429            1                    ***0***         return Result ; 
    1430                                               end function NewID ; 
    1431                                             
    1432                                               ------------------------------------------------------------
    1433                                               impure function IsInitialized (ID : MemoryIDType) return boolean is
    1434                                               ------------------------------------------------------------
    1435                                               begin
    1436            1                    ***0***         return MemoryStore.IsInitialized(ID) ;
    1437                                               end function IsInitialized ;
    1438                                             
    1439                                               ------------------------------------------------------------
    1440                                               procedure MemWrite ( 
    1441                                                 ID    : MemoryIDType ; 
    1442                                                 Addr  : std_logic_vector ;
    1443                                                 Data  : std_logic_vector 
    1444                                               ) is
    1445                                               begin
    1446            1                    ***0***         MemoryStore.MemWrite(ID.ID, Addr, Data) ; 
    1447                                               end procedure MemWrite ; 
    1448                                               
    1449                                               procedure MemRead (  
    1450                                                 ID    : in MemoryIDType ;
    1451                                                 Addr  : in  std_logic_vector ;
    1452                                                 Data  : out std_logic_vector 
    1453                                               ) is
    1454                                               begin
    1455            1                    ***0***         MemoryStore.MemRead(ID.ID, Addr, Data) ; 
    1456                                               end procedure MemRead ; 
    1457                                               
    1458                                               impure function MemRead ( 
    1459                                                 ID    : MemoryIDType ; 
    1460                                                 Addr  : std_logic_vector 
    1461                                               ) return std_logic_vector is
    1462                                               begin
    1463            1                    ***0***         return MemoryStore.MemRead(ID.ID, Addr) ; 
    1464                                               end function MemRead ; 
    1465                                             
    1466                                               ------------------------------------------------------------
    1467                                               procedure MemErase (ID : in MemoryIDType) is
    1468                                               begin
    1469            1                    ***0***         MemoryStore.MemErase(ID.ID) ; 
    1470                                               end procedure MemErase ;  
    1471                                               
    1472                                               ------------------------------------------------------------
    1473                                               procedure deallocate (ID : in MemoryIDType) is 
    1474                                               begin
    1475            1                    ***0***         MemoryStore.deallocate(ID.ID) ; 
    1476                                               end procedure ; 
    1477                                             
    1478                                               ------------------------------------------------------------
    1479                                               procedure MemoryPkgDeallocate is
    1480                                               begin
    1481            1                    ***0***         MemoryStore.deallocate ; 
    1482                                               end procedure MemoryPkgDeallocate ; 
    1483                                             
    1484                                               ------------------------------------------------------------
    1485                                               impure function GetAlertLogID (
    1486                                                 ID : in MemoryIDType
    1487                                               ) return AlertLogIDType is
    1488                                               begin
    1489            1                    ***0***         return MemoryStore.GetAlertLogID(ID.ID) ; 
    1490                                               end function GetAlertLogID ; 
    1491                                               
    1492                                               ------------------------------------------------------------
    1493                                               procedure FileReadH (    -- Hexadecimal File Read 
    1494                                                 ID           : MemoryIDType ;
    1495                                                 FileName     : string ; 
    1496                                                 StartAddr    : std_logic_vector ; 
    1497                                                 EndAddr      : std_logic_vector
    1498                                               ) is
    1499                                               begin
    1500            1                    ***0***         MemoryStore.FileReadH(ID.ID, FileName, StartAddr, EndAddr) ; 
    1501                                               end procedure FileReadH ; 
    1502                                               
    1503                                               procedure FileReadH (
    1504                                                 ID           : MemoryIDType ;
    1505                                                 FileName     : string ;  
    1506                                                 StartAddr    : std_logic_vector
    1507                                               ) is
    1508                                               begin
    1509            1                    ***0***         MemoryStore.FileReadH(ID.ID, FileName, StartAddr) ; 
    1510                                               end procedure FileReadH ; 
    1511                                             
    1512                                               procedure FileReadH (
    1513                                                 ID           : MemoryIDType ;
    1514                                                 FileName     : string 
    1515                                               ) is
    1516                                               begin
    1517            1                    ***0***         MemoryStore.FileReadH(ID.ID, FileName) ; 
    1518                                               end procedure FileReadH ; 
    1519                                             
    1520                                               ------------------------------------------------------------
    1521                                               procedure FileReadB (    -- Binary File Read 
    1522                                                 ID           : MemoryIDType ;
    1523                                                 FileName     : string ; 
    1524                                                 StartAddr    : std_logic_vector ; 
    1525                                                 EndAddr      : std_logic_vector
    1526                                               ) is
    1527                                               begin
    1528            1                    ***0***         MemoryStore.FileReadB(ID.ID, FileName, StartAddr, EndAddr) ; 
    1529                                               end procedure FileReadB ; 
    1530                                             
    1531                                               procedure FileReadB (
    1532                                                 ID           : MemoryIDType ;
    1533                                                 FileName     : string ;  
    1534                                                 StartAddr    : std_logic_vector
    1535                                               ) is
    1536                                               begin
    1537            1                    ***0***         MemoryStore.FileReadB(ID.ID, FileName, StartAddr) ; 
    1538                                               end procedure FileReadB ; 
    1539                                             
    1540                                               procedure FileReadB (
    1541                                                 ID           : MemoryIDType ;
    1542                                                 FileName     : string 
    1543                                               ) is
    1544                                               begin
    1545            1                    ***0***         MemoryStore.FileReadB(ID.ID, FileName) ; 
    1546                                               end procedure FileReadB ; 
    1547                                             
    1548                                               ------------------------------------------------------------
    1549                                               procedure FileWriteH (    -- Hexadecimal File Write 
    1550                                                 ID           : MemoryIDType ;
    1551                                                 FileName     : string ; 
    1552                                                 StartAddr    : std_logic_vector ; 
    1553                                                 EndAddr      : std_logic_vector
    1554                                               ) is
    1555                                               begin
    1556            1                    ***0***         MemoryStore.FileWriteH(ID.ID, FileName, StartAddr, EndAddr) ; 
    1557                                               end procedure FileWriteH ; 
    1558                                             
    1559                                               procedure FileWriteH (
    1560                                                 ID           : MemoryIDType ;
    1561                                                 FileName     : string ;  
    1562                                                 StartAddr    : std_logic_vector
    1563                                               ) is
    1564                                               begin
    1565            1                    ***0***         MemoryStore.FileWriteH(ID.ID, FileName, StartAddr) ; 
    1566                                               end procedure FileWriteH ; 
    1567                                               
    1568                                               procedure FileWriteH (
    1569                                                 ID           : MemoryIDType ;
    1570                                                 FileName     : string 
    1571                                               ) is
    1572                                               begin
    1573            1                    ***0***         MemoryStore.FileWriteH(ID.ID, FileName) ; 
    1574                                               end procedure FileWriteH ; 
    1575                                               
    1576                                               ------------------------------------------------------------
    1577                                               procedure FileWriteB (    -- Binary File Write 
    1578                                                 ID           : MemoryIDType ;
    1579                                                 FileName     : string ; 
    1580                                                 StartAddr    : std_logic_vector ; 
    1581                                                 EndAddr      : std_logic_vector
    1582                                               ) is
    1583                                               begin
    1584            1                    ***0***         MemoryStore.FileWriteB(ID.ID, FileName, StartAddr, EndAddr) ; 
    1585                                               end procedure FileWriteB ; 
    1586                                               
    1587                                               procedure FileWriteB (
    1588                                                 ID           : MemoryIDType ;
    1589                                                 FileName     : string ;  
    1590                                                 StartAddr    : std_logic_vector
    1591                                               ) is
    1592                                               begin
    1593            1                    ***0***         MemoryStore.FileWriteB(ID.ID, FileName, StartAddr) ; 
    1594                                               end procedure FileWriteB ; 
    1595                                             
    1596                                               procedure FileWriteB (
    1597                                                 ID           : MemoryIDType ;
    1598                                                 FileName     : string 
    1599                                               ) is
    1600                                               begin
    1601            1                    ***0***         MemoryStore.FileWriteB(ID.ID, FileName) ; 
    1602                                               end procedure FileWriteB ; 
    1603                                             end MemoryGenericPkg ;


=================================================================================
=== File: ../osvvm/osvvm/MemorySupportPkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        15         0        15     0.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/osvvm/MemorySupportPkg.vhd --

------------------------------------IF Branch------------------------------------
    122                                  ***0***     Count coming in to IF
    122             1                    ***0***             if Is_X(Bits16(BitIndex)) then 
    125             1                    ***0***             else 
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    124                                  ***0***     Count coming in to IF
    124             1                    ***0***               BitVal(BitIndex) := '1' when Bits16(BitIndex) = 'U' else '0' ;
    124             2                    ***0***               BitVal(BitIndex) := '1' when Bits16(BitIndex) = 'U' else '0' ;
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    148                                  ***0***     Count coming in to IF
    148             1                    ***0***             if BitIsX(BitIndex) = '1' then 
    150             1                    ***0***             else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    149                                  ***0***     Count coming in to IF
    149             1                    ***0***               Bits16(BitIndex) := 'U' when BitVal(BitIndex) = '1' else 'X' ;
    149             2                    ***0***               Bits16(BitIndex) := 'U' when BitVal(BitIndex) = '1' else 'X' ;
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    192                                  ***0***     Count coming in to IF
    192             1                    ***0***             if Is_X(Bits32(BitIndex)) then 
    194             1                    ***0***             else 
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    248                                  ***0***     Count coming in to IF
    248             1                    ***0***         if (Is_X(Slv)) then 
    250             1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    261                                  ***0***     Count coming in to IF
    261             1                    ***0***         if Mem(Mem'left) >= 0 then 
    264             1                    ***0***         elsif Mem(Mem'left) = -1 then 
    267             1                    ***0***         else 
Branch totals: 0 hits of 3 branches = 0.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      56         0        56     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/osvvm/MemorySupportPkg.vhd --

    1                                                --
    2                                                --  File Name:         MemorySupportPkg.vhd
    3                                                --  Design Unit Name:  MemorySupportPkg
    4                                                --  Revision:          STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com 
    7                                                --  Contributor(s):            
    8                                                --    Jim Lewis      email:  jim@synthworks.com   
    9                                                --
    10                                               --  Description
    11                                               --    Defines the storage policies: X, NoX, and orig 
    12                                               --    Supports MemoryGenericPkg
    13                                               --    Policies are implemented in instances in MemoryPkg
    14                                               --    
    15                                               --  Developed for: 
    16                                               --        SynthWorks Design Inc. 
    17                                               --        VHDL Training Classes
    18                                               --        11898 SW 128th Ave.  Tigard, Or  97223
    19                                               --        http://www.SynthWorks.com
    20                                               --
    21                                               --  Revision History:
    22                                               --    Date      Version    Description
    23                                               --    10/2022   2022.10    Minor changes
    24                                               --    08/2022   2022.08    Initial revision
    25                                               --
    26                                               --
    27                                               --  This file is part of OSVVM.
    28                                               --  
    29                                               --  Copyright (c) 2022 by SynthWorks Design Inc.  
    30                                               --  
    31                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    32                                               --  you may not use this file except in compliance with the License.
    33                                               --  You may obtain a copy of the License at
    34                                               --  
    35                                               --      https://www.apache.org/licenses/LICENSE-2.0
    36                                               --  
    37                                               --  Unless required by applicable law or agreed to in writing, software
    38                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    39                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    40                                               --  See the License for the specific language governing permissions and
    41                                               --  limitations under the License.
    42                                               --  
    43                                               
    44                                               library IEEE ; 
    45                                                 use IEEE.std_logic_1164.all ; 
    46                                                 use IEEE.numeric_std.all ; 
    47                                                 use IEEE.numeric_std_unsigned.all ; 
    48                                                 use IEEE.math_real.all ;
    49                                               
    50                                                 use work.AlertLogPkg.all ;
    51                                                 
    52                                               package MemorySupportPkg is
    53                                               
    54                                                 subtype MemoryBaseType is integer_vector ; 
    55                                               
    56                                                 -- -----------------------------------------------
    57                                                 -- Memory Policy X
    58                                                 --   Maintains fidelity of X and U
    59                                                 --   Each integer value stores 16 bits of data and 16 bits o X and U
    60                                                 --   Bit size unlimited
    61                                                 -- 
    62                                                 subtype  MemoryBaseType_X is integer_vector ;
    63                                                 function SizeMemoryBaseType_X(Size : integer) return integer ;  
    64                                                 function ToMemoryBaseType_X  (Slv  : std_logic_vector ; Size : integer) return integer_vector ;
    65                                                 function FromMemoryBaseType_X(Mem  : integer_vector   ; Size : integer) return std_logic_vector ;
    66                                                 function InitMemoryBaseType_X(Size : integer) return integer_vector ; 
    67                                               
    68                                                 -- -----------------------------------------------
    69                                                 -- Memory Policy NoX
    70                                                 --   X and U are stored as a 0
    71                                                 --   Each integer value stores 32 bits of data
    72                                                 --   Bit size unlimited
    73                                                 --   For larger word widths, uses half storage as X
    74                                                 -- 
    75                                                 subtype  MemoryBaseType_NoX is integer_vector ;
    76                                                 function SizeMemoryBaseType_NoX(Size : integer) return integer ;  
    77                                                 function ToMemoryBaseType_NoX  (Slv  : std_logic_vector ; Size : integer) return integer_vector ;
    78                                                 function FromMemoryBaseType_NoX(Mem  : integer_vector   ; Size : integer) return std_logic_vector ;
    79                                                 function InitMemoryBaseType_NoX(Size : integer) return integer_vector ; 
    80                                               
    81                                                 -- -----------------------------------------------
    82                                                 -- Memory policy orig 
    83                                                 --   For backward compatibility only
    84                                                 --   upto 31 bits of data
    85                                                 --   X or U in any bit and the word becomes X
    86                                                 -- 
    87                                                 subtype  MemoryBaseType_orig is integer_vector ; 
    88                                                 function SizeMemoryBaseType_orig(Size : integer) return integer ;  
    89                                                 function ToMemoryBaseType_orig  (Slv  : std_logic_vector ; Size : integer) return integer_vector ;
    90                                                 function FromMemoryBaseType_orig(Mem  : integer_vector   ; Size : integer) return std_logic_vector ;
    91                                                 function InitMemoryBaseType_orig(Size : integer) return integer_vector ; 
    92                                               
    93                                               end MemorySupportPkg ;
    94                                               
    95                                               package body MemorySupportPkg is 
    96                                               
    97                                                 ------------------------------------------------------------
    98                                                 -- Memory Policy X
    99                                                 --   Maintains fidelity of X and U
    100                                                --   Each integer value stores 16 bits of data and 16 bits o X and U
    101                                                ------------------------------------------------------------
    102                                                ------------------------------------------------------------
    103                                                function SizeMemoryBaseType_X(Size : integer) return integer is  
    104                                                ------------------------------------------------------------
    105                                                begin
    106             1                    ***0***         return integer(Ceil(real(Size)/16.0)) ; 
    107                                                end function SizeMemoryBaseType_X ; 
    108                                                
    109                                                ------------------------------------------------------------
    110                                                function ToMemoryBaseType_X(Slv : std_logic_vector ; Size : integer) return integer_vector is 
    111                                                ------------------------------------------------------------
    112                                                  variable NormalizedSlv : std_logic_vector(Size*16-1 downto 0) ;
    113                                                  variable Bits16        : std_logic_vector(15 downto 0) ;
    114                                                  variable BitIsX        : std_logic_vector(15 downto 0) ; 
    115                                                  variable BitVal        : std_logic_vector(15 downto 0) ;
    116                                                  variable result        : integer_vector (Size-1 downto 0) ; 
    117                                                begin
    118             1                    ***0***         NormalizedSlv := Resize(Slv, Size*16) ; 
    119             1                    ***0***         for MemIndex in result'reverse_range loop 
    119             2                    ***0***     
    120             1                    ***0***           Bits16 := NormalizedSlv(16*MemIndex+15 downto 16*MemIndex) ;
    121             1                    ***0***           for BitIndex in 0 to 15 loop
    121             2                    ***0***     
    122                                                      if Is_X(Bits16(BitIndex)) then 
    123             1                    ***0***               BitIsX(BitIndex) := '1' ; 
    124             1                    ***0***               BitVal(BitIndex) := '1' when Bits16(BitIndex) = 'U' else '0' ;
    125                                                      else 
    126             1                    ***0***               BitIsX(BitIndex) := '0' ; 
    127             1                    ***0***               BitVal(BitIndex) := Bits16(BitIndex) ;
    128                                                      end if ; 
    129             1                    ***0***           end loop ; 
    130             1                    ***0***           result(MemIndex) := to_integer(signed(BitIsX & BitVal)) ; 
    131             1                    ***0***         end loop ;
    132             1                    ***0***         return result ; 
    133                                                end function ToMemoryBaseType_X ; 
    134                                                
    135                                                ------------------------------------------------------------
    136                                                function FromMemoryBaseType_X(Mem : integer_vector ; Size : integer) return std_logic_vector is 
    137                                                ------------------------------------------------------------
    138                                                  constant NumIntegers   : integer := Mem'length ; 
    139                                                  alias    NormalizedMem : integer_vector(NumIntegers-1 downto 0) is Mem ; 
    140                                                  variable NormalizedSlv : std_logic_vector(NumIntegers*16-1 downto 0) ;
    141                                                  variable Bits16        : std_logic_vector(15 downto 0) ;
    142                                                  variable BitIsX        : std_logic_vector(15 downto 0) ; 
    143                                                  variable BitVal        : std_logic_vector(15 downto 0) ;
    144                                                begin
    145             1                    ***0***         for MemIndex in NormalizedMem'reverse_range loop 
    145             2                    ***0***     
    146             1                    ***0***           (BitIsX, BitVal) := std_logic_vector(to_signed(NormalizedMem(MemIndex), 32)) ;
    147             1                    ***0***           for BitIndex in 0 to 15 loop
    147             2                    ***0***     
    148                                                      if BitIsX(BitIndex) = '1' then 
    149             1                    ***0***               Bits16(BitIndex) := 'U' when BitVal(BitIndex) = '1' else 'X' ;
    150                                                      else
    151             1                    ***0***               Bits16(BitIndex) := BitVal(BitIndex) ; 
    152                                                      end if ;      
    153             1                    ***0***           end loop ;
    154             1                    ***0***           NormalizedSlv(16*MemIndex+15 downto 16*MemIndex) := Bits16 ;
    155             1                    ***0***         end loop ; 
    156             1                    ***0***         return NormalizedSlv(Size-1 downto 0) ; 
    157                                                end function FromMemoryBaseType_X ; 
    158                                                
    159                                                ------------------------------------------------------------
    160                                                function InitMemoryBaseType_X(Size : integer) return integer_vector is  
    161                                                ------------------------------------------------------------
    162                                                  constant BaseU : integer_vector(0 to Size-1)  := (others => -1) ;
    163                                                begin
    164             1                    ***0***         return BaseU ; 
    165                                                end function InitMemoryBaseType_X ; 
    166                                                
    167                                              
    168                                                ------------------------------------------------------------
    169                                                -- Memory Policy NoX
    170                                                --   X and U are stored as a 0
    171                                                --   Each integer value stores 32 bits of data
    172                                                ------------------------------------------------------------
    173                                                ------------------------------------------------------------
    174                                                function SizeMemoryBaseType_NoX(Size : integer) return integer is  
    175                                                ------------------------------------------------------------
    176                                                begin
    177             1                    ***0***         return integer(Ceil(real(Size)/32.0)) ; 
    178                                                end function SizeMemoryBaseType_NoX ; 
    179                                                
    180                                                ------------------------------------------------------------
    181                                                function ToMemoryBaseType_NoX(Slv : std_logic_vector ; Size : integer) return integer_vector is 
    182                                                ------------------------------------------------------------
    183                                                  variable NormalizedSlv : std_logic_vector(Size*32-1 downto 0) ;
    184                                                  variable Bits32        : std_logic_vector(31 downto 0) ;
    185                                                  variable BitVal        : std_logic_vector(31 downto 0) ;
    186                                                  variable result        : integer_vector (Size-1 downto 0) ; 
    187                                                begin
    188             1                    ***0***         NormalizedSlv := Resize(Slv, Size*32) ; 
    189             1                    ***0***         for MemIndex in result'reverse_range loop 
    189             2                    ***0***     
    190             1                    ***0***           Bits32 := NormalizedSlv(32*MemIndex+31 downto 32*MemIndex) ;
    191             1                    ***0***           for BitIndex in 0 to 31 loop
    191             2                    ***0***     
    192                                                      if Is_X(Bits32(BitIndex)) then 
    193             1                    ***0***               BitVal(BitIndex) := '0' ;
    194                                                      else 
    195             1                    ***0***               BitVal(BitIndex) := Bits32(BitIndex) ;
    196                                                      end if ; 
    197             1                    ***0***           end loop ; 
    198             1                    ***0***           result(MemIndex) := to_integer(signed(BitVal)) ; 
    199             1                    ***0***         end loop ;
    200             1                    ***0***         return result ; 
    201                                                end function ToMemoryBaseType_NoX ; 
    202                                                
    203                                                ------------------------------------------------------------
    204                                                function FromMemoryBaseType_NoX(Mem : integer_vector ; Size : integer) return std_logic_vector is 
    205                                                ------------------------------------------------------------
    206                                                  constant NumIntegers   : integer := Mem'length ; 
    207                                                  alias    NormalizedMem : integer_vector(NumIntegers-1 downto 0) is Mem ; 
    208                                                  variable NormalizedSlv : std_logic_vector(NumIntegers*32-1 downto 0) ;
    209                                                  variable Bits32        : std_logic_vector(31 downto 0) ;
    210                                                  variable BitVal        : std_logic_vector(31 downto 0) ;
    211                                                begin
    212             1                    ***0***         for MemIndex in NormalizedMem'reverse_range loop 
    212             2                    ***0***     
    213             1                    ***0***           Bits32 := std_logic_vector(to_signed(NormalizedMem(MemIndex), 32)) ;
    214             1                    ***0***           NormalizedSlv(32*MemIndex+31 downto 32*MemIndex) := Bits32 ;
    215             1                    ***0***         end loop ; 
    216             1                    ***0***         return NormalizedSlv(Size-1 downto 0) ; 
    217                                                end function FromMemoryBaseType_NoX ; 
    218                                                
    219                                                ------------------------------------------------------------
    220                                                function InitMemoryBaseType_NoX(Size : integer) return integer_vector is  
    221                                                ------------------------------------------------------------
    222                                                  constant BaseU : integer_vector(0 to Size-1)  := (others => 0) ;
    223                                                begin
    224             1                    ***0***         return BaseU ; 
    225                                                end function InitMemoryBaseType_NoX ; 
    226                                              
    227                                              
    228                                                ------------------------------------------------------------
    229                                                -- Memory policy orig 
    230                                                --   For backward compatibility only
    231                                                --   upto 31 bits of data
    232                                                --   X or U in any bit and the word becomes X
    233                                                ------------------------------------------------------------
    234                                                ------------------------------------------------------------
    235                                                function SizeMemoryBaseType_orig(Size : integer) return integer is  
    236                                                ------------------------------------------------------------
    237                                                begin
    238                                                  -- would be better as an alert, but not worth the pain since this is deprecated
    239                                                  assert Size < 32 report "MemoryPkg.MemInit/NewID.  DataWidth = " & to_string(Size) & " must be < 32 " severity FAILURE ; 
    240             1                    ***0***         return 1 ; 
    241                                                end function SizeMemoryBaseType_orig ; 
    242                                              
    243                                                ------------------------------------------------------------
    244                                                function ToMemoryBaseType_orig(Slv : std_logic_vector ; Size : integer) return integer_vector is 
    245                                                ------------------------------------------------------------
    246                                                  variable result : integer ; 
    247                                                begin
    248                                                  if (Is_X(Slv)) then 
    249             1                    ***0***           result := -1 ;
    250                                                  else
    251             1                    ***0***           result := to_integer( Slv ) ;
    252                                                  end if ;
    253             1                    ***0***         return (1 => result) ; 
    254                                                end function ToMemoryBaseType_orig ; 
    255                                                
    256                                                ------------------------------------------------------------
    257                                                function FromMemoryBaseType_orig(Mem : integer_vector ; Size : integer) return std_logic_vector is 
    258                                                ------------------------------------------------------------
    259                                                  variable Data : std_logic_vector(Size-1 downto 0) ; 
    260                                                begin
    261                                                  if Mem(Mem'left) >= 0 then 
    262                                                    -- Get the Word from the Array
    263             1                    ***0***           Data := to_slv(Mem(Mem'left), Size) ;
    264                                                  elsif Mem(Mem'left) = -1 then 
    265                                                   -- X in Word, return all X
    266             1                    ***0***           Data := (Data'range => 'X') ;
    267                                                  else 
    268                                                   -- Location Uninitialized, return all X
    269             1                    ***0***           Data := (Data'range => 'U') ;
    270                                                  end if ;
    271             1                    ***0***         return Data ; 
    272                                                end function FromMemoryBaseType_orig ; 
    273                                                
    274                                                ------------------------------------------------------------
    275                                                function InitMemoryBaseType_orig(Size : integer) return integer_vector is  
    276                                                ------------------------------------------------------------
    277                                                begin
    278             1                    ***0***         return (1 => integer'left) ; 
    279                                                end function InitMemoryBaseType_orig ; 
    280                                               
    281                                              end MemorySupportPkg ;


=================================================================================
=== File: ../osvvm/osvvm/ReportPkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                        18         0        18     0.00%

================================Branch Details================================

Branch Coverage for file ../osvvm/osvvm/ReportPkg.vhd --

------------------------------------IF Branch------------------------------------
    102                                  ***0***     Count coming in to IF
    102             1                    ***0***         if GotCoverage then 
    104             1                    ***0***         else
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    134                                  ***0***     Count coming in to IF
    134             1                    ***0***         if GotCoverage then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    140                                  ***0***     Count coming in to IF
    140             1                    ***0***         if work.ScoreboardPkg_slv.GotScoreboards then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    146                                  ***0***     Count coming in to IF
    146             1                    ***0***         if work.ScoreboardPkg_unsigned.GotScoreboards then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    152                                  ***0***     Count coming in to IF
    152             1                    ***0***         if work.ScoreboardPkg_signed.GotScoreboards then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    158                                  ***0***     Count coming in to IF
    158             1                    ***0***         if work.ScoreboardPkg_int.GotScoreboards then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    164                                  ***0***     Count coming in to IF
    164             1                    ***0***         if work.ScoreboardPkg_IntV.GotScoreboards then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    170                                  ***0***     Count coming in to IF
    170             1                    ***0***         if GotRequirements then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%

------------------------------------IF Branch------------------------------------
    210                                  ***0***     Count coming in to IF
    210             1                    ***0***         if Stop then 
                                         ***0***     All False Count
Branch totals: 0 hits of 2 branches = 0.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      27         0        27     0.00%

================================Statement Details================================

Statement Coverage for file ../osvvm/osvvm/ReportPkg.vhd --

    1                                                --
    2                                                --  File Name:         ReportPkg.vhd
    3                                                --  Design Unit Name:  ReportPkg
    4                                                --  Revision:          STANDARD VERSION
    5                                                --
    6                                                --  Maintainer:        Jim Lewis      email:  jim@synthworks.com
    7                                                --  Contributor(s):
    8                                                --     Jim Lewis      jim@synthworks.com
    9                                                --
    10                                               --  Description:
    11                                               --        Generate Final Reports
    12                                               --        Elements of these reports come from AlertLogPkg, CoveragePkg, and 
    13                                               --        the ScoreboardGenericPkg instances of ScoreboardPkg_int and ScoreboardPkg_slv
    14                                               --
    15                                               --  Developed for:
    16                                               --        SynthWorks Design Inc.
    17                                               --        VHDL Training Classes
    18                                               --        11898 SW 128th Ave.  Tigard, Or  97223
    19                                               --        http://www.SynthWorks.com
    20                                               --
    21                                               --  Revision History:
    22                                               --    Date      Version    Description
    23                                               --    07/2024   2024.07    Added timeout flag to EndOfTestReports. 
    24                                               --                         Added scoreboard reporting for: unsigned, signed, and IntV
    25                                               --    12/2023   2024.01    Updated WriteCovSummaryYaml to print FunctionalCoverage:  "" when no functional coverage (to work with TCL 8.5).
    26                                               --    09/2023   2023.09    Added WriteSimTimeYaml.
    27                                               --    07/2023   2023.07    Added call to WriteRequirementsYaml.
    28                                               --    04/2023   2023.04    Added TranscriptOpen without parameters 
    29                                               --    01/2023   2023.01    OSVVM_RAW_OUTPUT_DIRECTORY replaced REPORTS_DIRECTORY 
    30                                               --                         Added simple TranscriptOpen that uses GetTestName
    31                                               --    06/2022   2022.06    Minor reordering of EndOfTestReports
    32                                               --    02/2022   2022.02    EndOfTestReports now calls WriteScoreboardYaml
    33                                               --    10/2021   2021.10    Initial revision
    34                                               --
    35                                               --  This file is part of OSVVM.
    36                                               --
    37                                               --  Copyright (c) 2021-2024 by SynthWorks Design Inc.
    38                                               --
    39                                               --  Licensed under the Apache License, Version 2.0 (the "License");
    40                                               --  you may not use this file except in compliance with the License.
    41                                               --  You may obtain a copy of the License at
    42                                               --
    43                                               --      https://www.apache.org/licenses/LICENSE-2.0
    44                                               --
    45                                               --  Unless required by applicable law or agreed to in writing, software
    46                                               --  distributed under the License is distributed on an "AS IS" BASIS,
    47                                               --  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    48                                               --  See the License for the specific language governing permissions and
    49                                               --  limitations under the License.
    50                                               --
    51                                               
    52                                               use std.textio.all ;
    53                                               
    54                                               use work.OsvvmScriptSettingsPkg.all ;
    55                                               use work.TranscriptPkg.all ; 
    56                                               use work.AlertLogPkg.all ;
    57                                               use work.CoveragePkg.all ;
    58                                               use work.ScoreboardPkg_slv.all ;
    59                                               use work.ScoreboardPkg_signed.all ;
    60                                               use work.ScoreboardPkg_unsigned.all ;
    61                                               use work.ScoreboardPkg_int.all ;
    62                                               use work.ScoreboardPkg_IntV.all ;
    63                                               
    64                                               
    65                                               package ReportPkg is
    66                                               
    67                                                 impure function EndOfTestReports (
    68                                                   ReportAll      : boolean        := FALSE ;
    69                                                   ExternalErrors : AlertCountType := (0,0,0) ;
    70                                                   TimeOut        : boolean        := FALSE 
    71                                                 ) return integer ;
    72                                               
    73                                                 procedure EndOfTestReports (
    74                                                   ReportAll      : boolean        := FALSE ;
    75                                                   ExternalErrors : AlertCountType := (0,0,0) ;
    76                                                   Stop           : boolean        := FALSE ;
    77                                                   TimeOut        : boolean        := FALSE 
    78                                                 ) ;
    79                                                 
    80                                                 procedure TranscriptOpen (OpenKind: WRITE_APPEND_OPEN_KIND := WRITE_MODE) ;
    81                                                 procedure TranscriptOpen (Status: InOut FILE_OPEN_STATUS; OpenKind: WRITE_APPEND_OPEN_KIND := WRITE_MODE) ;
    82                                               
    83                                                 alias EndOfTestSummary is EndOfTestReports[boolean, AlertCountType, boolean return integer] ;
    84                                                 alias EndOfTestSummary is EndOfTestReports[boolean, AlertCountType, boolean, boolean] ;
    85                                               
    86                                               end ReportPkg ;
    87                                               
    88                                               --- ///////////////////////////////////////////////////////////////////////////
    89                                               --- ///////////////////////////////////////////////////////////////////////////
    90                                               --- ///////////////////////////////////////////////////////////////////////////
    91                                               
    92                                               package body ReportPkg is
    93                                               
    94                                                 ------------------------------------------------------------
    95                                                 procedure WriteCovSummaryYaml (FileName : string ) is
    96                                                 ------------------------------------------------------------
    97                                               --x    file OsvvmYamlFile : text open APPEND_MODE is FileName ;
    98                                                   file OsvvmYamlFile : text ;
    99                                                   variable buf : line ;
    100                                                begin
    101             1                    ***0***         file_open(OsvvmYamlFile, FileName, APPEND_MODE) ;
    102                                                  if GotCoverage then 
    103             1                    ***0***           swrite(buf, "        FunctionalCoverage: " & to_string(GetCov, 2)) ; 
    104                                                  else
    105             1                    ***0***           swrite(buf, "        FunctionalCoverage:  " & """""") ; 
    106                                                  end if ; 
    107             1                    ***0***         writeline(OsvvmYamlFile, buf) ; 
    108             1                    ***0***         file_close(OsvvmYamlFile) ;
    109                                                end procedure WriteCovSummaryYaml ;
    110                                              
    111                                                ------------------------------------------------------------
    112                                                procedure WriteSimTimeYaml (FileName : string ) is
    113                                                ------------------------------------------------------------
    114                                              --x    file OsvvmYamlFile : text open APPEND_MODE is FileName ;
    115                                                  file OsvvmYamlFile : text ;
    116                                                  variable buf : line ;
    117                                                begin
    118             1                    ***0***         file_open(OsvvmYamlFile, FileName, APPEND_MODE) ;
    119             1                    ***0***         swrite(buf, "        SimulationTime: """ & to_string(NOW) & '"') ; 
    120             1                    ***0***         writeline(OsvvmYamlFile, buf) ; 
    121             1                    ***0***         file_close(OsvvmYamlFile) ;
    122                                                end procedure WriteSimTimeYaml ;
    123                                              
    124                                                ------------------------------------------------------------
    125                                                impure function EndOfTestReports (
    126                                                ------------------------------------------------------------
    127                                                  ReportAll      : boolean        := FALSE ;
    128                                                  ExternalErrors : AlertCountType := (0,0,0) ;
    129                                                  TimeOut        : boolean        := FALSE 
    130                                                ) return integer is
    131                                                begin
    132             1                    ***0***         ReportAlerts(ExternalErrors => ExternalErrors, ReportAll => ReportAll, TimeOut => TimeOut) ; 
    133                                                  
    134                                                  if GotCoverage then 
    135                                                    WriteCovYaml (
    136                                                      FileName      => OSVVM_RAW_OUTPUT_DIRECTORY &  GetTestName & "_cov.yml"
    137             1                    ***0***           ) ;
    138                                                  end if ; 
    139                                                  
    140                                                  if work.ScoreboardPkg_slv.GotScoreboards then 
    141                                                    work.ScoreboardPkg_slv.WriteScoreboardYaml (
    142                                                      FileName => "slv", FileNameIsBaseName => TRUE
    143             1                    ***0***           ) ;
    144                                                  end if ; 
    145                                                  
    146                                                  if work.ScoreboardPkg_unsigned.GotScoreboards then 
    147                                                    work.ScoreboardPkg_unsigned.WriteScoreboardYaml (
    148                                                      FileName => "unsigned", FileNameIsBaseName => TRUE
    149             1                    ***0***           ) ;
    150                                                  end if ; 
    151                                              
    152                                                  if work.ScoreboardPkg_signed.GotScoreboards then 
    153                                                    work.ScoreboardPkg_signed.WriteScoreboardYaml (
    154                                                      FileName => "signed", FileNameIsBaseName => TRUE
    155             1                    ***0***           ) ;
    156                                                  end if ; 
    157                                              
    158                                                  if work.ScoreboardPkg_int.GotScoreboards then 
    159                                                    work.ScoreboardPkg_int.WriteScoreboardYaml (
    160                                                      FileName => "int", FileNameIsBaseName => TRUE
    161             1                    ***0***           ) ;
    162                                                  end if ; 
    163                                              
    164                                                  if work.ScoreboardPkg_IntV.GotScoreboards then 
    165                                                    work.ScoreboardPkg_IntV.WriteScoreboardYaml (
    166                                                      FileName => "IntV", FileNameIsBaseName => TRUE
    167             1                    ***0***           ) ;
    168                                                  end if ; 
    169                                              
    170                                                  if GotRequirements then 
    171                                                    WriteRequirementsYaml (
    172                                                      FileName      => OSVVM_RAW_OUTPUT_DIRECTORY &  GetTestName & "_req.yml"
    173             1                    ***0***           ) ;
    174                                                  end if ; 
    175                                                  
    176                                                  -- Summarize Alerts Last to allow previous steps to update Alerts
    177                                                  WriteAlertSummaryYaml(
    178                                                    FileName        => OSVVM_BUILD_YAML_FILE, 
    179                                                    ExternalErrors  => ExternalErrors,
    180                                                    TimeOut         => TimeOut
    181             1                    ***0***         ) ; 
    182                                                  WriteCovSummaryYaml (
    183                                                    FileName        => OSVVM_BUILD_YAML_FILE
    184             1                    ***0***         ) ;
    185                                                  WriteSimTimeYaml (
    186                                                    FileName        => OSVVM_BUILD_YAML_FILE
    187             1                    ***0***         ) ;
    188                                                  WriteAlertYaml (
    189                                                    FileName        => OSVVM_RAW_OUTPUT_DIRECTORY &  GetTestName & "_alerts.yml", 
    190                                                    ExternalErrors  => ExternalErrors,
    191                                                    TimeOut         => TimeOut
    192             1                    ***0***         ) ; 
    193                                                  
    194             1                    ***0***         TranscriptClose ; -- Close Transcript if open
    195                                              
    196             1                    ***0***         return SumAlertCount(GetAlertCount + ExternalErrors) ;
    197                                                end function EndOfTestReports ;
    198                                              
    199                                                ------------------------------------------------------------
    200                                                procedure EndOfTestReports (
    201                                                ------------------------------------------------------------
    202                                                  ReportAll      : boolean        := FALSE ;
    203                                                  ExternalErrors : AlertCountType := (0,0,0) ;
    204                                                  Stop           : boolean        := FALSE ;
    205                                                  TimeOut        : boolean        := FALSE 
    206                                                ) is
    207                                                  variable ErrorCount : integer ; 
    208                                                begin
    209             1                    ***0***         ErrorCount := EndOfTestReports(ReportAll, ExternalErrors, TimeOut) ;
    210                                                  if Stop then 
    211             1                    ***0***           std.env.stop ; 
    212                                                  end if ;
    213                                                end procedure EndOfTestReports ;
    214                                              
    215                                                ------------------------------------------------------------
    216                                                procedure TranscriptOpen (OpenKind: WRITE_APPEND_OPEN_KIND := WRITE_MODE) is
    217                                                ------------------------------------------------------------
    218                                                  variable Status : FILE_OPEN_STATUS ; 
    219                                                begin
    220             1                    ***0***         TranscriptOpen(Status, OSVVM_RAW_OUTPUT_DIRECTORY & GetTranscriptName, OpenKind) ;
    221                                                end procedure TranscriptOpen ; 
    222                                              
    223                                                ------------------------------------------------------------
    224                                                procedure TranscriptOpen (Status: InOut FILE_OPEN_STATUS; OpenKind: WRITE_APPEND_OPEN_KIND := WRITE_MODE) is
    225                                                ------------------------------------------------------------
    226                                                begin
    227             1                    ***0***         TranscriptOpen(Status, OSVVM_RAW_OUTPUT_DIRECTORY & GetTranscriptName, OpenKind) ;
    228                                                end procedure TranscriptOpen ; 
    229                                                
    230                                              
    231                                              
    232                                              end package body ReportPkg ;


=================================================================================
=== File: avmm_pkg.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                         2         2         0   100.00%

================================Branch Details================================

Branch Coverage for file avmm_pkg.vhd --

------------------------------------IF Branch------------------------------------
    135                                        2     Count coming in to IF
    135             1                          1           if unsigned(write_mask(i*8 to (i+1)*8-1)) > 0 then
                                               1     All False Count
Branch totals: 2 hits of 2 branches = 100.00%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      15        15         0   100.00%

================================Statement Details================================

Statement Coverage for file avmm_pkg.vhd --

    1                                                library ieee;
    2                                                  use ieee.std_logic_1164.all;
    3                                                  use ieee.numeric_std.all;
    4                                                
    5                                                library osvvm;
    6                                                  context osvvm.OsvvmContext;
    7                                                
    8                                                library osvvm_common ;
    9                                                  context osvvm_common.OsvvmCommonContext ; 
    10                                               
    11                                               package avmm_pkg is
    12                                               
    13                                                 type AvmmPinoutT is record
    14                                                   address            : std_logic_vector;
    15                                                   writedata          : std_logic_vector;
    16                                                   readdata           : std_logic_vector;
    17                                                   byteenable         : std_logic_vector;
    18                                                   read               : std_logic;
    19                                                   write              : std_logic;
    20                                                 end record;
    21                                               
    22                                                 procedure AvmmWrite(signal trans: inout AddressBusRecType; addr, data, byte_enable: std_logic_vector);
    23                                                 procedure AvmmRead(signal trans: inout AddressBusRecType; addr, byte_enable: std_logic_vector; variable read_data: out std_logic_vector);
    24                                                 procedure AvmmReadModifyWrite(signal trans: inout AddressBusRecType; addr, data, write_mask: std_logic_vector);
    25                                               
    26                                                 /*
    27                                                   type AddressBusRecType is record
    28                                                   -- Handshaking controls
    29                                                   --   Used by RequestTransaction in the Transaction Procedures
    30                                                   --   Used by WaitForTransaction in the Verification Component
    31                                                   --   RequestTransaction and WaitForTransaction are in osvvm.TbUtilPkg
    32                                                   Rdy                : RdyType ;
    33                                                   Ack                : AckType ;
    34                                                   -- Transaction Type
    35                                                   Operation          : AddressBusOperationType ;
    36                                                   -- Address to verification component and its width
    37                                                   -- Width may be smaller than Address
    38                                                   Address            : std_logic_vector_max_c ;
    39                                                   AddrWidth          : integer_max ;
    40                                                   -- Data to and from the verification component and its width.
    41                                                   -- Width will be smaller than Data for byte operations
    42                                                   -- Width size requirements are enforced in the verification component
    43                                                   DataToModel        : std_logic_vector_max_c ;
    44                                                   DataFromModel      : std_logic_vector_max_c ;
    45                                                   DataWidth          : integer_max ;
    46                                                   -- Burst FIFOs
    47                                                   WriteBurstFifo     : ScoreboardIdType ; 
    48                                                   ReadBurstFifo      : ScoreboardIdType ; 
    49                                                   --    UseCheckFifo       : boolean_max ; 
    50                                                   --    CheckFifo          : ScoreboardIdType ; 
    51                                                   -- Parameters - internal settings for the VC in a singleton data structure   
    52                                                   Params             : ModelParametersIDType ;  
    53                                                   -- StatusMsgOn provides transaction messaging override.
    54                                                   -- When true, print transaction messaging independent of 
    55                                                   -- other verification based based controls.
    56                                                   StatusMsgOn        : boolean_max ;
    57                                                   -- Verification Component Options Parameters - used by SetModelOptions
    58                                                   IntToModel         : integer_max ;
    59                                                   IntFromModel       : integer_max ; 
    60                                                   BoolToModel        : boolean_max ; 
    61                                                   BoolFromModel      : boolean_max ;
    62                                                   TimeToModel        : time_max ; 
    63                                                   TimeFromModel      : time_max ; 
    64                                                   -- Verification Component Options Type  
    65                                                   Options            : integer_max ;  
    66                                                   end record AddressBusRecType ;
    67                                                 */
    68                                               
    69                                                 subtype AvmmRecType is AddressBusRecType(
    70                                                   Address(4 downto 0),
    71                                                   DataToModel(15 downto 0),
    72                                                   DataFromModel(15 downto 0)
    73                                                 );
    74                                                 subtype AvmmPinoutR is AvmmPinoutT(    
    75                                                   address(4 downto 0),
    76                                                   writedata(15 downto 0),
    77                                                   readdata(15 downto 0),
    78                                                   byteenable(1 downto 0)
    79                                                   );
    80                                               
    81                                                 function to_string(val: AvmmPinoutT) return string;
    82                                                 function Match (
    83                                                   constant  Actual          : in    AvmmPinoutT ;
    84                                                   constant  Expected        : in    AvmmPinoutT
    85                                                 ) return boolean; 
    86                                               end package;
    87                                               
    88                                               package body avmm_pkg is
    89                                                 function to_string(val: AvmmPinoutT) return string is
    90                                                 begin
    91                                                   return "AvmmPinoutT: address(0x" & to_string(val.address) &
    92                                                     ") writedata(0x" & to_string(val.writedata)  &
    93                                                     ") readdata(0x" & to_string(val.readdata) &
    94                                                     ") byteenable(0x" & to_string(val.byteenable) &
    95                                                     ") read(" & to_string(val.read) &
    96              1                          6           ") write(" & to_string(val.write) & ");";
    97                                                 end function;
    98                                               
    99                                                 function Match (
    100                                                    constant  Actual   : in AvmmPinoutT ;
    101                                                    constant  Expected : in AvmmPinoutT
    102                                                  ) return boolean is
    103                                                begin
    104                                                  return (Actual.address = Expected.address) and
    105                                                         (Actual.write = '0' -- dont care otherwise
    106                                                            or (Actual.write = '1' and Actual.writedata = Expected.writedata)) and 
    107                                                         (Actual.read = '0' -- dont care otherwise
    108                                                            or (Actual.read = '1' and Actual.readdata = Expected.readdata)) and 
    109                                                         (Actual.byteenable = Expected.byteenable) and
    110                                                         (Actual.read = Expected.read) and
    111             1                          6                (Actual.write = Expected.write);
    112                                                end function;
    113                                              
    114                                                procedure AvmmWrite(signal trans: inout AddressBusRecType; addr, data, byte_enable: std_logic_vector) is
    115                                                begin
    116                                                  -- Enter your code here
    117             1                          2         trans.intToModel <= to_integer(unsigned(byte_enable));
    118             1                          2         write(trans, addr, data);
    119                                                end procedure;
    120                                              
    121                                                procedure AvmmRead(signal trans: inout AddressBusRecType; addr, byte_enable: std_logic_vector; variable read_data: out std_logic_vector) is
    122                                                  variable data : std_logic_vector(trans.dataFromModel'range) := (others => '0');
    123                                                begin
    124                                                  -- Enter your code here
    125             1                          1         trans.intToModel <= to_integer(unsigned(byte_enable));
    126             1                          1         read(trans, addr, data);
    127             1                          1         read_data := data;
    128                                                end procedure;
    129                                              
    130                                                procedure AvmmReadModifyWrite(signal trans: inout AddressBusRecType; addr, data, write_mask: std_logic_vector) is
    131                                                  variable data_r : std_logic_vector(trans.dataFromModel'range) := (others => '0');
    132                                                  variable byte_enable : std_logic_vector(trans.dataFromModel'length - 1 / 8 downto 0) := (others => '0');
    133                                                begin
    134             1                          1         for i in 0 to write_mask'length / 8 - 1 loop
    134             2                          2     
    135                                                    if unsigned(write_mask(i*8 to (i+1)*8-1)) > 0 then
    136             1                          1             byte_enable(write_mask'length / 8 - 1 - i) := '1';
    137                                                    end if;
    138             1                          2         end loop;
    139                                              
    140             1                          1         trans.intToModel <= to_integer(unsigned(byte_enable));
    141             1                          1         read(trans, addr, data_r);
    142                                                  -- additonal step, not done by avmm
    143             1                          1         data_r := (data_r and not write_mask) or (data and write_mask);
    144             1                          1         write(trans, addr, data_r);
    145                                                end procedure;
    146                                                
    147                                              end package body;


=================================================================================
=== File: avmm_vu.vhd
=================================================================================
Branch Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Branches                         3         2         1    66.66%

================================Branch Details================================

Branch Coverage for file avmm_vu.vhd --

------------------------------------CASE Branch------------------------------------
    46                                         5     Count coming in to CASE
    47              1                          3             when WRITE_OP =>
    55              1                          2             when READ_OP =>
    64              1                    ***0***             when others => -- not part of coverage
Branch totals: 2 hits of 3 branches = 66.66%


Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      22        21         1    95.45%

================================Statement Details================================

Statement Coverage for file avmm_vu.vhd --

    1                                                library ieee;
    2                                                  use ieee.std_logic_1164.all;
    3                                                  use ieee.numeric_std.all;
    4                                                  use work.avmm_pkg.all;
    5                                                
    6                                                library osvvm;
    7                                                context osvvm.OsvvmContext;
    8                                                
    9                                                library osvvm_common;
    10                                               context osvvm_common.OsvvmCommonContext;
    11                                               
    12                                               entity avmm_vu is
    13                                                 port (
    14                                                   trans_io: inout AddressBusRecType;
    15                                                   clk_i   : in    std_logic;
    16                                                   pins_io : inout AvmmPinoutT
    17                                                 );
    18                                               end entity;
    19                                               
    20                                               architecture behav of avmm_vu is
    21                                               
    22                                                 -- Enter your code here
    23                                               
    24                                                 constant IDLE_PINS : AvmmPinoutT := (
    25                                                   address => (pins_io.address'range => '0'),
    26                                                   writedata => (pins_io.writedata'range => '0'),
    27                                                   readdata => (pins_io.readdata'range => 'Z'), -- VU is not supposed to drive this
    28                                                   byteenable => (pins_io.byteenable'range => '0'),
    29                                                   read => '0',
    30                                                   write => '0'
    31                                                 );
    32                                               begin
    33                                               
    34              1                          1       sequencer_p: process is
    35                                                   variable read_data : std_logic_vector(pins_io.readdata'range);
    36                                                   variable wait_cycles_v : integer;
    37                                                 begin
    38                                                   -- apply default values to the pins
    39                                                   -- Enter your code here
    40                                               
    41              1                          1         pins_io <= IDLE_PINS;
    42                                               
    43              1                          1         wait for 0 ns;
    44              1                          6         dispatcher_loop: loop
    45              1                          6           WaitForTransaction(clk => clk_i, Rdy => trans_io.Rdy, Ack => trans_io.Ack);
    46                                                     case trans_io.Operation is
    47                                                       when WRITE_OP =>
    48              1                          3               pins_io.address <= std_logic_vector(trans_io.Address);
    49              1                          3               pins_io.writedata <= std_logic_vector(trans_io.DataToModel);
    50              1                          3               pins_io.write <= '1';
    51              1                          3               pins_io.byteenable <= std_logic_vector(to_unsigned(trans_io.IntToModel, pins_io.byteenable'length));
    52              1                          3               WaitForClock(clk_i, 1);
    53              1                          3               pins_io <= IDLE_PINS;
    54              1                          3               wait for 0 ns;
    55                                                       when READ_OP =>
    56              1                          2               pins_io.address <= std_logic_vector(trans_io.Address);
    57              1                          2               pins_io.read <= '1';
    58              1                          2               pins_io.byteenable <= std_logic_vector(to_unsigned(trans_io.IntToModel, pins_io.byteenable'length));
    59              1                          2               WaitForClock(clk_i, 2);
    60              1                          2               wait for 0 ns;
    61              1                          2               trans_io.DataFromModel <= ToTransaction(pins_io.readdata);
    62              1                          2               pins_io <= IDLE_PINS;
    63              1                          2               wait for 0 ns;
    64                                                       when others => -- not part of coverage
    65              1                    ***0***               Alert("Unimplemented Transaction", FAILURE);
    66                                                     end case;
    67              1                          5         end loop;
    68                                                 end process;
    69                                               
    70                                               end architecture;


=================================================================================
=== File: ex5.vhd
=================================================================================
Statement Coverage:
    Enabled Coverage              Bins      Hits    Misses  Coverage
    ----------------              ----      ----    ------  --------
    Statements                      45        44         1    97.77%

================================Statement Details================================

Statement Coverage for file ex5.vhd --

    1                                                library common_lib;
    2                                                context common_lib.common_context;
    3                                                use work.avmm_pkg.all;
    4                                                
    5                                                entity ex5 is
    6                                                end entity;
    7                                                
    8                                                architecture behav of ex5 is
    9                                                
    10                                                 -- Define clk_i, trans_io and pins_io with the correct constrained data types
    11                                                 -- Enter your code here
    12                                                 signal trans_io : AvmmRecType;
    13                                                 signal clk_i : std_logic;
    14                                                 signal pins_io : AvmmPinoutR;
    15                                               
    16                                                 package ScoreBoardAVMM is new OSVVM.ScoreboardGenericPkg generic map( 
    17                                                     AvmmPinoutT,
    18                                                     AvmmPinoutT,
    19                                                     Match,
    20                                                     to_string,
    21                                                     to_string
    22                                                   );
    23                                                   use ScoreBoardAVMM.all;
    24                                               
    25                                                   signal avmmScoreBoardID : ScoreBoardIDType; 
    26                                               
    27                                                   constant IDLE_PINS : AvmmPinoutR := (
    28                                                     address => (others => '0'),
    29                                                     writedata => (others => '0'),
    30                                                     readdata => (others => '0'),
    31                                                     byteenable => (others => '0'),
    32                                                     read => '0',
    33                                                     write => '0'
    34                                                   );
    35                                               
    36                                                   signal testdone : std_logic;
    37                                               
    38                                                   -- simulating target memory
    39                                                   type ram_t is array (0 to pins_io.address'length-1) of std_logic_vector(pins_io.writedata'range);
    40                                                   signal ram : ram_t := (others => (others => '0'));
    41                                               
    42                                               begin
    43                                               
    44              1                          1       CreateClock(clk_i, 10 ns);
    45                                               
    46                                                 avmm_vu_inst: entity work.avmm_vu
    47                                                   port map (
    48                                                     trans_io => trans_io,
    49                                                     clk_i    => clk_i,
    50                                                     pins_io  => pins_io
    51                                                   );
    52                                               
    53              1                          1       stimuli_p: process is
    54                                                   variable poppedPins : AvmmPinoutR;
    55                                                   variable read_data: std_logic_vector(pins_io.readdata'range);
    56                                                 begin
    57                                                   -- Implement your main testbench code here
    58                                                   -- Enter your code here
    59              1                          1         Log("**********************************");
    60              1                          1         avmmScoreBoardID <= newId("AVMM Scoreboard");
    61              1                          1         waitForClock(clk_i);
    62              1                          1         Log("***********Check Empty************");
    63                                               
    64              1                          1         push(avmmScoreBoardID, IDLE_PINS);
    65              1                          1         check(avmmScoreBoardID, IDLE_PINS);
    66                                               
    67              1                          1         Log("***********Check Write************");
    68              1                          1         waitForClock(clk_i);
    69                                                   push(avmmScoreBoardID, (
    70                                                     address => "00001",
    71                                                     writedata => x"aa55",
    72                                                     readdata => x"----",
    73                                                     byteenable => "11",
    74                                                     read => '0',
    75                                                     write => '1'
    76              1                          1         ));
    77              1                          1         AvmmWrite(trans_io, "00001", x"aa55", "11");
    78                                               
    79              1                          1         Log("***********Check Write************");
    80              1                          1         waitForClock(clk_i);
    81                                                   push(avmmScoreBoardID, (
    82                                                     address => "00001",
    83                                                     writedata => x"aa55",
    84                                                     readdata => x"----",
    85                                                     byteenable => "11",
    86                                                     read => '0',
    87                                                     write => '1'
    88              1                          1         ));
    89              1                          1         AvmmWrite(trans_io, "00001", x"aa55", "11");
    90                                               
    91              1                          1         Log("***********Check Read************");
    92              1                          1         waitForClock(clk_i);
    93                                                   push(avmmScoreBoardID, (
    94                                                     address => "00001",
    95                                                     writedata => x"----",
    96                                                     readdata => x"aa55",
    97                                                     byteenable => "11",
    98                                                     read => '1',
    99                                                     write => '0'
    100             1                          1         ));
    101             1                          1         AvmmRead(trans_io, "00001", "11", read_data); 
    102             1                          1         waitForClock(clk_i, 5);
    103                                              
    104             1                          1         Log("*****Check Read Modify Write*****");
    105             1                          1         waitForClock(clk_i);
    106                                                  push(avmmScoreBoardID, ( -- cycle 2 read
    107                                                    address => "00001",
    108                                                    writedata => x"----",
    109                                                    readdata => x"aa00",
    110                                                    byteenable => "10",
    111                                                    read => '1',
    112                                                    write => '0'
    113             1                          1         ));
    114                                                  push(avmmScoreBoardID, (
    115                                                    address => "00001",
    116                                                    writedata => x"5500",
    117                                                    readdata => x"----",
    118                                                    byteenable => "10",
    119                                                    read => '0',
    120                                                    write => '1'
    121             1                          1         ));
    122             1                          1         AvmmReadModifyWrite(trans_io, "00001", x"5511", x"ff00");
    123             1                          1         waitForClock(clk_i);
    124             1                          1         waitForClock(clk_i);
    125                                              
    126                                                --  procedure AvmmWrite(signal trans: inout AddressBusRecType; addr, data, byte_enable: std_logic_vector) is
    127                                                --  procedure AvmmRead(signal trans: inout AddressBusRecType; addr, byte_enable: std_logic_vector; variable read_data: out std_logic_vector) is
    128                                                --  procedure AvmmReadModifyWrite(signal trans: inout AddressBusRecType; addr, data, write_mask: std_logic_vector) is
    129                                              
    130             1                          1         ReportAlerts ;
    131             1                          1         Log("***************DONE***************");
    132             1                          1         std.env.stop;
    133             1                    ***0***         wait ; 
    134                                                end process;
    135                                              
    136                                                -- just a process that handles expected reads
    137             1                          1       expected_read_p: process
    138                                                begin
    139             1                          2         wait until pins_io.read = '1';
    140             1                          1         pins_io.readdata <= x"aa55";
    141             1                          1         wait until pins_io.read = '1';
    142             1                          1         pins_io.readdata <= x"aa00";  
    143                                                end process;
    144                                              
    145             1                          1       check_reads_p: process
    146                                                  variable masked : std_logic_vector(pins_io.writedata'range);
    147                                                begin
    148             1                          3         wait until pins_io.read = '1';
    149                                              
    150             1                          2         waitForClock(clk_i, 2);
    151             1                          2         check(avmmScoreBoardID, pins_io);
    152                                                end process;
    153                                              
    154             1                          1       check_writes_p: process
    155                                                  variable masked : std_logic_vector(pins_io.writedata'range);
    156                                                begin
    157             1                          4         wait until pins_io.write = '1';
    158                                              
    159             1                          3         check(avmmScoreBoardID, pins_io);
    160             1                          3         waitForClock(clk_i);
    161                                                end process;
    162                                              
    163                                              end architecture;



Total Coverage By File (code coverage only, filtered view): 2.16%

